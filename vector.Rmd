## 向量 vector



向量是R语言中最基本的数据结构, 其他类型的数据结构都可以由向量构成。

### 向量的类型与长度

最常见的向量有三种类型

* 数值型
* 字符型
* 逻辑型

#### 数值型向量 numeric

假设有这样一个数据集, 包含上海某互联网公司数据部门12个员工的相关信息。

这些员工的身高分别是：176cm, 168cm, 172cm, 165cm, 166cm, 162cm, 181cm, 174cm, 178cm, 171cm, 172cm, 169cm。

R语言中的`向量`, 实际上就是一列数据集合。比如这些员工的身高序列 {176, 168, 172, 165, 166, 162, 181, 174, 178, 171, 172, 169}, 将这些身高数值用`c()`这个函数将其拼接起来, 每个数值之间用英文逗号隔开，就构成了一个向量。 

这个向量中的每个数值就是该向量的一个`元素`。

在R语言中, `<-`是`赋值`符号, 可以将值赋予给一个`对象`，或者说是`变量`。

*** 

下面的示例代码，将这些员工的身高按顺序拼接组合起来，并赋值给名为 `height` 的这个对象。

执行这行代码后，这个 height 对象，就是一个向量。

向量根据其元素的数据类型，可以分为几种不同的数据类型，比如员工的身高都是数值，该类型的向量就是`数值型`。

```{r vector_create_integer}
height <- c(173, 168, 172, 165, 166, 162, 181, 174, 178, 171, 172, 169)
```

上面的`c()`函数，其作用是将每个元素的值合并成一个向量。

R语言中，所谓的`函数`，就是执行某类操作。

在`控制台`中直接输入对象的名字并运行, R语言程序就会将该对象包含的内容打印到显示屏幕上。

屏幕上显示的结果，每行都会以`[1]`这样标识开头，后面跟着具体的向量每个元素的值。

如果在控制台屏幕上一行显示不下，会继续在第二行显示，第二行开头也会以`[n]`开始，至于`n`具体是多少，就看第二行是从第几个元素开始显示。第三行、第四行以此类推。

```{r vector_print}
height
```

*** 

直接运行对象的名字, 实际上等于使用了 `print()` 函数, 两者等价。

```{r vector_print_fun}
print(height)
```

#### 字符型向量 character

这12名员工的姓名分别是：宋子启, 张伯仲, 孟轲舆, 张伟, 王雪梅, 陈梦妍, 李元礼, 杨伯侨, 赵蜚廉, 蒋欣, 沈约度, 陈淮阳。

他们的姓名也可以组成一个向量，姓名是字符，所以向量的类型是`字符型`。

在R语言中, 字符串类型的值需要用引号括起来, 可以使用双引号, 也可以使用单引号。推荐使用双引号。

当然, 无论是哪种引号, 都是英文输入法下的引号, 中文下的引号是不被系统识别的。

实际上，所有以英文为自己的编程语言，所能识别的关键字符都是英文的，比如之前提到的c()函数中连接字符串的逗号，字符串的引号，以及后面陆续会使用的符号，都是在英文输入法环境下的符号，不再累述。

创建12名员工的字符创向量代码如下：

```{r vector_create_character}
name <- c("宋子启", "张伯仲", "孟轲舆", "张伟", "王雪梅", "陈梦妍", "李元礼", "杨伯侨", "赵蜚廉", "蒋欣", "沈约度", "陈淮阳")
```

显示`name`这个向量中的所有名字，并在命令行中添加注释文本。

井号后面文本是代码注释，不会被执行。很多时候在大段的代码中，需要输入一些备注文本说明一些逻辑或者结构等。井号个数不限，井号开始后面的一整行都被注释。

```{r vector_print_comment}
name # 井号后面文本是代码注释，不会被执行
```

#### 逻辑型向量 logical

在公司的员工信息登记表中，还会记录是否本地户口信息，便于办理社会保险等相关事项。相应的也会有该12名员工的是否本地户口信息，如{是，是，否，是，否，否，否，是，否，否，是，是}。

我可以直接使用“是”和“否”两个字符来表示该信息，作为一个字符型向量。

不过，大多数编程语言中都会有专门的一种`逻辑型`数据类型来表示这种是否问题，记录真假值，可以用来做条件判断和逻辑运算。

R语言中，用`TRUE`来表示`逻辑真`，用`FALSE`表示`逻辑假`，也就是计算机二进制的两种状态`0`和`1`。这两个英文字符都是大写，也可以使用`T`和`F`代替。

这里的是否本地户口的原始数据“是”和“否”，我们这里就用`TRUE`和`FALSE`来代替，并创建这个`逻辑型`向量如下：

```{r vector_create_logical}
islocal <- c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE)
islocal
```

#### 向量的类属性 class

“类”是一种对象的属性，用来定义数据结构，是面对对象编程的概念。

这里的“类”，可以理解为对象的数据结构类型。

函数`class()` 获得对象的“类”属性。

对向量来说，向量的类，就是向量的类型。

```{r vector_class}
class(height) # "numeric" 数值型
class(name) # "character" 字符型
class(islocal) # "logical" 逻辑型
```



> 向量的类型，还可以用 `typeof()` 和 `mode()` 这两个函数获得，返回的结果只在“数值型”的向量上略有区别，主要是角度不同。


##### 检验向量的类型

R语言还提供了判断向量是否属于某种类型的一系列函数，对应上面三种类型分别是

* `is.numeric(x)`
* `is.character(x)`
* `is.logical(x)`

其中参数 x 是待检验的对象，该函数返回类型检验结果的逻辑值，TRUE 或 FALSE.

```{r vector_is_class}
is.numeric(height) # "numeric" 数值型
is.character(name) # "character" 字符型
is.logical(islocal) # "logical" 逻辑型
```

判断其他两类是否为数值型
```{r}
is.numeric(name) 
is.numeric(islocal)
```

判断其他两类是否为字符型
```{r}
is.character(height)
is.character(islocal)
```

***

判断其他两类是否为逻辑型
```{r}
is.logical(height)
is.logical(name)
```


#### 向量的长度 length

向量的`长度`，就是向量中包含的`元素`的个数。

获得向量长度的函数是 `length(x)` ，返回的是一个整数。

这里“身高”、“姓名”、“是否本地”三个向量，都是记录了 12 名员工的信息，故而这三个向量长度的结果应该都是 12。

```{r vector_length}
length(height) 
length(name)
length(islocal)
```

#### 单个元素的向量

假设这个数据分析团队现在新加入了一名员工，其身高是 174cm，姓名是“况天佑”，不是本地人。

将这三个数据分别赋值给三个对象，它们分别是只包含一个元素的向量。

```{r vector_length_1}
h1 <- c(174)
h1
n1 <- c("况天佑")
n1
l1 <- c(FALSE)
l1
```

对于单个元素的数据赋值给一个对象时，不需要`c()`函数，因为`c()`函数的作用是将多个元素合并成一个向量。直接将值赋给对象给方便。

```{r vector_length_1_no_c}
h1 <- 174
n1 <- "况天佑"
l1 <- FALSE
```

有些地方会将只包含单个元素的向量，也就是长度为一的向量，另外起一个名字叫“标量”。

实际上，R语言没有`标量`这个说法，也没有判读一个对象是否为标量的函数。

所有的数据都是向量。

```{r vector_length_1_length}
# 单个元素的向量，其长度为 1
length(h1)
length(n1)
length(l1)
```

#### 检验对象是否为向量 is.atomic

判断一个对象是否为向量的函数是 `is.atomic()` , 如果是向量, 则返回值为 `TRUE`, 如果不是则返回 `FALSE`。

这里讨论的“向量”是狭义的概念，是`原子向量`(atomic vector)。

R中还有其他的`广义的向量`，如矩阵和数组，以及`泛化的向量`，如列表。

>- 故而检验对象是否为原子向量是用 `is.atomic()`，而不是`is.vector()`。

```{r vector_is.atomic}
# 长度为 12 的向量，判断结果返回的结果是 TRUE
is.atomic(height) 
is.atomic(name)
is.atomic(islocal)

# 长度为 1 的向量，判断结果返回的结果也是 TRUE
is.atomic(h1) 
is.atomic(n1)
is.atomic(l1)
```


#### 向量的合并 combine

我们将第13名员工的信息，合并到前12名员工的向量中，依然使用 `c()` 函数。

```{r vector_combine_1}
# 这里讲合并后的结果还是还是赋值给原来的对象
# 新对象就包含13个元素
height <- c(height, h1)
height
length(height)

name <- c(name, n1)
name
length(name)

islocal <- c(islocal, l1)
islocal
length(islocal)
```

假设，该团队又有两名新成员加入，依然使用`c()`函数添加，并且可以直接追加向量的值，而不需要先赋予给另一个对象。

```{r vector_combine_15}
# 新对象继续添加了两名员工的信息
# 现在向量的元素一共包含了 15 个员工的信息
height <- c(height, 170, 172)
height
length(height)

name <- c(name, "王珍珍", "马小玲")
name
length(name)

islocal <- c(islocal, TRUE, TRUE)
islocal
length(islocal)
```

#### 不同类型向量转化

向量的一个内在要求是，其内部元素之间的类型要相同。

#### 合并向量时类型不同自动转化

创建或者合并向量时，如果元素类型之间不相同，则会遵循优先兼容递升原则，自动转为兼容性更高的类型。

* 逻辑型会被转为数值型
* 数值型会被转为字符型

> 在数值型向量中，严格意义上来说，还区分两种类型，一个是子类：“整数型”，一个是父类“复数型”，而“数值型”实际上就是“实数型”。

> 在数学上，整数 ∈ 实数 ∈ 复数。

> 按类型转化原则，在数值型之间，整数型会转为实数型，数值型会转为复数型。


```{r}
class(c(TRUE, 1, FALSE, 0)) # 逻辑型转为数值型
print(c(TRUE, 1, FALSE, 0)) # TRUE 转为 1, FASLE 转为 0
class(c(TRUE, "真", FALSE, "假")) # 逻辑型转为数值型
print(c(TRUE, "真", FALSE, "假"))  # TRUE 转为 "TRUE"（字符）, FASLE 转为 "FASLE"（字符）
class(c(3.14, "PI")) # 数值型转为字符型
print(c(3.14, "PI")) # 3.14 转为 "3.14"（字符）
```

*** 
```{r}
print(c(1, 3.14)) # 整数型转为数值型
class(c(3.14, 2 + 5i)) # 数值型转为复数型
print(c(3.14, 2 + 5i)) # 数值型转为复数型
```

##### 强制类型转化函数

类似于 `is.FUN` 一系列向量类型检验函数，强制类型转化也相似的一系列函数

* `as.logical(x)`
* `as.number(x)`
    + `as.integer(x)`
    + `as.complex(x)`
* `as.character(x)`

强制类型转化遵循一定的原则，比如

* 数值型可以转为逻辑型：0 转为逻辑值 FALSE, 非 0 都转为 TRUE
* 字符型可以转为数值型的条件是：去掉字符符号（引号）之后是可以被识别的数值
* 如果不符合转化条件，则强制转化后对应的元素的结果将变成 `NA`，这是 R 语言中的缺失值，因为系统不知道该显示什么值是正确的，相当于信息丢失;

在强制转化过程中如果产生了NA，则会出现系统“警告”。实际上这时候程序已经执行成功了，并不会等待确认或者要放弃执行，警告信息只是一种提醒。

```{r}
as.logical(c(1,0,2)) # 0 转为逻辑值 FALSE, 非 0 都转为 TRUE
as.logical(c(0, 0.68, 1, 3.14)) # 0 转为逻辑值 FALSE, 非 0 都转为 TRUE

as.numeric(name) # 将名字转为数值，得到的都是 NA，程序不知道该转为什么值合适

as.numeric("3.14") # 如果去掉字符型的符号后能被系统识别为数值，则可顺利转化
class(as.numeric("3.14")) # 打印出转化后的类型
```

字符和数值之间类型转化是很常见的。

比如爬虫系统，从网页上爬取所需数据，最迟得到的数据是字符型的（网页是富文本），要做数值运行就需要将其转为数值型。

在需要输出特殊格式化的结果时，通常会将数值转为字符。最常见的例子是，将一个百分比数值显示为带有百分号的格式。


### 等差序列向量 sequence

对这 15 名员工，我想给他们编一个序号，从 1 到 15。

我可以用 `c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)` 这样的原始输入方式获得，但这种手动输入不是很方便，特别是数量很大的时候。

这些数字是有规律的，是`等差`递增向量，其`步长`为 1. 只要是有规律的，实际上程序就可以自动生成。

R语言中有一个专门的函数来生成这种等差序列的向量，该函数是 `seq()` ，其参数是 from 表示开始的数值， to 是结束的数值，by 是步长（每次增加的数值）。

我们用 `seq()` 函数来生成从 1 到 15 的向量，间隔为 1，并将结果赋值给 `no` 这个对象。

```{r vector_seq}
no <- seq(from = 1, to = 15, by = 1)
no
```

函数的参数名称是`形式参数`，其值是`实际参数`, 这里的 from, to, by 是形式参数，其值 1, 15, 1 是对象的实际参数。

在R语言中，形式参数是可以不直接写出来的，这种情况下，按照参数的值所在的位置去对应参数的名称，这样就可以简化一些常用函数的书写过程。

比如上面这个创建等差序列向量的过程，我们就可以简化为

```{r vector_seq_1}
no <- seq(1, 15, 1)
```

函数的参数有时候会定义默认值，比如 `seq()` 中 `by` 的默认值为 1，则在使用该函数的不指定该参数的值，就会在运行过程中使用该参数的默认值，这时候函数的书写就可以进一步简化。

```{r vector_seq_2}
no <- seq(1, 15)
```

这也是之前在使用函数 head() 和 tail() 时，不指定参数 n 的情况下，只显示首尾 6 个元素的原因，因为参数 n 的默认值就是 6.

`seq()` 函数还有另外一个用法，当我们知道等差序列的起止数值，但不知道步长应该是多少，只知道应该产生多少个元素的向量，可以使用参数 length.out 

产生等差序列还有一种情况：已知起始值 from 和 终止值 to ，但不知道步长 by 的值，但知道应该要产生多少个元素的向量，这时可以使用 seq() 函数的另一个参数 length.out , 表示要产生多少个元素。

```{r vector_se_3}
seq(from = 1, to = 15, length.out = 15)
```

但这里要注意的是，seq() 函数中 by 和 length.out 两个参数不能同时使用，只能使用一个，否则会报错。

> 实际上，seq() 函数中如果指定了 length.out 这个参数，则 by 的值会被自动计算出来， by = ((to - from)/(length.out - 1) 。

> 因为等差序列的关键参数还是 from, to 和 by ，程序最终还是需要知道步长是多少，否则无法计算。不能同时指定的原因是，可能会出现用户输入的 by 和从 length.out  计算的 by = ((to - from)/(length.out - 1) 两者不相等，就会出问题。

> 这种情况下 by = ((to - from)/(length.out - 1) 这个表达式，使用了 from, to, length.out 这三个参数的具体的值。R语言中可以允许这种一个参数调用其他参数值的情况，可以使得函数更为灵活。

步长为 1 的等差序列最为常用，故而还有一种更为便捷的书写方式，`n:m`，这种包含符号的写法成为`表达式`。比如 `1:15` 就等价于 seq(1,15) , 等价于 seq(from = 1, to = 15, by = 1)。

> 表达式，本质上也是一种函数。R语言中所有的操作，都是函数过程。

```{r vector_se_4}
n <- 1:15
```

如果我们要等到递减的等差序列，则 to 的值大于 from 即可。

```{r vector_se_5}
15:1
```

另外，等差序列可以产生实数，并不限于整数（上面的值都是整数）。

```{r vector_se_}
seq(from = 0.01, to = 0.15, by = 0.01)
```

> 对于函数的参数是否书写的问题，建议如下：如果已经对该函数中的参数名称、顺序、参数默认值等情况比较清楚，自己简化书写的时候不会产生困惑，则可以简化。在不熟悉的情况下，建议书写完整，容易阅读。

> 另外，函数的各参数之间，尽量空一格；参数名和参数值与等号之间，尽量空一格，使得代码更规范，便于阅读。

### 循环重复向量 replicate

有时候，我们需要产生一些重复的向量，R语言中有专门的函数来处理。

假设我们要对这15名员工做个分组，按照顺序分为3组，每个组给予1,2,3,4,5这样的序号。

R语言中有一个函数 `rep()` ，可以生成具有重复性质的向量，或者说将一个向量按重复循环生成更多元素的向量。

该函数有一个参数 times 可以，可以指定对一个向量重复的次数。

这里的分组，我们就可以先创建一个 c(1, 2, 3, 4, 5) 向量，然后将其循环 3 次到达目标。

```{r vector_rep_1}
three_group_3 <- rep(c(1, 2, 3, 4, 5), times = 3)
print(three_group_3)
```

假设我们做个不同的分组，共分为5组，前3名员工分为第1组，记录他们的组号为1，随后的3名分为第2组，记录为2，直到最后一组，也就是第5组，记录为5。

该函数还有另外一个参数 each，可以指定向量的每个元素按顺序循环的次数。上面的分组我们可以用 each 参数来实现。

```{r vector_rep_2}
three_group_5 <- rep(c(1, 2, 3, 4, 5), each = 3)
print(three_group_5)
```

> rep() 函数中的 times 参数，是对整个向量循环重复；而 each 参数，是对向量中的元素循环重复。

> times 和 each 两个参数是可以同时使用的， `each` 参数的优先级高于 `times` 参数，先循环重复每个元素得到新向量对象，然后再对此新结果整个向量做循环重复。

> times 和 each 的默认参数都是 1 ，故而可以只设定一个即可。多数情况下，我们只选择一种用法，也就是只使用一个参数。

对于 `seq()` 函数的用法，可以使用 `help()` 函数来获得更进一步的信息。执行 `help(seq)` 就会打开一个页面，介绍关于`seq()`函数的各种信息，通常都会包括

* 描述(Description)
* 用法(Usage)
* 参数(Arguments)
* 详情(Details)
* 参数值(Value)
* 参考文献(References)
* 参考更多信息(See Also)
* 示例(Examples)

其中 Arguments 和 Examples 是最有用的部分。

```{r, eval=FALSE}
help(seq) # 查看关于该函数的帮助信息
?seq # 也可以使用“?”开头紧接着函数名的方式
```

### 数值向量的算术运算

这个数据分析团队中的每个成员都已经有身高信息了，我们再来提供他们的体重信息，单位为 kg.

```{r vector_numeric_2}
weight <- c(73, 70, 68, 60, 55, 52, 80, 75, 78, 54, 61, 62, 56, 53, 82)
print(weight)
```

现在，我们想要计算每个人的“身高体重指数”(BMI, Body Mass Index)，计算该指数用来反映一个人的整体营养状态，比如是否偏瘦，还是偏胖等。

身高质量指数的公式是

$$BMI = \frac{w}{h^2}$$

w = 体重, 单位：千克(kg)；

h = 身高，单位：米(m)；

BMI = 身高体重指数，单位：千克/平方米(kg/m^2)


之前的身高向量 height 的单位是 cm(厘米)，按照公式需要，先转换单位为 m(米)，只要每个元素除以100即可。

将一个数值向量，除以一个数值时，每个元素都会做相同的算术运算。

```{r vector_calculate_1}
height <- height / 100 # / 是除法符号，左边除以右边
print(height)
```

这时我们得到了单位为米的身高数据。

我们要计算每个人的身高质量指数，只要对身高和体重两个向量直接做算术运算即可。

当两个向量的长度相同（包含的元素相同）时，算术运算时每个元素都是一一对应的。


```{r vector_calculate_2}
BMI <- weight / (height ^ 2) # ^ 是幂符号，^2就是2次方，也就是平方
print(BMI)
```

最后，我们根据身高质量指数的统计分析对照表来做这 15 名员工的体质做分析。

![](images/Body_mass_index_chart.svg)

总体来说，BMI值小于18.5属于偏瘦，大于25属于偏胖。

从结果上看，第10名员工的BMI约等于18.5，算是标准体质范围；有两位员工需要注意自己的体质健康状况：

* 第14名员工就属于偏瘦，需要多补充点营养即可；
* 第15名员工就属于偏胖，需要加强身体锻炼了。

*** 

R语言中关于数值的算术运算符号及含义见下表

算术运算符号|符号含义
-- | --
+ | 加号，数值相加
- | 减号，数值相减
* | 乘号，数值相乘
/ | 除号，数值相除
%% | 取模，数值相除取不能整除的余数
%/% | 取整，数值相除取整除的部分
^ | 幂，幂运算，x^y 表示 x 连续乘以 x 自身 y 次

```{r}
15 + 6
15 - 6
15 * 6
15 / 6
15 %% 6
15 %/% 6
2^3 
```


### 向量运算的循环补齐

我们再回过头来看 `height/100` 一个向量直接除以一个数值的情况。

我们知道，一个数值，实际上就是一个只包含一个元素的向量。那么这里的情况是，一个包含 15 个元素的向量，除以一个只包含一个元素的向量。

向量的算术运算实际上是需要两个个数相同，每个元素之间相互对应做运算的。那么这里是怎么实现最终的运算的呢？

这里引出了一个R语言向量运算过程中的一个重要概念，向量`循环补齐`。

100这个数值是只包含一个元素的向量，对应要运算的向量是包含15个元素的向量，根据循环补齐原则，这里先向量长度少的向量，按照循环重复的原则补齐到相同长度，使用 `rep()` 的规则，且重复的参数是 `times`。

这里 100 这个单个元素（长度为1的向量），先处理为 rep(100, time = 15) 的向量，再做计算，等价于

```{r vector_calculate_3, eval=FALSE}
height/rep(100, times = 15)
```

如果我们将包含15个元素的体重向量 weight，除以包含4个元素的向量c(1, 2, 3, 4)，会发生什么呢？

```{r vector_calculate_4}
weight/c(1, 2, 3, 4)
```

运算后该表达式会得到一个结果值，但是同时会打印出一条红色警告信息：**“长的对象长度不是短的对象长度的整倍数”** 。

该计算过程会去重复循环长度短的向量，如果“长的对象长度不是短的对象长度的整倍数”，则重复次数 = (长的对象长度/短的对象长度)除数的整数部分 + 1。这里 15/4的除数3倍 + 1 ，times = 4.

c(1, 2, 3, 4) 重复 4 次之后，就得到长度为 16 的向量，比原来长的对象的长度还要多，则多出的部分会被丢弃，使得计算的两个向量长度相同。

因为有丢弃的情况出现，故而计算后会有一个警告信息，作为提示。

如果“长的对象长度”正好是“短的对象长度”的整倍数，则直接循环重复后计算，且不会提出警告信息。

```{r vector_calculate_5}
weight/c(1, 2, 3)
```


### 向量索引与子集筛选

向量是多个元素的集合，当我们只需要指定或者说提取该向量中的某个元素时，就可以使用向量的`索引`(Indexing)。

向量元素可以由三种基本类型的向量索引

* 整数型，索引的是元素位置
* 字符型，索引的是名称属性
* 逻辑型，索引的是相同长度的逻辑向量对应的逻辑值为真的元素



#### 通过元素位置索引向量

第一种元素的索引方式，是通过在向量后面加中括号，其中输入需要索引的元素的位置（第几个）。

比如我们想要获得该数据分析团队中的第2个人的身高，第5个人的名字，第9个人的体重，以及第14个人的身高体重指数，则直接索引对应向量的位置序号即可。

```{r vector_index_1}
height[2] # 第2个人的身高
name[5] # 第5个人的名字
weight[9] # 第9个人的体重
BMI[14] # 第14个人的身高体重指数
```

还是回到单个数值本身就是向量的问题，这里的位置索引，只要求是整数向量即可，故而一次索引多个元素。

```{r vector_index_2}
height[1:5] # 第1到第5个人的身高
name[c(2, 6, 8)] # 第2,6,8个人的名字
weight[c(15, 4, 12, 1)] # 第15,4,12,1个人的体重，具体的顺序可以任意指定
BMI[15:12] # 第15到12个人的身高体重指数
```

这里需要注意的是，作为位置索引的数字整数，不能超过该向量的长度。否则会得到一个值为 NA 的结果，也就是一个空值。

```{r vector_index_3}
height[16] # 第16个元素不存在
name[c(-2, -6, -8)] # 第2,6,8个人的名字
weight[-c(15, 4, 12, 1)] # 第15,4,12,1个人的体重，具体的顺序可以任意指定
BMI[15:12] # 第15到12个人的身高体重指数
```

当我们想要获得排除某个位置元素的剩余其他元素向量的时候，位置索引数字变成负数即可。

```{r vector_index_4}
height[-15] # 排除第15个元素的身高向量
name[c(-2, -6, -8)] # 排除第2,6,8个人的名字
weight[-c(15, 4, 12, 1)] # -c(15, 4, 12, 1) 等价于 -1 * c(15, 4, 12, 1)
BMI[-15:-12] # 排除第15到第12个人的身高体重指数
```



#### 通过名称属性索引向量

向量可以设置一个名称`属性`，从而可以通过名称来索引向量。

名称属性可以通过 `names()` 来指定，将一个包含名称的向量，指定给等长度的向量。

例如，我们将这 15 名员工的姓名向量，赋值给身高向量作为名称属性。

这样，身高向量就具有了名称属性，每个身高元素都会对应一个姓名。print(height) 时候也会将元素的名称显示出来。

```{r vector_index_name_1}
print(name)
print(height)

names(height) <- name # 这里将 name 作为 height 的 names 属性
print(height)
```

通过名称向量即可索引具体的元素，用法和位置索引类似，但是名称是字符，故而索引的名称要作为字符处理，需要添加字符引号。

通过名称来索引，有个显而易见的好处，记住名字比位置更为方便。

```{r vector_index_name_2}
height["马小玲"]
height[c("马小玲","蒋欣")]
```

#### 通过逻辑表达式筛选子集

用逻辑向量来筛选向量元素，也是常见的用法。在索引符号中输入逻辑向量，就会筛选出对应的逻辑为真(TRUE)的元素。

比如，在这 15 名员工中，筛选出户口是本地的员工。现在已经有了 islocal 的逻辑向量，可直接筛选出本地户口的员工了。

```{r vector_index_logic_1}
print(name)
print(islocal)
name[islocal]

# 如果把 islocal 原本的逻辑值显示完整等价于
name[c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE)]
```

如果逻辑向量长度少于被筛选向量, 则会通过向量循环补齐的方式自动补全为与筛选对象等长的逻辑向量在筛选，

```{r vector_index_logic_2}
name[c(TRUE, FALSE, TRUE, FALSE, FALSE)] # 第1个和第3个元素逻辑值为TRUE

# 等价于索引的逻辑向量先循环补齐长度与被筛选对象相同，这里正好是3倍
name[rep(c(TRUE, FALSE, TRUE, FALSE, FALSE), times = 3)] 
```

这种逻辑索引的方式，更为重建的用法是逻辑表达式：一个向量经过逻辑运算后得到相同长度的逻辑向量，然后用此结果逻辑向量来筛选符合逻辑为真的元素。

比如，`weight > 60` 就是一个逻辑表达式，大于号是一个比较运算符，类似于算术运算，这里也是一个向量与另一个向量的对应的值的比较，返回的结果是一个逻辑向量，也就是每个比较的结果，是否为真，为真就记录为 TRUE，否则就记录为 FALSE。

> 这里的 60 虽然只是一个数值，但它就是只包含一个元素的向量，这里的运算还是会类似于算术运算中，先对其做向量循环补齐，然后再一一对应做比较运算。关于单个数值的向量循环补齐原则，后续将不再单独说明。

```{r vector_index_logic_3}
weight > 60 # 逻辑表达式，返回相同长度的逻辑向量
height[weight > 60]
```

如果要对一个逻辑结果做一个转化，真变为假，假变为真，则有一个运算符号来完成，在逻辑表达式前加“!”(英文状态下的惊叹号)，也可以将在一个逻辑表达式前面。

```{r vector_index_logic_4}
weight[!(weight >= 60)] # 这里加入括号，更容易理解其优先级顺序
weight[!weight >= 60] # 这里 !weight >= 60 等价于 !(weight >= 60) 是因为 ! 的优先级比 >= 低
weight[islocal]
weight[!islocal]
weight[!rep(c(TRUE, FALSE, TRUE, FALSE, FALSE), times = 3)]
```

判断一个值是否等于另一个只，是用 “==” 两个连续等号，因为单个等号有其他两个含义，一个是赋值符号，一个是在函数中指定参数值。

而判断一个值是否不等于另一个值，是否“!=”，一个否定的惊叹号紧接着一个等号。这里也是需要特别注意，因为有很多其他的编程语言用了其他的方式来表示不相等，比如“<>”，小于和大于号连用这种方式在R语言中是不能识别的。

```{r vector_index_logic_5}
1 == 1 # TRUE
1 != 1 # FALSE
1 == 2 # FALSE
1 != 2 # TRUE

weight[weight == 80]
weight[weight != 80]
```


下表是常用的比较运算符号及其含义：

比较运算符号|含义
---|---
>|大于
>=|大于等于
<|小于
<=|小于等于
==|等于
!=|等于

#### 通过 subset() 筛选子集

R语言中，有一个专门用来筛选子集的函数 `subset()`, 其参数为待筛选子集的对象，和一个逻辑表达式。

对向量来说，subset() 的用法和逻辑表达式筛选是类似的，subset()的含义，更多的是使用函数来操作，这在管道操作中比较有效，而不是“[]”这种符号化的操作。

```{r vector_subset_1}
subset(weight, weight >= 60) # 等价于 weight[weight >= 60]
```


#### 通过 head() 和 tail() 筛选首尾向量

有时候，我们想要快速的查看某个向量的前几个元素，而不要在屏幕上将所有元素都出来，这样的函数就非常有用。

显示前几个元素函数是 `head()`，默认显示前6个元素。

对应地，也有一个显示最后几个元素的函数是 `tail()`，默认显示最后6个元素。

也就是 `头(head)` 和 `尾(tail)`。


```{r vector_head_tail}
head(height)
head(name)
head(islocal)

tail(height)
tail(name)
head(islocal)
```

`head()` 和 `tail()` 都有一个参数 `n` 可以指定具体显示元素的个数。

```{r vector_head_tail_n}
head(height, n = 10)
head(name, n = 3)
head(islocal, n = 6)

tail(height, n = 10)
tail(name, n = 3)
head(islocal, n = 6)
```

### 因子向量 factor

在这 15 名员工的信息中，现在新添加一列用来存储性别。

在R语言中有一种特殊的数据类型，可以用方便处理类别变量，称其为“因子(factor)”。

`因子`根据类别是否具有顺序上的意义分为两类：

* 无序因子：类别变量并未实际的顺序意义，如性别
* 有序因子：类别变量有实际的顺序意义，如年龄层、收入区间、优良中差等级，类别之间是有大小、高低、好坏等顺序信息的

因子的类别，在R语言中有一个专有的名称，称为“水平(levels)"。

因子是通过 `factor()` 函数来定义的，跟普通的字符型向量创建类似，但需要指定 levels 有哪些，如果是有序因子则还要指定个水平的顺序。

```{r}
gender <- factor(x = c("男", "男", "男", "男", "女", "女", "男",  "男", "男", "女", "男", "男", "男", "女", "女"),
                 levels = c("男", "女")) # 一段完整的代码未结束时，其他参数可另起一行书写
print(gender) # 除了显示该向量具体的类别信息外，还是显示所有水平
class(gender) # 类为 factor
```

***

因子是一种向量，可以用 `is.atomic(x)` 来检验。

检验一个对象是否为因子，可以用 `is.factor(x)` 函数。

```{r}
is.atomic(gender) # 因子是一种向量
is.factor(gender) # 检验一个对象是否为因子
```

> 从对象的类上来说，因子是一种向量，或者说是一种因子型向量，与逻辑型、数值型、字符型相对。



*** 

公司每年在年终结束的时候，需要进行绩效考核，评估员工在过去一年的表现，评级为“优”、“良”、“中”、“差”四种。

而该数据分析团队最终考核是结果只在“优”、“良”、“中”三个等级里，没有人被评级为“差”。在这种情况下，因子的水平就会体现出其作用来。绩效等级因子对应着四个水平，虽然团队考核最终只出现了三种，但从因子水平中可以看到有四种。

“优”、“良”、“中”、“差”四个等级，依次从好到差，是有顺序的，这种情况下因子的顺序也变成了一种有用的信息。

```{r}
grade <- factor(x = c("中", "良", "良", "中", "优", "良", "中",  "优", "中", "良", "良", "中", "良", "中", "优"),
                 levels = c("差", "中", "良", "优"),
                 ordered = TRUE) # ordered = TRUE 使用排序，具体的排序就是levels中的先后顺序，从小到大（从低到高）
print(grade) # 除了显示该向量具体的类别信息外，还是显示所有水平
class(grade) # 有序的因子出了 factor 类之外，还有一个 ordered 的类
```

类似地，可以检验该对象是否为向量，是否为因子，是否是有序的。

```{r}
is.atomic(grade) # 因子是一种向量
is.factor(grade) # 检验一个对象是否为因子对象
is.ordered(grade) # 检验一个对象是否为有序对象
```

因子在统计分析中可能会用的比较多，但在我自己的实践中用得很少，多数情况下可以将其作为字符型向量使用即可。

我个人会在 ggplot2 的画图中有时会用到有序的因子，用来指定图例和分面的顺序。


### 日期向量 Date

还有一种常用的数据格式是日期型向量，比如该数据分析团队15名成员的出生日期，类似“1984-02-28”这样的日期。

最常用的日期格式是“yyyy-mm-dd”这样表示的，分别代表年月日。如果单就这样用引号引起来的格式，那应该算字符，需要将其特殊定义为“日期”类或者说转化为日期类，系统才能真正识别其为日期。

将系统能够识别为日期的字符串，强制转为为日期类 `as.Date(x)` 是最为常见的定义日期的方法。

```{r}
birthday <- as.Date(c("1984-02-28", "1988-09-26", "1989-07-28", "1990-01-25", "1987-04-30",
                      "1989-12-20", "1992-06-14", "1991-07-01", "1990-08-08", "1985-05-10",
                      "1993-04-01", "1991-03-05", "1991-09-25", "1992-01-31", "1988-02-14"))
print(birthday) # 屏幕上打印的结果，看起来和字符串没什么分别
class(birthday) # 类是 Date 
is.atomic(birthday) # 是否为向量
class(birthday) == "Date" # 系统没有自带的 is.Date 的函数，可以用此方法来检验
```

日期实际上是一种以“日”为单位的时间，是一维单向的向量，只要定义一个点为 0 点，则可用实数来表示。

在 R语言中，系统定义的 0 点是 "1970-01-01"，这与Unix系统中日期的原点保持一致。

> 实际上起点定义为哪天是无所谓的，因为时间既没有开始也没有结算，只有相对的差值是有意义的。

日期类向量在存储上是以数字来存储的。

日期的差值有意义，故而两个日期值可以相减，得到结果是数值型。从此可以推演出来，两个日期之间不能直接相减，但一个日期与一个数值相加减可以得到另一个有意义的日期值。

```{r}
as.Date("1984-01-02") - as.Date("1984-01-01") # 两个日期之间相差的天数
as.Date("1984-01-01") + 1 # 一个日期加一个天数可以得到另一个日期
Sys.Date() # 系统函数，返回当前日期，并且为日期型
Sys.Date() - 1 # 昨天，定期执行脚本的程序常用系统日期函数引申出来的日期作为变量
```


```{r, echo = FALSE}
# 保存变量到文件中，以便在其他章节中调用
names(height) <- NULL
save(height, file = "rdata/height.RData")
save(weight, file = "rdata/weight.RData")
save(islocal, file = "rdata/islocal.RData")
save(name, file = "rdata/name.RData")
save(gender, file = "rdata/gender.RData")
save(grade, file = "rdata/grade.RData")
save(birthday, file = "rdata/birthday.RData")
```


