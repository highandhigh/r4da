<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>利用R语言进行数据分析</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="利用R语言进行数据分析">
  <meta name="generator" content="bookdown 0.0.71 and GitBook 2.6.7">

  <meta property="og:title" content="利用R语言进行数据分析" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://lixionghui.com/r4da/" />
  
  <meta property="og:description" content="利用R语言进行数据分析" />
  <meta name="github-repo" content="lixionghui/r4da" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="利用R语言进行数据分析" />
  
  <meta name="twitter:description" content="利用R语言进行数据分析" />
  

<meta name="author" content="李雄辉">

<meta name="date" content="2016-08-07">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="index.html">
<link rel="next" href="section-2.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script type='text/javascript'>
      var _vds = _vds || [];
      window._vds = _vds;
      (function(){
        _vds.push(['setAccountId', 'a52f907cf5de9ce2']);
        (function() {
          var vds = document.createElement('script');
          vds.type='text/javascript';
          vds.async = true;
          vds.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'dn-growing.qbox.me/vds.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(vds, s);
        })();
      })();
  </script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">利用R语言进行数据分析</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>前言</a></li>
<li class="chapter" data-level="1" data-path="section-1.html"><a href="section-1.html"><i class="fa fa-check"></i><b>1</b> 基本数据结构</a><ul>
<li class="chapter" data-level="1.1" data-path="section-1.html"><a href="section-1.html#-vector"><i class="fa fa-check"></i><b>1.1</b> 向量 vector</a><ul>
<li class="chapter" data-level="1.1.1" data-path="section-1.html"><a href="section-1.html#section-1.1.1"><i class="fa fa-check"></i><b>1.1.1</b> 向量的类型与长度</a></li>
<li class="chapter" data-level="1.1.2" data-path="section-1.html"><a href="section-1.html#-sequence"><i class="fa fa-check"></i><b>1.1.2</b> 等差序列向量 sequence</a></li>
<li class="chapter" data-level="1.1.3" data-path="section-1.html"><a href="section-1.html#-replicate"><i class="fa fa-check"></i><b>1.1.3</b> 循环重复向量 replicate</a></li>
<li class="chapter" data-level="1.1.4" data-path="section-1.html"><a href="section-1.html#section-1.1.4"><i class="fa fa-check"></i><b>1.1.4</b> 数值向量的算术运算</a></li>
<li class="chapter" data-level="1.1.5" data-path="section-1.html"><a href="section-1.html#section-1.1.5"><i class="fa fa-check"></i><b>1.1.5</b> 向量运算的循环补齐</a></li>
<li class="chapter" data-level="1.1.6" data-path="section-1.html"><a href="section-1.html#section-1.1.6"><i class="fa fa-check"></i><b>1.1.6</b> 向量索引与子集筛选</a></li>
<li class="chapter" data-level="1.1.7" data-path="section-1.html"><a href="section-1.html#-factor"><i class="fa fa-check"></i><b>1.1.7</b> 因子向量 factor</a></li>
<li class="chapter" data-level="1.1.8" data-path="section-1.html"><a href="section-1.html#-date"><i class="fa fa-check"></i><b>1.1.8</b> 日期向量 Date</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="section-1.html"><a href="section-1.html#-matrix"><i class="fa fa-check"></i><b>1.2</b> 矩阵 matrix</a><ul>
<li class="chapter" data-level="1.2.1" data-path="section-1.html"><a href="section-1.html#section-1.2.1"><i class="fa fa-check"></i><b>1.2.1</b> 创建矩阵</a></li>
<li class="chapter" data-level="1.2.2" data-path="section-1.html"><a href="section-1.html#section-1.2.2"><i class="fa fa-check"></i><b>1.2.2</b> 矩阵维度</a></li>
<li class="chapter" data-level="1.2.3" data-path="section-1.html"><a href="section-1.html#section-1.2.3"><i class="fa fa-check"></i><b>1.2.3</b> 矩阵索引</a></li>
<li class="chapter" data-level="1.2.4" data-path="section-1.html"><a href="section-1.html#section-1.2.4"><i class="fa fa-check"></i><b>1.2.4</b> 矩阵合并</a></li>
<li class="chapter" data-level="1.2.5" data-path="section-1.html"><a href="section-1.html#section-1.2.5"><i class="fa fa-check"></i><b>1.2.5</b> 矩阵计算</a></li>
<li class="chapter" data-level="1.2.6" data-path="section-1.html"><a href="section-1.html#section-1.2.6"><i class="fa fa-check"></i><b>1.2.6</b> 矩阵检验与转化</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="section-1.html"><a href="section-1.html#-array"><i class="fa fa-check"></i><b>1.3</b> 数组 array</a></li>
<li class="chapter" data-level="1.4" data-path="section-1.html"><a href="section-1.html#-data.frame"><i class="fa fa-check"></i><b>1.4</b> 数据框 data.frame</a><ul>
<li class="chapter" data-level="1.4.1" data-path="section-1.html"><a href="section-1.html#section-1.4.1"><i class="fa fa-check"></i><b>1.4.1</b> 创建数据框</a></li>
<li class="chapter" data-level="1.4.2" data-path="section-1.html"><a href="section-1.html#section-1.4.2"><i class="fa fa-check"></i><b>1.4.2</b> 数据框的属性</a></li>
<li class="chapter" data-level="1.4.3" data-path="section-1.html"><a href="section-1.html#section-1.4.3"><i class="fa fa-check"></i><b>1.4.3</b> 数据结构与数据汇总</a></li>
<li class="chapter" data-level="1.4.4" data-path="section-1.html"><a href="section-1.html#section-1.4.4"><i class="fa fa-check"></i><b>1.4.4</b> 访问数据框变量</a></li>
<li class="chapter" data-level="1.4.5" data-path="section-1.html"><a href="section-1.html#section-1.4.5"><i class="fa fa-check"></i><b>1.4.5</b> 数据框的长度与类型</a></li>
<li class="chapter" data-level="1.4.6" data-path="section-1.html"><a href="section-1.html#section-1.4.6"><i class="fa fa-check"></i><b>1.4.6</b> 数据框索引与筛选</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="section-1.html"><a href="section-1.html#-list"><i class="fa fa-check"></i><b>1.5</b> 列表 list</a><ul>
<li class="chapter" data-level="1.5.1" data-path="section-1.html"><a href="section-1.html#section-1.5.1"><i class="fa fa-check"></i><b>1.5.1</b> 多种类型的复合数据</a></li>
<li class="chapter" data-level="1.5.2" data-path="section-1.html"><a href="section-1.html#section-1.5.2"><i class="fa fa-check"></i><b>1.5.2</b> 非结构化的数据存储方式</a></li>
<li class="chapter" data-level="1.5.3" data-path="section-1.html"><a href="section-1.html#section-1.5.3"><i class="fa fa-check"></i><b>1.5.3</b> 对象的集合</a></li>
<li class="chapter" data-level="1.5.4" data-path="section-1.html"><a href="section-1.html#section-1.5.4"><i class="fa fa-check"></i><b>1.5.4</b> 列表子集筛选</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="section-1.html"><a href="section-1.html#-special-values"><i class="fa fa-check"></i><b>1.6</b> 特殊值 Special Values</a><ul>
<li class="chapter" data-level="1.6.1" data-path="section-1.html"><a href="section-1.html#-null"><i class="fa fa-check"></i><b>1.6.1</b> 空值 NULL</a></li>
<li class="chapter" data-level="1.6.2" data-path="section-1.html"><a href="section-1.html#-na"><i class="fa fa-check"></i><b>1.6.2</b> 缺失值 NA</a></li>
<li class="chapter" data-level="1.6.3" data-path="section-1.html"><a href="section-1.html#-nan"><i class="fa fa-check"></i><b>1.6.3</b> 非数值 NaN</a></li>
<li class="chapter" data-level="1.6.4" data-path="section-1.html"><a href="section-1.html#-inf--inf"><i class="fa fa-check"></i><b>1.6.4</b> 无穷大/无穷小 Inf /-Inf</a></li>
</ul></li>
<li class="chapter" data-level="1.7" data-path="section-1.html"><a href="section-1.html#section-1.7"><i class="fa fa-check"></i><b>1.7</b> 数据模式、类型与对象的类辨析</a><ul>
<li class="chapter" data-level="1.7.1" data-path="section-1.html"><a href="section-1.html#section-1.7.1"><i class="fa fa-check"></i><b>1.7.1</b> 数据模式、类型</a></li>
<li class="chapter" data-level="1.7.2" data-path="section-1.html"><a href="section-1.html#section-1.7.2"><i class="fa fa-check"></i><b>1.7.2</b> 对象的类</a></li>
<li class="chapter" data-level="1.7.3" data-path="section-1.html"><a href="section-1.html#section-1.7.3"><i class="fa fa-check"></i><b>1.7.3</b> 基本数据结构的联系与区别</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="section-2.html"><a href="section-2.html"><i class="fa fa-check"></i><b>2</b> 函数式编程</a><ul>
<li class="chapter" data-level="2.1" data-path="section-2.html"><a href="section-2.html#section-2.1"><i class="fa fa-check"></i><b>2.1</b> 基础包中的函数</a><ul>
<li class="chapter" data-level="2.1.1" data-path="section-2.html"><a href="section-2.html#section-2.1.1"><i class="fa fa-check"></i><b>2.1.1</b> 基本数学函数</a></li>
<li class="chapter" data-level="2.1.2" data-path="section-2.html"><a href="section-2.html#section-2.1.2"><i class="fa fa-check"></i><b>2.1.2</b> 描述统计函数</a></li>
<li class="chapter" data-level="2.1.3" data-path="section-2.html"><a href="section-2.html#section-2.1.3"><i class="fa fa-check"></i><b>2.1.3</b> 字符处理函数</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="section-2.html"><a href="section-2.html#section-2.2"><i class="fa fa-check"></i><b>2.2</b> 编写自定义函数</a></li>
<li class="chapter" data-level="2.3" data-path="section-2.html"><a href="section-2.html#section-2.3"><i class="fa fa-check"></i><b>2.3</b> 扩展函数包</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="section-3.html"><a href="section-3.html"><i class="fa fa-check"></i><b>3</b> 数据处理</a><ul>
<li class="chapter" data-level="3.1" data-path="section-3.html"><a href="section-3.html#magrittr-"><i class="fa fa-check"></i><b>3.1</b> magrittr 管道操作符：流式编程</a><ul>
<li class="chapter" data-level="3.1.1" data-path="section-3.html"><a href="section-3.html#magrittr"><i class="fa fa-check"></i><b>3.1.1</b> magrittr介绍</a></li>
<li class="chapter" data-level="3.1.2" data-path="section-3.html"><a href="section-3.html#section-3.1.2"><i class="fa fa-check"></i><b>3.1.2</b> 管道操作符</a></li>
<li class="chapter" data-level="3.1.3" data-path="section-3.html"><a href="section-3.html#section-3.1.3"><i class="fa fa-check"></i><b>3.1.3</b> 运算符号的通用函数</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="section-3.html"><a href="section-3.html#dplyr-"><i class="fa fa-check"></i><b>3.2</b> dplyr 数据表处理语法</a><ul>
<li class="chapter" data-level="3.2.1" data-path="section-3.html"><a href="section-3.html#dplyr"><i class="fa fa-check"></i><b>3.2.1</b> dplyr介绍</a></li>
<li class="chapter" data-level="3.2.2" data-path="section-3.html"><a href="section-3.html#-6-"><i class="fa fa-check"></i><b>3.2.2</b> 单表操作的 6 个主函数</a></li>
<li class="chapter" data-level="3.2.3" data-path="section-3.html"><a href="section-3.html#summary-window-function"><i class="fa fa-check"></i><b>3.2.3</b> summary &amp; window function</a></li>
<li class="chapter" data-level="3.2.4" data-path="section-3.html"><a href="section-3.html#-join--combine"><i class="fa fa-check"></i><b>3.2.4</b> 多表操作 join 和 combine</a></li>
<li class="chapter" data-level="3.2.5" data-path="section-1.html"><a href="section-1.html#-combine"><i class="fa fa-check"></i><b>3.2.5</b> 合并 combine</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="http://lixionghui.com/">返回 lixionghui.com</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">利用R语言进行数据分析</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="section-1" class="section level1">
<h1><span class="header-section-number">第1章</span> 基本数据结构</h1>
<p>R语言借用了面向对象的结构，使用了“类”的抽象数据结构概念。</p>

<div id="-vector" class="section level2">
<h2><span class="header-section-number">1.1</span> 向量 vector</h2>
<p>向量是R语言中最基本的数据结构, 其他类型的数据结构都可以由向量构成。</p>
<div id="section-1.1.1" class="section level3">
<h3><span class="header-section-number">1.1.1</span> 向量的类型与长度</h3>
<p>最常见的向量有三种类型</p>
<ul>
<li>数值型</li>
<li>字符型</li>
<li>逻辑型</li>
</ul>
<div id="-numeric" class="section level4">
<h4><span class="header-section-number">1.1.1.1</span> 数值型向量 numeric</h4>
<p>假设有这样一个数据集, 包含上海某互联网公司数据部门12个员工的相关信息。</p>
<p>这些员工的身高分别是：176cm, 168cm, 172cm, 165cm, 166cm, 162cm, 181cm, 174cm, 178cm, 171cm, 172cm, 169cm。</p>
<p>R语言中的<code>向量</code>, 实际上就是一列数据集合。比如这些员工的身高序列 {176, 168, 172, 165, 166, 162, 181, 174, 178, 171, 172, 169}, 将这些身高数值用<code>c()</code>这个函数将其拼接起来, 每个数值之间用英文逗号隔开，就构成了一个向量。</p>
<p>这个向量中的每个数值就是该向量的一个<code>元素</code>。</p>
<p>在R语言中, <code>&lt;-</code>是<code>赋值</code>符号, 可以将值赋予给一个<code>对象</code>，或者说是<code>变量</code>。</p>
<hr />
<p>下面的示例代码，将这些员工的身高按顺序拼接组合起来，并赋值给名为 <code>height</code> 的这个对象。</p>
<p>执行这行代码后，这个 height 对象，就是一个向量。</p>
<p>向量根据其元素的数据类型，可以分为几种不同的数据类型，比如员工的身高都是数值，该类型的向量就是<code>数值型</code>。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">173</span>, <span class="dv">168</span>, <span class="dv">172</span>, <span class="dv">165</span>, <span class="dv">166</span>, <span class="dv">162</span>, <span class="dv">181</span>, <span class="dv">174</span>, <span class="dv">178</span>, <span class="dv">171</span>, <span class="dv">172</span>, <span class="dv">169</span>)</code></pre></div>
<p>上面的<code>c()</code>函数，其作用是将每个元素的值合并成一个向量。</p>
<p>R语言中，所谓的<code>函数</code>，就是执行某类操作。</p>
<p>在<code>控制台</code>中直接输入对象的名字并运行, R语言程序就会将该对象包含的内容打印到显示屏幕上。</p>
<p>屏幕上显示的结果，每行都会以<code>[1]</code>这样标识开头，后面跟着具体的向量每个元素的值。</p>
<p>如果在控制台屏幕上一行显示不下，会继续在第二行显示，第二行开头也会以<code>[n]</code>开始，至于<code>n</code>具体是多少，就看第二行是从第几个元素开始显示。第三行、第四行以此类推。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height
<span class="co">#&gt;  [1] 173 168 172 165 166 162 181 174 178 171 172 169</span></code></pre></div>
<hr />
<p>直接运行对象的名字, 实际上等于使用了 <code>print()</code> 函数, 两者等价。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(height)
<span class="co">#&gt;  [1] 173 168 172 165 166 162 181 174 178 171 172 169</span></code></pre></div>
</div>
<div id="-character" class="section level4">
<h4><span class="header-section-number">1.1.1.2</span> 字符型向量 character</h4>
<p>这12名员工的姓名分别是：宋子启, 张伯仲, 孟轲舆, 张伟, 王雪梅, 陈梦妍, 李元礼, 杨伯侨, 赵蜚廉, 蒋欣, 沈约度, 陈淮阳。</p>
<p>他们的姓名也可以组成一个向量，姓名是字符，所以向量的类型是<code>字符型</code>。</p>
<p>在R语言中, 字符串类型的值需要用引号括起来, 可以使用双引号, 也可以使用单引号。推荐使用双引号。</p>
<p>当然, 无论是哪种引号, 都是英文输入法下的引号, 中文下的引号是不被系统识别的。</p>
<p>实际上，所有以英文为自己的编程语言，所能识别的关键字符都是英文的，比如之前提到的c()函数中连接字符串的逗号，字符串的引号，以及后面陆续会使用的符号，都是在英文输入法环境下的符号，不再累述。</p>
<p>创建12名员工的字符创向量代码如下：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">name &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;宋子启&quot;</span>, <span class="st">&quot;张伯仲&quot;</span>, <span class="st">&quot;孟轲舆&quot;</span>, <span class="st">&quot;张伟&quot;</span>, <span class="st">&quot;王雪梅&quot;</span>, <span class="st">&quot;陈梦妍&quot;</span>, <span class="st">&quot;李元礼&quot;</span>, <span class="st">&quot;杨伯侨&quot;</span>, <span class="st">&quot;赵蜚廉&quot;</span>, <span class="st">&quot;蒋欣&quot;</span>, <span class="st">&quot;沈约度&quot;</span>, <span class="st">&quot;陈淮阳&quot;</span>)</code></pre></div>
<p>显示<code>name</code>这个向量中的所有名字，并在命令行中添加注释文本。</p>
<p>井号后面文本是代码注释，不会被执行。很多时候在大段的代码中，需要输入一些备注文本说明一些逻辑或者结构等。井号个数不限，井号开始后面的一整行都被注释。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">name <span class="co"># 井号后面文本是代码注释，不会被执行</span>
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot;</span>
<span class="co">#&gt;  [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;   &quot;沈约度&quot; &quot;陈淮阳&quot;</span></code></pre></div>
</div>
<div id="-logical" class="section level4">
<h4><span class="header-section-number">1.1.1.3</span> 逻辑型向量 logical</h4>
<p>在公司的员工信息登记表中，还会记录是否本地户口信息，便于办理社会保险等相关事项。相应的也会有该12名员工的是否本地户口信息，如{是，是，否，是，否，否，否，是，否，否，是，是}。</p>
<p>我可以直接使用“是”和“否”两个字符来表示该信息，作为一个字符型向量。</p>
<p>不过，大多数编程语言中都会有专门的一种<code>逻辑型</code>数据类型来表示这种是否问题，记录真假值，可以用来做条件判断和逻辑运算。</p>
<p>R语言中，用<code>TRUE</code>来表示<code>逻辑真</code>，用<code>FALSE</code>表示<code>逻辑假</code>，也就是计算机二进制的两种状态<code>0</code>和<code>1</code>。这两个英文字符都是大写，也可以使用<code>T</code>和<code>F</code>代替。</p>
<p>这里的是否本地户口的原始数据“是”和“否”，我们这里就用<code>TRUE</code>和<code>FALSE</code>来代替，并创建这个<code>逻辑型</code>向量如下：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">islocal &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">TRUE</span>)
islocal
<span class="co">#&gt;  [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE</span>
<span class="co">#&gt; [12]  TRUE</span></code></pre></div>
</div>
<div id="-class" class="section level4">
<h4><span class="header-section-number">1.1.1.4</span> 向量的类属性 class</h4>
<p>“类”是一种对象的属性，用来定义数据结构，是面对对象编程的概念。</p>
<p>这里的“类”，可以理解为对象的数据结构类型。</p>
<p>函数<code>class()</code> 获得对象的“类”属性。</p>
<p>对向量来说，向量的类，就是向量的类型。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(height) <span class="co"># &quot;numeric&quot; 数值型</span>
<span class="co">#&gt; [1] &quot;numeric&quot;</span>
<span class="kw">class</span>(name) <span class="co"># &quot;character&quot; 字符型</span>
<span class="co">#&gt; [1] &quot;character&quot;</span>
<span class="kw">class</span>(islocal) <span class="co"># &quot;logical&quot; 逻辑型</span>
<span class="co">#&gt; [1] &quot;logical&quot;</span></code></pre></div>
<blockquote>
<p>向量的类型，还可以用 <code>typeof()</code> 和 <code>mode()</code> 这两个函数获得，返回的结果只在“数值型”的向量上略有区别，主要是角度不同。</p>
</blockquote>
<div id="section-1.1.1.4.1" class="section level5">
<h5><span class="header-section-number">1.1.1.4.1</span> 检验向量的类型</h5>
<p>R语言还提供了判断向量是否属于某种类型的一系列函数，对应上面三种类型分别是</p>
<ul>
<li><code>is.numeric(x)</code></li>
<li><code>is.character(x)</code></li>
<li><code>is.logical(x)</code></li>
</ul>
<p>其中参数 x 是待检验的对象，该函数返回类型检验结果的逻辑值，TRUE 或 FALSE.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.numeric</span>(height) <span class="co"># &quot;numeric&quot; 数值型</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.character</span>(name) <span class="co"># &quot;character&quot; 字符型</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.logical</span>(islocal) <span class="co"># &quot;logical&quot; 逻辑型</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>判断其他两类是否为数值型</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.numeric</span>(name) 
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">is.numeric</span>(islocal)
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
<p>判断其他两类是否为字符型</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.character</span>(height)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">is.character</span>(islocal)
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
<hr />
<p>判断其他两类是否为逻辑型</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.logical</span>(height)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">is.logical</span>(name)
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
</div>
</div>
<div id="-length" class="section level4">
<h4><span class="header-section-number">1.1.1.5</span> 向量的长度 length</h4>
<p>向量的<code>长度</code>，就是向量中包含的<code>元素</code>的个数。</p>
<p>获得向量长度的函数是 <code>length(x)</code> ，返回的是一个整数。</p>
<p>这里“身高”、“姓名”、“是否本地”三个向量，都是记录了 12 名员工的信息，故而这三个向量长度的结果应该都是 12。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(height) 
<span class="co">#&gt; [1] 12</span>
<span class="kw">length</span>(name)
<span class="co">#&gt; [1] 12</span>
<span class="kw">length</span>(islocal)
<span class="co">#&gt; [1] 12</span></code></pre></div>
</div>
<div id="section-1.1.1.6" class="section level4">
<h4><span class="header-section-number">1.1.1.6</span> 单个元素的向量</h4>
<p>假设这个数据分析团队现在新加入了一名员工，其身高是 174cm，姓名是“况天佑”，不是本地人。</p>
<p>将这三个数据分别赋值给三个对象，它们分别是只包含一个元素的向量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">h1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">174</span>)
h1
<span class="co">#&gt; [1] 174</span>
n1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;况天佑&quot;</span>)
n1
<span class="co">#&gt; [1] &quot;况天佑&quot;</span>
l1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">FALSE</span>)
l1
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
<p>对于单个元素的数据赋值给一个对象时，不需要<code>c()</code>函数，因为<code>c()</code>函数的作用是将多个元素合并成一个向量。直接将值赋给对象给方便。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">h1 &lt;-<span class="st"> </span><span class="dv">174</span>
n1 &lt;-<span class="st"> &quot;况天佑&quot;</span>
l1 &lt;-<span class="st"> </span><span class="ot">FALSE</span></code></pre></div>
<p>有些地方会将只包含单个元素的向量，也就是长度为一的向量，另外起一个名字叫“标量”。</p>
<p>实际上，R语言没有<code>标量</code>这个说法，也没有判读一个对象是否为标量的函数。</p>
<p>所有的数据都是向量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 单个元素的向量，其长度为 1</span>
<span class="kw">length</span>(h1)
<span class="co">#&gt; [1] 1</span>
<span class="kw">length</span>(n1)
<span class="co">#&gt; [1] 1</span>
<span class="kw">length</span>(l1)
<span class="co">#&gt; [1] 1</span></code></pre></div>
</div>
<div id="-is.atomic" class="section level4">
<h4><span class="header-section-number">1.1.1.7</span> 检验对象是否为向量 is.atomic</h4>
<p>判断一个对象是否为向量的函数是 <code>is.atomic()</code> , 如果是向量, 则返回值为 <code>TRUE</code>, 如果不是则返回 <code>FALSE</code>。</p>
<p>这里讨论的“向量”是狭义的概念，是<code>原子向量</code>(atomic vector)。</p>
<p>R中还有其他的<code>广义的向量</code>，如矩阵和数组，以及<code>泛化的向量</code>，如列表。</p>
<blockquote>
<ul>
<li>故而检验对象是否为原子向量是用 <code>is.atomic()</code>，而不是<code>is.vector()</code>。</li>
</ul>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 长度为 12 的向量，判断结果返回的结果是 TRUE</span>
<span class="kw">is.atomic</span>(height) 
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.atomic</span>(name)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.atomic</span>(islocal)
<span class="co">#&gt; [1] TRUE</span>

<span class="co"># 长度为 1 的向量，判断结果返回的结果也是 TRUE</span>
<span class="kw">is.atomic</span>(h1) 
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.atomic</span>(n1)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.atomic</span>(l1)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
</div>
<div id="-combine" class="section level4">
<h4><span class="header-section-number">1.1.1.8</span> 向量的合并 combine</h4>
<p>我们将第13名员工的信息，合并到前12名员工的向量中，依然使用 <code>c()</code> 函数。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 这里讲合并后的结果还是还是赋值给原来的对象</span>
<span class="co"># 新对象就包含13个元素</span>
height &lt;-<span class="st"> </span><span class="kw">c</span>(height, h1)
height
<span class="co">#&gt;  [1] 173 168 172 165 166 162 181 174 178 171 172 169 174</span>
<span class="kw">length</span>(height)
<span class="co">#&gt; [1] 13</span>

name &lt;-<span class="st"> </span><span class="kw">c</span>(name, n1)
name
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot;</span>
<span class="co">#&gt;  [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;   &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot;</span>
<span class="kw">length</span>(name)
<span class="co">#&gt; [1] 13</span>

islocal &lt;-<span class="st"> </span><span class="kw">c</span>(islocal, l1)
islocal
<span class="co">#&gt;  [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE</span>
<span class="co">#&gt; [12]  TRUE FALSE</span>
<span class="kw">length</span>(islocal)
<span class="co">#&gt; [1] 13</span></code></pre></div>
<p>假设，该团队又有两名新成员加入，依然使用<code>c()</code>函数添加，并且可以直接追加向量的值，而不需要先赋予给另一个对象。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 新对象继续添加了两名员工的信息</span>
<span class="co"># 现在向量的元素一共包含了 15 个员工的信息</span>
height &lt;-<span class="st"> </span><span class="kw">c</span>(height, <span class="dv">170</span>, <span class="dv">172</span>)
height
<span class="co">#&gt;  [1] 173 168 172 165 166 162 181 174 178 171 172 169 174 170 172</span>
<span class="kw">length</span>(height)
<span class="co">#&gt; [1] 15</span>

name &lt;-<span class="st"> </span><span class="kw">c</span>(name, <span class="st">&quot;王珍珍&quot;</span>, <span class="st">&quot;马小玲&quot;</span>)
name
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot;</span>
<span class="co">#&gt;  [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;   &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot;</span>
<span class="co">#&gt; [15] &quot;马小玲&quot;</span>
<span class="kw">length</span>(name)
<span class="co">#&gt; [1] 15</span>

islocal &lt;-<span class="st"> </span><span class="kw">c</span>(islocal, <span class="ot">TRUE</span>, <span class="ot">TRUE</span>)
islocal
<span class="co">#&gt;  [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE</span>
<span class="co">#&gt; [12]  TRUE FALSE  TRUE  TRUE</span>
<span class="kw">length</span>(islocal)
<span class="co">#&gt; [1] 15</span></code></pre></div>
</div>
<div id="section-1.1.1.9" class="section level4">
<h4><span class="header-section-number">1.1.1.9</span> 不同类型向量转化</h4>
<p>向量的一个内在要求是，其内部元素之间的类型要相同。</p>
</div>
<div id="section-1.1.1.10" class="section level4">
<h4><span class="header-section-number">1.1.1.10</span> 合并向量时类型不同自动转化</h4>
<p>创建或者合并向量时，如果元素类型之间不相同，则会遵循优先兼容递升原则，自动转为兼容性更高的类型。</p>
<ul>
<li>逻辑型会被转为数值型</li>
<li>数值型会被转为字符型</li>
</ul>
<blockquote>
<p>在数值型向量中，严格意义上来说，还区分两种类型，一个是子类：“整数型”，一个是父类“复数型”，而“数值型”实际上就是“实数型”。</p>
</blockquote>
<blockquote>
<p>在数学上，整数 ∈ 实数 ∈ 复数。</p>
</blockquote>
<blockquote>
<p>按类型转化原则，在数值型之间，整数型会转为实数型，数值型会转为复数型。</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="dv">1</span>, <span class="ot">FALSE</span>, <span class="dv">0</span>)) <span class="co"># 逻辑型转为数值型</span>
<span class="co">#&gt; [1] &quot;numeric&quot;</span>
<span class="kw">print</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="dv">1</span>, <span class="ot">FALSE</span>, <span class="dv">0</span>)) <span class="co"># TRUE 转为 1, FASLE 转为 0</span>
<span class="co">#&gt; [1] 1 1 0 0</span>
<span class="kw">class</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="st">&quot;真&quot;</span>, <span class="ot">FALSE</span>, <span class="st">&quot;假&quot;</span>)) <span class="co"># 逻辑型转为数值型</span>
<span class="co">#&gt; [1] &quot;character&quot;</span>
<span class="kw">print</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="st">&quot;真&quot;</span>, <span class="ot">FALSE</span>, <span class="st">&quot;假&quot;</span>))  <span class="co"># TRUE 转为 &quot;TRUE&quot;（字符）, FASLE 转为 &quot;FASLE&quot;（字符）</span>
<span class="co">#&gt; [1] &quot;TRUE&quot;  &quot;真&quot;    &quot;FALSE&quot; &quot;假&quot;</span>
<span class="kw">class</span>(<span class="kw">c</span>(<span class="fl">3.14</span>, <span class="st">&quot;PI&quot;</span>)) <span class="co"># 数值型转为字符型</span>
<span class="co">#&gt; [1] &quot;character&quot;</span>
<span class="kw">print</span>(<span class="kw">c</span>(<span class="fl">3.14</span>, <span class="st">&quot;PI&quot;</span>)) <span class="co"># 3.14 转为 &quot;3.14&quot;（字符）</span>
<span class="co">#&gt; [1] &quot;3.14&quot; &quot;PI&quot;</span></code></pre></div>
<hr />
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">3.14</span>)) <span class="co"># 整数型转为数值型</span>
<span class="co">#&gt; [1] 1.00 3.14</span>
<span class="kw">class</span>(<span class="kw">c</span>(<span class="fl">3.14</span>, <span class="dv">2</span> +<span class="st"> </span>5i)) <span class="co"># 数值型转为复数型</span>
<span class="co">#&gt; [1] &quot;complex&quot;</span>
<span class="kw">print</span>(<span class="kw">c</span>(<span class="fl">3.14</span>, <span class="dv">2</span> +<span class="st"> </span>5i)) <span class="co"># 数值型转为复数型</span>
<span class="co">#&gt; [1] 3.14+0i 2.00+5i</span></code></pre></div>
<div id="section-1.1.1.10.1" class="section level5">
<h5><span class="header-section-number">1.1.1.10.1</span> 强制类型转化函数</h5>
<p>类似于 <code>is.FUN</code> 一系列向量类型检验函数，强制类型转化也相似的一系列函数</p>
<ul>
<li><code>as.logical(x)</code></li>
<li><code>as.number(x)</code>
<ul>
<li><code>as.integer(x)</code></li>
<li><code>as.complex(x)</code></li>
</ul></li>
<li><code>as.character(x)</code></li>
</ul>
<p>强制类型转化遵循一定的原则，比如</p>
<ul>
<li>数值型可以转为逻辑型：0 转为逻辑值 FALSE, 非 0 都转为 TRUE</li>
<li>字符型可以转为数值型的条件是：去掉字符符号（引号）之后是可以被识别的数值</li>
<li>如果不符合转化条件，则强制转化后对应的元素的结果将变成 <code>NA</code>，这是 R 语言中的缺失值，因为系统不知道该显示什么值是正确的，相当于信息丢失;</li>
</ul>
<p>在强制转化过程中如果产生了NA，则会出现系统“警告”。实际上这时候程序已经执行成功了，并不会等待确认或者要放弃执行，警告信息只是一种提醒。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.logical</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>)) <span class="co"># 0 转为逻辑值 FALSE, 非 0 都转为 TRUE</span>
<span class="co">#&gt; [1]  TRUE FALSE  TRUE</span>
<span class="kw">as.logical</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.68</span>, <span class="dv">1</span>, <span class="fl">3.14</span>)) <span class="co"># 0 转为逻辑值 FALSE, 非 0 都转为 TRUE</span>
<span class="co">#&gt; [1] FALSE  TRUE  TRUE  TRUE</span>

<span class="kw">as.numeric</span>(name) <span class="co"># 将名字转为数值，得到的都是 NA，程序不知道该转为什么值合适</span>
<span class="co">#&gt; Warning: 强制改变过程中产生了NA</span>
<span class="co">#&gt;  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA</span>

<span class="kw">as.numeric</span>(<span class="st">&quot;3.14&quot;</span>) <span class="co"># 如果去掉字符型的符号后能被系统识别为数值，则可顺利转化</span>
<span class="co">#&gt; [1] 3.14</span>
<span class="kw">class</span>(<span class="kw">as.numeric</span>(<span class="st">&quot;3.14&quot;</span>)) <span class="co"># 打印出转化后的类型</span>
<span class="co">#&gt; [1] &quot;numeric&quot;</span></code></pre></div>
<p>字符和数值之间类型转化是很常见的。</p>
<p>比如爬虫系统，从网页上爬取所需数据，最迟得到的数据是字符型的（网页是富文本），要做数值运行就需要将其转为数值型。</p>
<p>在需要输出特殊格式化的结果时，通常会将数值转为字符。最常见的例子是，将一个百分比数值显示为带有百分号的格式。</p>
</div>
</div>
</div>
<div id="-sequence" class="section level3">
<h3><span class="header-section-number">1.1.2</span> 等差序列向量 sequence</h3>
<p>对这 15 名员工，我想给他们编一个序号，从 1 到 15。</p>
<p>我可以用 <code>c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)</code> 这样的原始输入方式获得，但这种手动输入不是很方便，特别是数量很大的时候。</p>
<p>这些数字是有规律的，是<code>等差</code>递增向量，其<code>步长</code>为 1. 只要是有规律的，实际上程序就可以自动生成。</p>
<p>R语言中有一个专门的函数来生成这种等差序列的向量，该函数是 <code>seq()</code> ，其参数是 from 表示开始的数值， to 是结束的数值，by 是步长（每次增加的数值）。</p>
<p>我们用 <code>seq()</code> 函数来生成从 1 到 15 的向量，间隔为 1，并将结果赋值给 <code>no</code> 这个对象。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">no &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">1</span>, <span class="dt">to =</span> <span class="dv">15</span>, <span class="dt">by =</span> <span class="dv">1</span>)
no
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</span></code></pre></div>
<p>函数的参数名称是<code>形式参数</code>，其值是<code>实际参数</code>, 这里的 from, to, by 是形式参数，其值 1, 15, 1 是对象的实际参数。</p>
<p>在R语言中，形式参数是可以不直接写出来的，这种情况下，按照参数的值所在的位置去对应参数的名称，这样就可以简化一些常用函数的书写过程。</p>
<p>比如上面这个创建等差序列向量的过程，我们就可以简化为</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">no &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">15</span>, <span class="dv">1</span>)</code></pre></div>
<p>函数的参数有时候会定义默认值，比如 <code>seq()</code> 中 <code>by</code> 的默认值为 1，则在使用该函数的不指定该参数的值，就会在运行过程中使用该参数的默认值，这时候函数的书写就可以进一步简化。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">no &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">15</span>)</code></pre></div>
<p>这也是之前在使用函数 head() 和 tail() 时，不指定参数 n 的情况下，只显示首尾 6 个元素的原因，因为参数 n 的默认值就是 6.</p>
<p><code>seq()</code> 函数还有另外一个用法，当我们知道等差序列的起止数值，但不知道步长应该是多少，只知道应该产生多少个元素的向量，可以使用参数 length.out</p>
<p>产生等差序列还有一种情况：已知起始值 from 和 终止值 to ，但不知道步长 by 的值，但知道应该要产生多少个元素的向量，这时可以使用 seq() 函数的另一个参数 length.out , 表示要产生多少个元素。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">1</span>, <span class="dt">to =</span> <span class="dv">15</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</span></code></pre></div>
<p>但这里要注意的是，seq() 函数中 by 和 length.out 两个参数不能同时使用，只能使用一个，否则会报错。</p>
<blockquote>
<p>实际上，seq() 函数中如果指定了 length.out 这个参数，则 by 的值会被自动计算出来， by = ((to - from)/(length.out - 1) 。</p>
</blockquote>
<blockquote>
<p>因为等差序列的关键参数还是 from, to 和 by ，程序最终还是需要知道步长是多少，否则无法计算。不能同时指定的原因是，可能会出现用户输入的 by 和从 length.out 计算的 by = ((to - from)/(length.out - 1) 两者不相等，就会出问题。</p>
</blockquote>
<blockquote>
<p>这种情况下 by = ((to - from)/(length.out - 1) 这个表达式，使用了 from, to, length.out 这三个参数的具体的值。R语言中可以允许这种一个参数调用其他参数值的情况，可以使得函数更为灵活。</p>
</blockquote>
<p>步长为 1 的等差序列最为常用，故而还有一种更为便捷的书写方式，<code>n:m</code>，这种包含符号的写法成为<code>表达式</code>。比如 <code>1:15</code> 就等价于 seq(1,15) , 等价于 seq(from = 1, to = 15, by = 1)。</p>
<blockquote>
<p>表达式，本质上也是一种函数。R语言中所有的操作，都是函数过程。</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">15</span></code></pre></div>
<p>如果我们要等到递减的等差序列，则 to 的值大于 from 即可。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">15</span>:<span class="dv">1</span>
<span class="co">#&gt;  [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1</span></code></pre></div>
<p>另外，等差序列可以产生实数，并不限于整数（上面的值都是整数）。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">seq</span>(<span class="dt">from =</span> <span class="fl">0.01</span>, <span class="dt">to =</span> <span class="fl">0.15</span>, <span class="dt">by =</span> <span class="fl">0.01</span>)
<span class="co">#&gt;  [1] 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14</span>
<span class="co">#&gt; [15] 0.15</span></code></pre></div>
<blockquote>
<p>对于函数的参数是否书写的问题，建议如下：如果已经对该函数中的参数名称、顺序、参数默认值等情况比较清楚，自己简化书写的时候不会产生困惑，则可以简化。在不熟悉的情况下，建议书写完整，容易阅读。</p>
</blockquote>
<blockquote>
<p>另外，函数的各参数之间，尽量空一格；参数名和参数值与等号之间，尽量空一格，使得代码更规范，便于阅读。</p>
</blockquote>
</div>
<div id="-replicate" class="section level3">
<h3><span class="header-section-number">1.1.3</span> 循环重复向量 replicate</h3>
<p>有时候，我们需要产生一些重复的向量，R语言中有专门的函数来处理。</p>
<p>假设我们要对这15名员工做个分组，按照顺序分为3组，每个组给予1,2,3,4,5这样的序号。</p>
<p>R语言中有一个函数 <code>rep()</code> ，可以生成具有重复性质的向量，或者说将一个向量按重复循环生成更多元素的向量。</p>
<p>该函数有一个参数 times 可以，可以指定对一个向量重复的次数。</p>
<p>这里的分组，我们就可以先创建一个 c(1, 2, 3, 4, 5) 向量，然后将其循环 3 次到达目标。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">three_group_3 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), <span class="dt">times =</span> <span class="dv">3</span>)
<span class="kw">print</span>(three_group_3)
<span class="co">#&gt;  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5</span></code></pre></div>
<p>假设我们做个不同的分组，共分为5组，前3名员工分为第1组，记录他们的组号为1，随后的3名分为第2组，记录为2，直到最后一组，也就是第5组，记录为5。</p>
<p>该函数还有另外一个参数 each，可以指定向量的每个元素按顺序循环的次数。上面的分组我们可以用 each 参数来实现。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">three_group_5 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), <span class="dt">each =</span> <span class="dv">3</span>)
<span class="kw">print</span>(three_group_5)
<span class="co">#&gt;  [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5</span></code></pre></div>
<blockquote>
<p>rep() 函数中的 times 参数，是对整个向量循环重复；而 each 参数，是对向量中的元素循环重复。</p>
</blockquote>
<blockquote>
<p>times 和 each 两个参数是可以同时使用的， <code>each</code> 参数的优先级高于 <code>times</code> 参数，先循环重复每个元素得到新向量对象，然后再对此新结果整个向量做循环重复。</p>
</blockquote>
<blockquote>
<p>times 和 each 的默认参数都是 1 ，故而可以只设定一个即可。多数情况下，我们只选择一种用法，也就是只使用一个参数。</p>
</blockquote>
<p>对于 <code>seq()</code> 函数的用法，可以使用 <code>help()</code> 函数来获得更进一步的信息。执行 <code>help(seq)</code> 就会打开一个页面，介绍关于<code>seq()</code>函数的各种信息，通常都会包括</p>
<ul>
<li>描述(Description)</li>
<li>用法(Usage)</li>
<li>参数(Arguments)</li>
<li>详情(Details)</li>
<li>参数值(Value)</li>
<li>参考文献(References)</li>
<li>参考更多信息(See Also)</li>
<li>示例(Examples)</li>
</ul>
<p>其中 Arguments 和 Examples 是最有用的部分。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">help</span>(seq) <span class="co"># 查看关于该函数的帮助信息</span>
?seq <span class="co"># 也可以使用“?”开头紧接着函数名的方式</span></code></pre></div>
</div>
<div id="section-1.1.4" class="section level3">
<h3><span class="header-section-number">1.1.4</span> 数值向量的算术运算</h3>
<p>这个数据分析团队中的每个成员都已经有身高信息了，我们再来提供他们的体重信息，单位为 kg.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">weight &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">73</span>, <span class="dv">70</span>, <span class="dv">68</span>, <span class="dv">60</span>, <span class="dv">55</span>, <span class="dv">52</span>, <span class="dv">80</span>, <span class="dv">75</span>, <span class="dv">78</span>, <span class="dv">54</span>, <span class="dv">61</span>, <span class="dv">62</span>, <span class="dv">56</span>, <span class="dv">53</span>, <span class="dv">82</span>)
<span class="kw">print</span>(weight)
<span class="co">#&gt;  [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82</span></code></pre></div>
<p>现在，我们想要计算每个人的“身高体重指数”(BMI, Body Mass Index)，计算该指数用来反映一个人的整体营养状态，比如是否偏瘦，还是偏胖等。</p>
<p>身高质量指数的公式是</p>
<p><span class="math display">\[BMI = \frac{w}{h^2}\]</span></p>
<p>w = 体重, 单位：千克(kg)；</p>
<p>h = 身高，单位：米(m)；</p>
<p>BMI = 身高体重指数，单位：千克/平方米(kg/m^2)</p>
<p>之前的身高向量 height 的单位是 cm(厘米)，按照公式需要，先转换单位为 m(米)，只要每个元素除以100即可。</p>
<p>将一个数值向量，除以一个数值时，每个元素都会做相同的算术运算。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height &lt;-<span class="st"> </span>height /<span class="st"> </span><span class="dv">100</span> <span class="co"># / 是除法符号，左边除以右边</span>
<span class="kw">print</span>(height)
<span class="co">#&gt;  [1] 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70</span>
<span class="co">#&gt; [15] 1.72</span></code></pre></div>
<p>这时我们得到了单位为米的身高数据。</p>
<p>我们要计算每个人的身高质量指数，只要对身高和体重两个向量直接做算术运算即可。</p>
<p>当两个向量的长度相同（包含的元素相同）时，算术运算时每个元素都是一一对应的。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BMI &lt;-<span class="st"> </span>weight /<span class="st"> </span>(height ^<span class="st"> </span><span class="dv">2</span>) <span class="co"># ^ 是幂符号，^2就是2次方，也就是平方</span>
<span class="kw">print</span>(BMI)
<span class="co">#&gt;  [1] 24.4 24.8 23.0 22.0 20.0 19.8 24.4 24.8 24.6 18.5 20.6 21.7 18.5 18.3</span>
<span class="co">#&gt; [15] 27.7</span></code></pre></div>
<p>最后，我们根据身高质量指数的统计分析对照表来做这 15 名员工的体质做分析。</p>
<div class="figure">
<img src="images/Body_mass_index_chart.svg" alt="" />

</div>
<p>总体来说，BMI值小于18.5属于偏瘦，大于25属于偏胖。</p>
<p>从结果上看，第10名员工的BMI约等于18.5，算是标准体质范围；有两位员工需要注意自己的体质健康状况：</p>
<ul>
<li>第14名员工就属于偏瘦，需要多补充点营养即可；</li>
<li>第15名员工就属于偏胖，需要加强身体锻炼了。</li>
</ul>
<hr />
<p>R语言中关于数值的算术运算符号及含义见下表</p>
<table>
<thead>
<tr class="header">
<th align="left">算术运算符号</th>
<th align="left">符号含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">+</td>
<td align="left">加号，数值相加</td>
</tr>
<tr class="even">
<td align="left">-</td>
<td align="left">减号，数值相减</td>
</tr>
<tr class="odd">
<td align="left">*</td>
<td align="left">乘号，数值相乘</td>
</tr>
<tr class="even">
<td align="left">/</td>
<td align="left">除号，数值相除</td>
</tr>
<tr class="odd">
<td align="left">%%</td>
<td align="left">取模，数值相除取不能整除的余数</td>
</tr>
<tr class="even">
<td align="left">%/%</td>
<td align="left">取整，数值相除取整除的部分</td>
</tr>
<tr class="odd">
<td align="left">^</td>
<td align="left">幂，幂运算，x^y 表示 x 连续乘以 x 自身 y 次</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">15</span> +<span class="st"> </span><span class="dv">6</span>
<span class="co">#&gt; [1] 21</span>
<span class="dv">15</span> -<span class="st"> </span><span class="dv">6</span>
<span class="co">#&gt; [1] 9</span>
<span class="dv">15</span> *<span class="st"> </span><span class="dv">6</span>
<span class="co">#&gt; [1] 90</span>
<span class="dv">15</span> /<span class="st"> </span><span class="dv">6</span>
<span class="co">#&gt; [1] 2.5</span>
<span class="dv">15</span> %%<span class="st"> </span><span class="dv">6</span>
<span class="co">#&gt; [1] 3</span>
<span class="dv">15</span> %/%<span class="st"> </span><span class="dv">6</span>
<span class="co">#&gt; [1] 2</span>
<span class="dv">2</span>^<span class="dv">3</span> 
<span class="co">#&gt; [1] 8</span></code></pre></div>
</div>
<div id="section-1.1.5" class="section level3">
<h3><span class="header-section-number">1.1.5</span> 向量运算的循环补齐</h3>
<p>我们再回过头来看 <code>height/100</code> 一个向量直接除以一个数值的情况。</p>
<p>我们知道，一个数值，实际上就是一个只包含一个元素的向量。那么这里的情况是，一个包含 15 个元素的向量，除以一个只包含一个元素的向量。</p>
<p>向量的算术运算实际上是需要两个个数相同，每个元素之间相互对应做运算的。那么这里是怎么实现最终的运算的呢？</p>
<p>这里引出了一个R语言向量运算过程中的一个重要概念，向量<code>循环补齐</code>。</p>
<p>100这个数值是只包含一个元素的向量，对应要运算的向量是包含15个元素的向量，根据循环补齐原则，这里先向量长度少的向量，按照循环重复的原则补齐到相同长度，使用 <code>rep()</code> 的规则，且重复的参数是 <code>times</code>。</p>
<p>这里 100 这个单个元素（长度为1的向量），先处理为 rep(100, time = 15) 的向量，再做计算，等价于</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height/<span class="kw">rep</span>(<span class="dv">100</span>, <span class="dt">times =</span> <span class="dv">15</span>)</code></pre></div>
<p>如果我们将包含15个元素的体重向量 weight，除以包含4个元素的向量c(1, 2, 3, 4)，会发生什么呢？</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">weight/<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)
<span class="co">#&gt; Warning in weight/c(1, 2, 3, 4): 长的对象长度不是短的对象长度的整倍数</span>
<span class="co">#&gt;  [1] 73.0 35.0 22.7 15.0 55.0 26.0 26.7 18.8 78.0 27.0 20.3 15.5 56.0 26.5</span>
<span class="co">#&gt; [15] 27.3</span></code></pre></div>
<p>运算后该表达式会得到一个结果值，但是同时会打印出一条红色警告信息：<strong>“长的对象长度不是短的对象长度的整倍数”</strong> 。</p>
<p>该计算过程会去重复循环长度短的向量，如果“长的对象长度不是短的对象长度的整倍数”，则重复次数 = (长的对象长度/短的对象长度)除数的整数部分 + 1。这里 15/4的除数3倍 + 1 ，times = 4.</p>
<p>c(1, 2, 3, 4) 重复 4 次之后，就得到长度为 16 的向量，比原来长的对象的长度还要多，则多出的部分会被丢弃，使得计算的两个向量长度相同。</p>
<p>因为有丢弃的情况出现，故而计算后会有一个警告信息，作为提示。</p>
<p>如果“长的对象长度”正好是“短的对象长度”的整倍数，则直接循环重复后计算，且不会提出警告信息。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">weight/<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="co">#&gt;  [1] 73.0 35.0 22.7 60.0 27.5 17.3 80.0 37.5 26.0 54.0 30.5 20.7 56.0 26.5</span>
<span class="co">#&gt; [15] 27.3</span></code></pre></div>
</div>
<div id="section-1.1.6" class="section level3">
<h3><span class="header-section-number">1.1.6</span> 向量索引与子集筛选</h3>
<p>向量是多个元素的集合，当我们只需要指定或者说提取该向量中的某个元素时，就可以使用向量的<code>索引</code>(Indexing)。</p>
<p>向量元素可以由三种基本类型的向量索引</p>
<ul>
<li>整数型，索引的是元素位置</li>
<li>字符型，索引的是名称属性</li>
<li>逻辑型，索引的是相同长度的逻辑向量对应的逻辑值为真的元素</li>
</ul>
<div id="section-1.1.6.1" class="section level4">
<h4><span class="header-section-number">1.1.6.1</span> 通过元素位置索引向量</h4>
<p>第一种元素的索引方式，是通过在向量后面加中括号，其中输入需要索引的元素的位置（第几个）。</p>
<p>比如我们想要获得该数据分析团队中的第2个人的身高，第5个人的名字，第9个人的体重，以及第14个人的身高体重指数，则直接索引对应向量的位置序号即可。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height[<span class="dv">2</span>] <span class="co"># 第2个人的身高</span>
<span class="co">#&gt; [1] 1.68</span>
name[<span class="dv">5</span>] <span class="co"># 第5个人的名字</span>
<span class="co">#&gt; [1] &quot;王雪梅&quot;</span>
weight[<span class="dv">9</span>] <span class="co"># 第9个人的体重</span>
<span class="co">#&gt; [1] 78</span>
BMI[<span class="dv">14</span>] <span class="co"># 第14个人的身高体重指数</span>
<span class="co">#&gt; [1] 18.3</span></code></pre></div>
<p>还是回到单个数值本身就是向量的问题，这里的位置索引，只要求是整数向量即可，故而一次索引多个元素。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height[<span class="dv">1</span>:<span class="dv">5</span>] <span class="co"># 第1到第5个人的身高</span>
<span class="co">#&gt; [1] 1.73 1.68 1.72 1.65 1.66</span>
name[<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">8</span>)] <span class="co"># 第2,6,8个人的名字</span>
<span class="co">#&gt; [1] &quot;张伯仲&quot; &quot;陈梦妍&quot; &quot;杨伯侨&quot;</span>
weight[<span class="kw">c</span>(<span class="dv">15</span>, <span class="dv">4</span>, <span class="dv">12</span>, <span class="dv">1</span>)] <span class="co"># 第15,4,12,1个人的体重，具体的顺序可以任意指定</span>
<span class="co">#&gt; [1] 82 60 62 73</span>
BMI[<span class="dv">15</span>:<span class="dv">12</span>] <span class="co"># 第15到12个人的身高体重指数</span>
<span class="co">#&gt; [1] 27.7 18.3 18.5 21.7</span></code></pre></div>
<p>这里需要注意的是，作为位置索引的数字整数，不能超过该向量的长度。否则会得到一个值为 NA 的结果，也就是一个空值。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height[<span class="dv">16</span>] <span class="co"># 第16个元素不存在</span>
<span class="co">#&gt; [1] NA</span>
name[<span class="kw">c</span>(-<span class="dv">2</span>, -<span class="dv">6</span>, -<span class="dv">8</span>)] <span class="co"># 第2,6,8个人的名字</span>
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;李元礼&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;  </span>
<span class="co">#&gt;  [8] &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; &quot;马小玲&quot;</span>
weight[-<span class="kw">c</span>(<span class="dv">15</span>, <span class="dv">4</span>, <span class="dv">12</span>, <span class="dv">1</span>)] <span class="co"># 第15,4,12,1个人的体重，具体的顺序可以任意指定</span>
<span class="co">#&gt;  [1] 70 68 55 52 80 75 78 54 61 56 53</span>
BMI[<span class="dv">15</span>:<span class="dv">12</span>] <span class="co"># 第15到12个人的身高体重指数</span>
<span class="co">#&gt; [1] 27.7 18.3 18.5 21.7</span></code></pre></div>
<p>当我们想要获得排除某个位置元素的剩余其他元素向量的时候，位置索引数字变成负数即可。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height[-<span class="dv">15</span>] <span class="co"># 排除第15个元素的身高向量</span>
<span class="co">#&gt;  [1] 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70</span>
name[<span class="kw">c</span>(-<span class="dv">2</span>, -<span class="dv">6</span>, -<span class="dv">8</span>)] <span class="co"># 排除第2,6,8个人的名字</span>
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;李元礼&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;  </span>
<span class="co">#&gt;  [8] &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; &quot;马小玲&quot;</span>
weight[-<span class="kw">c</span>(<span class="dv">15</span>, <span class="dv">4</span>, <span class="dv">12</span>, <span class="dv">1</span>)] <span class="co"># -c(15, 4, 12, 1) 等价于 -1 * c(15, 4, 12, 1)</span>
<span class="co">#&gt;  [1] 70 68 55 52 80 75 78 54 61 56 53</span>
BMI[-<span class="dv">15</span>:-<span class="dv">12</span>] <span class="co"># 排除第15到第12个人的身高体重指数</span>
<span class="co">#&gt;  [1] 24.4 24.8 23.0 22.0 20.0 19.8 24.4 24.8 24.6 18.5 20.6</span></code></pre></div>
</div>
<div id="section-1.1.6.2" class="section level4">
<h4><span class="header-section-number">1.1.6.2</span> 通过名称属性索引向量</h4>
<p>向量可以设置一个名称<code>属性</code>，从而可以通过名称来索引向量。</p>
<p>名称属性可以通过 <code>names()</code> 来指定，将一个包含名称的向量，指定给等长度的向量。</p>
<p>例如，我们将这 15 名员工的姓名向量，赋值给身高向量作为名称属性。</p>
<p>这样，身高向量就具有了名称属性，每个身高元素都会对应一个姓名。print(height) 时候也会将元素的名称显示出来。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(name)
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot;</span>
<span class="co">#&gt;  [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;   &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot;</span>
<span class="co">#&gt; [15] &quot;马小玲&quot;</span>
<span class="kw">print</span>(height)
<span class="co">#&gt;  [1] 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70</span>
<span class="co">#&gt; [15] 1.72</span>

<span class="kw">names</span>(height) &lt;-<span class="st"> </span>name <span class="co"># 这里将 name 作为 height 的 names 属性</span>
<span class="kw">print</span>(height)
<span class="co">#&gt; 宋子启 张伯仲 孟轲舆   张伟 王雪梅 陈梦妍 李元礼 杨伯侨 赵蜚廉   蒋欣 </span>
<span class="co">#&gt;   1.73   1.68   1.72   1.65   1.66   1.62   1.81   1.74   1.78   1.71 </span>
<span class="co">#&gt; 沈约度 陈淮阳 况天佑 王珍珍 马小玲 </span>
<span class="co">#&gt;   1.72   1.69   1.74   1.70   1.72</span></code></pre></div>
<p>通过名称向量即可索引具体的元素，用法和位置索引类似，但是名称是字符，故而索引的名称要作为字符处理，需要添加字符引号。</p>
<p>通过名称来索引，有个显而易见的好处，记住名字比位置更为方便。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height[<span class="st">&quot;马小玲&quot;</span>]
<span class="co">#&gt; 马小玲 </span>
<span class="co">#&gt;   1.72</span>
height[<span class="kw">c</span>(<span class="st">&quot;马小玲&quot;</span>,<span class="st">&quot;蒋欣&quot;</span>)]
<span class="co">#&gt; 马小玲   蒋欣 </span>
<span class="co">#&gt;   1.72   1.71</span></code></pre></div>
</div>
<div id="section-1.1.6.3" class="section level4">
<h4><span class="header-section-number">1.1.6.3</span> 通过逻辑表达式筛选子集</h4>
<p>用逻辑向量来筛选向量元素，也是常见的用法。在索引符号中输入逻辑向量，就会筛选出对应的逻辑为真(TRUE)的元素。</p>
<p>比如，在这 15 名员工中，筛选出户口是本地的员工。现在已经有了 islocal 的逻辑向量，可直接筛选出本地户口的员工了。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(name)
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot;</span>
<span class="co">#&gt;  [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;   &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot;</span>
<span class="co">#&gt; [15] &quot;马小玲&quot;</span>
<span class="kw">print</span>(islocal)
<span class="co">#&gt;  [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE</span>
<span class="co">#&gt; [12]  TRUE FALSE  TRUE  TRUE</span>
name[islocal]
<span class="co">#&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;张伟&quot;   &quot;杨伯侨&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;王珍珍&quot; &quot;马小玲&quot;</span>

<span class="co"># 如果把 islocal 原本的逻辑值显示完整等价于</span>
name[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">TRUE</span>)]
<span class="co">#&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;张伟&quot;   &quot;杨伯侨&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot;</span></code></pre></div>
<p>如果逻辑向量长度少于被筛选向量, 则会通过向量循环补齐的方式自动补全为与筛选对象等长的逻辑向量在筛选，</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">name[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>)] <span class="co"># 第1个和第3个元素逻辑值为TRUE</span>
<span class="co">#&gt; [1] &quot;宋子启&quot; &quot;孟轲舆&quot; &quot;陈梦妍&quot; &quot;杨伯侨&quot; &quot;沈约度&quot; &quot;况天佑&quot;</span>

<span class="co"># 等价于索引的逻辑向量先循环补齐长度与被筛选对象相同，这里正好是3倍</span>
name[<span class="kw">rep</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>), <span class="dt">times =</span> <span class="dv">3</span>)] 
<span class="co">#&gt; [1] &quot;宋子启&quot; &quot;孟轲舆&quot; &quot;陈梦妍&quot; &quot;杨伯侨&quot; &quot;沈约度&quot; &quot;况天佑&quot;</span></code></pre></div>
<p>这种逻辑索引的方式，更为重建的用法是逻辑表达式：一个向量经过逻辑运算后得到相同长度的逻辑向量，然后用此结果逻辑向量来筛选符合逻辑为真的元素。</p>
<p>比如，<code>weight &gt; 60</code> 就是一个逻辑表达式，大于号是一个比较运算符，类似于算术运算，这里也是一个向量与另一个向量的对应的值的比较，返回的结果是一个逻辑向量，也就是每个比较的结果，是否为真，为真就记录为 TRUE，否则就记录为 FALSE。</p>
<blockquote>
<p>这里的 60 虽然只是一个数值，但它就是只包含一个元素的向量，这里的运算还是会类似于算术运算中，先对其做向量循环补齐，然后再一一对应做比较运算。关于单个数值的向量循环补齐原则，后续将不再单独说明。</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">weight &gt;<span class="st"> </span><span class="dv">60</span> <span class="co"># 逻辑表达式，返回相同长度的逻辑向量</span>
<span class="co">#&gt;  [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE</span>
<span class="co">#&gt; [12]  TRUE FALSE FALSE  TRUE</span>
height[weight &gt;<span class="st"> </span><span class="dv">60</span>]
<span class="co">#&gt; 宋子启 张伯仲 孟轲舆 李元礼 杨伯侨 赵蜚廉 沈约度 陈淮阳 马小玲 </span>
<span class="co">#&gt;   1.73   1.68   1.72   1.81   1.74   1.78   1.72   1.69   1.72</span></code></pre></div>
<p>如果要对一个逻辑结果做一个转化，真变为假，假变为真，则有一个运算符号来完成，在逻辑表达式前加“!”(英文状态下的惊叹号)，也可以将在一个逻辑表达式前面。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">weight[!(weight &gt;=<span class="st"> </span><span class="dv">60</span>)] <span class="co"># 这里加入括号，更容易理解其优先级顺序</span>
<span class="co">#&gt; [1] 55 52 54 56 53</span>
weight[!weight &gt;=<span class="st"> </span><span class="dv">60</span>] <span class="co"># 这里 !weight &gt;= 60 等价于 !(weight &gt;= 60) 是因为 ! 的优先级比 &gt;= 低</span>
<span class="co">#&gt; [1] 55 52 54 56 53</span>
weight[islocal]
<span class="co">#&gt; [1] 73 70 60 75 61 62 53 82</span>
weight[!islocal]
<span class="co">#&gt; [1] 68 55 52 80 78 54 56</span>
weight[!<span class="kw">rep</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>), <span class="dt">times =</span> <span class="dv">3</span>)]
<span class="co">#&gt; [1] 70 60 55 80 78 54 62 53 82</span></code></pre></div>
<p>判断一个值是否等于另一个只，是用 “==” 两个连续等号，因为单个等号有其他两个含义，一个是赋值符号，一个是在函数中指定参数值。</p>
<p>而判断一个值是否不等于另一个值，是否“!=”，一个否定的惊叹号紧接着一个等号。这里也是需要特别注意，因为有很多其他的编程语言用了其他的方式来表示不相等，比如“&lt;&gt;”，小于和大于号连用这种方式在R语言中是不能识别的。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span> ==<span class="st"> </span><span class="dv">1</span> <span class="co"># TRUE</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="dv">1</span> !=<span class="st"> </span><span class="dv">1</span> <span class="co"># FALSE</span>
<span class="co">#&gt; [1] FALSE</span>
<span class="dv">1</span> ==<span class="st"> </span><span class="dv">2</span> <span class="co"># FALSE</span>
<span class="co">#&gt; [1] FALSE</span>
<span class="dv">1</span> !=<span class="st"> </span><span class="dv">2</span> <span class="co"># TRUE</span>
<span class="co">#&gt; [1] TRUE</span>

weight[weight ==<span class="st"> </span><span class="dv">80</span>]
<span class="co">#&gt; [1] 80</span>
weight[weight !=<span class="st"> </span><span class="dv">80</span>]
<span class="co">#&gt;  [1] 73 70 68 60 55 52 75 78 54 61 62 56 53 82</span></code></pre></div>
<p>下表是常用的比较运算符号及其含义：</p>
<table>
<thead>
<tr class="header">
<th align="left">比较运算符号</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr class="even">
<td align="left">&gt;=</td>
<td align="left">大于等于</td>
</tr>
<tr class="odd">
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr class="even">
<td align="left">&lt;=</td>
<td align="left">小于等于</td>
</tr>
<tr class="odd">
<td align="left">==</td>
<td align="left">等于</td>
</tr>
<tr class="even">
<td align="left">!=</td>
<td align="left">等于</td>
</tr>
</tbody>
</table>
</div>
<div id="-subset-" class="section level4">
<h4><span class="header-section-number">1.1.6.4</span> 通过 subset() 筛选子集</h4>
<p>R语言中，有一个专门用来筛选子集的函数 <code>subset()</code>, 其参数为待筛选子集的对象，和一个逻辑表达式。</p>
<p>对向量来说，subset() 的用法和逻辑表达式筛选是类似的，subset()的含义，更多的是使用函数来操作，这在管道操作中比较有效，而不是“[]”这种符号化的操作。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">subset</span>(weight, weight &gt;=<span class="st"> </span><span class="dv">60</span>) <span class="co"># 等价于 weight[weight &gt;= 60]</span>
<span class="co">#&gt;  [1] 73 70 68 60 80 75 78 61 62 82</span></code></pre></div>
</div>
<div id="-head--tail-" class="section level4">
<h4><span class="header-section-number">1.1.6.5</span> 通过 head() 和 tail() 筛选首尾向量</h4>
<p>有时候，我们想要快速的查看某个向量的前几个元素，而不要在屏幕上将所有元素都出来，这样的函数就非常有用。</p>
<p>显示前几个元素函数是 <code>head()</code>，默认显示前6个元素。</p>
<p>对应地，也有一个显示最后几个元素的函数是 <code>tail()</code>，默认显示最后6个元素。</p>
<p>也就是 <code>头(head)</code> 和 <code>尾(tail)</code>。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(height)
<span class="co">#&gt; 宋子启 张伯仲 孟轲舆   张伟 王雪梅 陈梦妍 </span>
<span class="co">#&gt;   1.73   1.68   1.72   1.65   1.66   1.62</span>
<span class="kw">head</span>(name)
<span class="co">#&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;陈梦妍&quot;</span>
<span class="kw">head</span>(islocal)
<span class="co">#&gt; [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE</span>

<span class="kw">tail</span>(height)
<span class="co">#&gt;   蒋欣 沈约度 陈淮阳 况天佑 王珍珍 马小玲 </span>
<span class="co">#&gt;   1.71   1.72   1.69   1.74   1.70   1.72</span>
<span class="kw">tail</span>(name)
<span class="co">#&gt; [1] &quot;蒋欣&quot;   &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; &quot;马小玲&quot;</span>
<span class="kw">head</span>(islocal)
<span class="co">#&gt; [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE</span></code></pre></div>
<p><code>head()</code> 和 <code>tail()</code> 都有一个参数 <code>n</code> 可以指定具体显示元素的个数。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(height, <span class="dt">n =</span> <span class="dv">10</span>)
<span class="co">#&gt; 宋子启 张伯仲 孟轲舆   张伟 王雪梅 陈梦妍 李元礼 杨伯侨 赵蜚廉   蒋欣 </span>
<span class="co">#&gt;   1.73   1.68   1.72   1.65   1.66   1.62   1.81   1.74   1.78   1.71</span>
<span class="kw">head</span>(name, <span class="dt">n =</span> <span class="dv">3</span>)
<span class="co">#&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot;</span>
<span class="kw">head</span>(islocal, <span class="dt">n =</span> <span class="dv">6</span>)
<span class="co">#&gt; [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE</span>

<span class="kw">tail</span>(height, <span class="dt">n =</span> <span class="dv">10</span>)
<span class="co">#&gt; 陈梦妍 李元礼 杨伯侨 赵蜚廉   蒋欣 沈约度 陈淮阳 况天佑 王珍珍 马小玲 </span>
<span class="co">#&gt;   1.62   1.81   1.74   1.78   1.71   1.72   1.69   1.74   1.70   1.72</span>
<span class="kw">tail</span>(name, <span class="dt">n =</span> <span class="dv">3</span>)
<span class="co">#&gt; [1] &quot;况天佑&quot; &quot;王珍珍&quot; &quot;马小玲&quot;</span>
<span class="kw">head</span>(islocal, <span class="dt">n =</span> <span class="dv">6</span>)
<span class="co">#&gt; [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE</span></code></pre></div>
</div>
</div>
<div id="-factor" class="section level3">
<h3><span class="header-section-number">1.1.7</span> 因子向量 factor</h3>
<p>在这 15 名员工的信息中，现在新添加一列用来存储性别。</p>
<p>在R语言中有一种特殊的数据类型，可以用方便处理类别变量，称其为“因子(factor)”。</p>
<p><code>因子</code>根据类别是否具有顺序上的意义分为两类：</p>
<ul>
<li>无序因子：类别变量并未实际的顺序意义，如性别</li>
<li>有序因子：类别变量有实际的顺序意义，如年龄层、收入区间、优良中差等级，类别之间是有大小、高低、好坏等顺序信息的</li>
</ul>
<p>因子的类别，在R语言中有一个专有的名称，称为“水平(levels)”。</p>
<p>因子是通过 <code>factor()</code> 函数来定义的，跟普通的字符型向量创建类似，但需要指定 levels 有哪些，如果是有序因子则还要指定个水平的顺序。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gender &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;男&quot;</span>, <span class="st">&quot;男&quot;</span>, <span class="st">&quot;男&quot;</span>, <span class="st">&quot;男&quot;</span>, <span class="st">&quot;女&quot;</span>, <span class="st">&quot;女&quot;</span>, <span class="st">&quot;男&quot;</span>,  <span class="st">&quot;男&quot;</span>, <span class="st">&quot;男&quot;</span>, <span class="st">&quot;女&quot;</span>, <span class="st">&quot;男&quot;</span>, <span class="st">&quot;男&quot;</span>, <span class="st">&quot;男&quot;</span>, <span class="st">&quot;女&quot;</span>, <span class="st">&quot;女&quot;</span>),
                 <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;男&quot;</span>, <span class="st">&quot;女&quot;</span>)) <span class="co"># 一段完整的代码未结束时，其他参数可另起一行书写</span>
<span class="kw">print</span>(gender) <span class="co"># 除了显示该向量具体的类别信息外，还是显示所有水平</span>
<span class="co">#&gt;  [1] 男 男 男 男 女 女 男 男 男 女 男 男 男 女 女</span>
<span class="co">#&gt; Levels: 男 女</span>
<span class="kw">class</span>(gender) <span class="co"># 类为 factor</span>
<span class="co">#&gt; [1] &quot;factor&quot;</span></code></pre></div>
<hr />
<p>因子是一种向量，可以用 <code>is.atomic(x)</code> 来检验。</p>
<p>检验一个对象是否为因子，可以用 <code>is.factor(x)</code> 函数。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.atomic</span>(gender) <span class="co"># 因子是一种向量</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.factor</span>(gender) <span class="co"># 检验一个对象是否为因子</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<blockquote>
<p>从对象的类上来说，因子是一种向量，或者说是一种因子型向量，与逻辑型、数值型、字符型相对。</p>
</blockquote>
<hr />
<p>公司每年在年终结束的时候，需要进行绩效考核，评估员工在过去一年的表现，评级为“优”、“良”、“中”、“差”四种。</p>
<p>而该数据分析团队最终考核是结果只在“优”、“良”、“中”三个等级里，没有人被评级为“差”。在这种情况下，因子的水平就会体现出其作用来。绩效等级因子对应着四个水平，虽然团队考核最终只出现了三种，但从因子水平中可以看到有四种。</p>
<p>“优”、“良”、“中”、“差”四个等级，依次从好到差，是有顺序的，这种情况下因子的顺序也变成了一种有用的信息。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">grade &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;中&quot;</span>, <span class="st">&quot;良&quot;</span>, <span class="st">&quot;良&quot;</span>, <span class="st">&quot;中&quot;</span>, <span class="st">&quot;优&quot;</span>, <span class="st">&quot;良&quot;</span>, <span class="st">&quot;中&quot;</span>,  <span class="st">&quot;优&quot;</span>, <span class="st">&quot;中&quot;</span>, <span class="st">&quot;良&quot;</span>, <span class="st">&quot;良&quot;</span>, <span class="st">&quot;中&quot;</span>, <span class="st">&quot;良&quot;</span>, <span class="st">&quot;中&quot;</span>, <span class="st">&quot;优&quot;</span>),
                 <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;差&quot;</span>, <span class="st">&quot;中&quot;</span>, <span class="st">&quot;良&quot;</span>, <span class="st">&quot;优&quot;</span>),
                 <span class="dt">ordered =</span> <span class="ot">TRUE</span>) <span class="co"># ordered = TRUE 使用排序，具体的排序就是levels中的先后顺序，从小到大（从低到高）</span>
<span class="kw">print</span>(grade) <span class="co"># 除了显示该向量具体的类别信息外，还是显示所有水平</span>
<span class="co">#&gt;  [1] 中 良 良 中 优 良 中 优 中 良 良 中 良 中 优</span>
<span class="co">#&gt; Levels: 差 &lt; 中 &lt; 良 &lt; 优</span>
<span class="kw">class</span>(grade) <span class="co"># 有序的因子出了 factor 类之外，还有一个 ordered 的类</span>
<span class="co">#&gt; [1] &quot;ordered&quot; &quot;factor&quot;</span></code></pre></div>
<p>类似地，可以检验该对象是否为向量，是否为因子，是否是有序的。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.atomic</span>(grade) <span class="co"># 因子是一种向量</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.factor</span>(grade) <span class="co"># 检验一个对象是否为因子对象</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.ordered</span>(grade) <span class="co"># 检验一个对象是否为有序对象</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>因子在统计分析中可能会用的比较多，但在我自己的实践中用得很少，多数情况下可以将其作为字符型向量使用即可。</p>
<p>我个人会在 ggplot2 的画图中有时会用到有序的因子，用来指定图例和分面的顺序。</p>
</div>
<div id="-date" class="section level3">
<h3><span class="header-section-number">1.1.8</span> 日期向量 Date</h3>
<p>还有一种常用的数据格式是日期型向量，比如该数据分析团队15名成员的出生日期，类似“1984-02-28”这样的日期。</p>
<p>最常用的日期格式是“yyyy-mm-dd”这样表示的，分别代表年月日。如果单就这样用引号引起来的格式，那应该算字符，需要将其特殊定义为“日期”类或者说转化为日期类，系统才能真正识别其为日期。</p>
<p>将系统能够识别为日期的字符串，强制转为为日期类 <code>as.Date(x)</code> 是最为常见的定义日期的方法。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">birthday &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="st">&quot;1984-02-28&quot;</span>, <span class="st">&quot;1988-09-26&quot;</span>, <span class="st">&quot;1989-07-28&quot;</span>, <span class="st">&quot;1990-01-25&quot;</span>, <span class="st">&quot;1987-04-30&quot;</span>,
                      <span class="st">&quot;1989-12-20&quot;</span>, <span class="st">&quot;1992-06-14&quot;</span>, <span class="st">&quot;1991-07-01&quot;</span>, <span class="st">&quot;1990-08-08&quot;</span>, <span class="st">&quot;1985-05-10&quot;</span>,
                      <span class="st">&quot;1993-04-01&quot;</span>, <span class="st">&quot;1991-03-05&quot;</span>, <span class="st">&quot;1991-09-25&quot;</span>, <span class="st">&quot;1992-01-31&quot;</span>, <span class="st">&quot;1988-02-14&quot;</span>))
<span class="kw">print</span>(birthday) <span class="co"># 屏幕上打印的结果，看起来和字符串没什么分别</span>
<span class="co">#&gt;  [1] &quot;1984-02-28&quot; &quot;1988-09-26&quot; &quot;1989-07-28&quot; &quot;1990-01-25&quot; &quot;1987-04-30&quot;</span>
<span class="co">#&gt;  [6] &quot;1989-12-20&quot; &quot;1992-06-14&quot; &quot;1991-07-01&quot; &quot;1990-08-08&quot; &quot;1985-05-10&quot;</span>
<span class="co">#&gt; [11] &quot;1993-04-01&quot; &quot;1991-03-05&quot; &quot;1991-09-25&quot; &quot;1992-01-31&quot; &quot;1988-02-14&quot;</span>
<span class="kw">class</span>(birthday) <span class="co"># 类是 Date </span>
<span class="co">#&gt; [1] &quot;Date&quot;</span>
<span class="kw">is.atomic</span>(birthday) <span class="co"># 是否为向量</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">class</span>(birthday) ==<span class="st"> &quot;Date&quot;</span> <span class="co"># 系统没有自带的 is.Date 的函数，可以用此方法来检验</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>日期实际上是一种以“日”为单位的时间，是一维单向的向量，只要定义一个点为 0 点，则可用实数来表示。</p>
<p>在 R语言中，系统定义的 0 点是 “1970-01-01”，这与Unix系统中日期的原点保持一致。</p>
<blockquote>
<p>实际上起点定义为哪天是无所谓的，因为时间既没有开始也没有结算，只有相对的差值是有意义的。</p>
</blockquote>
<p>日期类向量在存储上是以数字来存储的。</p>
<p>日期的差值有意义，故而两个日期值可以相减，得到结果是数值型。从此可以推演出来，两个日期之间不能直接相减，但一个日期与一个数值相加减可以得到另一个有意义的日期值。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.Date</span>(<span class="st">&quot;1984-01-02&quot;</span>) -<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;1984-01-01&quot;</span>) <span class="co"># 两个日期之间相差的天数</span>
<span class="co">#&gt; Time difference of 1 days</span>
<span class="kw">as.Date</span>(<span class="st">&quot;1984-01-01&quot;</span>) +<span class="st"> </span><span class="dv">1</span> <span class="co"># 一个日期加一个天数可以得到另一个日期</span>
<span class="co">#&gt; [1] &quot;1984-01-02&quot;</span>
<span class="kw">Sys.Date</span>() <span class="co"># 系统函数，返回当前日期，并且为日期型</span>
<span class="co">#&gt; [1] &quot;2016-08-07&quot;</span>
<span class="kw">Sys.Date</span>() -<span class="st"> </span><span class="dv">1</span> <span class="co"># 昨天，定期执行脚本的程序常用系统日期函数引申出来的日期作为变量</span>
<span class="co">#&gt; [1] &quot;2016-08-06&quot;</span></code></pre></div>

</div>
</div>
<div id="-matrix" class="section level2">
<h2><span class="header-section-number">1.2</span> 矩阵 matrix</h2>
<div id="section-1.2.1" class="section level3">
<h3><span class="header-section-number">1.2.1</span> 创建矩阵</h3>
<p>矩阵是线性代数上常用的一个概念，是由行和列组成的数据结构。</p>
<p>创建矩阵的方法是通过 matrix() 函数来定义。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 矩阵的定义函数、参数及参数默认值</span>
<span class="kw">matrix</span>(<span class="dt">data =</span> <span class="ot">NA</span>, <span class="dt">nrow =</span> <span class="dv">1</span>, <span class="dt">ncol =</span> <span class="dv">1</span>, <span class="dt">byrow =</span> <span class="ot">FALSE</span>, <span class="dt">dimnames =</span> <span class="ot">NULL</span>)
<span class="co"># 参数</span>
<span class="co"># data 是原始数据，通常是一个向量</span>
<span class="co"># nrow 是行的数量（行数）</span>
<span class="co"># ncol 是列的数量（两书）</span>
<span class="co"># byrow 是原始数据（向量）是否按行排列填充，默认 FALSE 则默认不按行排列，即默认按列来排列填充</span>
<span class="co"># dimnames 是维度的名称属性，也就是行和列的名称向量，默认是空（不启用名称属性）</span></code></pre></div>
<p>通过向量来创建矩阵，可以看做是将原来一维的向量元素，按照行和列重新排列填充，形成一个新结构的对象。</p>
<p>比如我们对原来15名员工的身高进行重排列变成一个3行5列的矩阵：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">height &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">15</span>)
<span class="kw">print</span>(height) <span class="co"># 先将原来15名员工的身高数据显示出来</span>
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</span>
<span class="kw">matrix</span>(<span class="dt">data =</span> height, <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">5</span>) <span class="co"># 将身高 height 数据转变成3*5的矩阵</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    4    7   10   13</span>
<span class="co">#&gt; [2,]    2    5    8   11   14</span>
<span class="co">#&gt; [3,]    3    6    9   12   15</span>
<span class="co"># 对比height向量和新矩阵数据，两者包含的数据和顺序都一样</span>
<span class="co"># 两者只是排列方式从一维数据，变成了3行5列的二维数据</span>
<span class="co"># 可以将员工每连续3个一组分共5组，或者每隔5个分为一组共3组</span></code></pre></div>
<p>数据的排列方式默认是按列填充，但可以更改</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_height &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> height, <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">5</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>) <span class="co"># 排列方式更为按行填充</span>
<span class="kw">print</span>(m_height)
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    2    3    4    5</span>
<span class="co">#&gt; [2,]    6    7    8    9   10</span>
<span class="co">#&gt; [3,]   11   12   13   14   15</span></code></pre></div>
</div>
<div id="section-1.2.2" class="section level3">
<h3><span class="header-section-number">1.2.2</span> 矩阵维度</h3>
<p>矩阵有一个属性叫做<code>维度(dim)</code>，因为矩阵是二维的，所以矩阵的维度分别是行和列，其值就是<code>行数(nrow)</code>和<code>列数(ncol)</code>组成的包含两个整数的向量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(m_height) 
<span class="co">#&gt; [1] 3 5</span>
<span class="co"># 第一个数值对应的就是 nrow ，第二个数值对应的就是 ncol</span>
<span class="co"># nrow 和 ncol 与 matrix() 矩阵定义中两个参数 nrow 和 ncol 是一一对应的</span>
<span class="co"># nrow 的全称是 Number of Rows</span>
<span class="co"># ncol 的全称是 Number of Columns</span></code></pre></div>
<p>如果只需要单独获得矩阵的行数或者列数，可则使用 <code>nrow()</code> 和 <code>ncol()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(m_height) <span class="co"># 行数；等价于 dim(m_height)[1]</span>
<span class="co">#&gt; [1] 3</span>
<span class="kw">ncol</span>(m_height) <span class="co"># 列数；等价于 dim(m_height)[2]</span>
<span class="co">#&gt; [1] 5</span></code></pre></div>
<p>R语言中每个对象都有其长度，对矩阵而言，<code>length()</code>返回的是矩阵所有元素的个数，并且等于矩阵的行数与列数乘积。</p>
<p>对矩阵而言，长度并不是一个常用的概念；更多的时候，用行数和列数更实用。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(m_height) <span class="co"># 矩阵的长度表示矩阵的所有元素个数</span>
<span class="co">#&gt; [1] 15</span>
<span class="co">#等价于行数与列数的乘积</span>
<span class="kw">nrow</span>(m_height) *<span class="st"> </span><span class="kw">ncol</span>(m_height) 
<span class="co">#&gt; [1] 15</span></code></pre></div>
</div>
<div id="section-1.2.3" class="section level3">
<h3><span class="header-section-number">1.2.3</span> 矩阵索引</h3>
<p>类似于向量通过<code>[]</code>来索引定位具体的元素，矩阵也沿用此方法，但需要行和列两部分<code>[,]</code>才能索引定位到具体的元素，他们中间用逗号分隔，前者表示行索引，后者表示列索引。</p>
<div id="section-1.2.3.1" class="section level4">
<h4><span class="header-section-number">1.2.3.1</span> 位置整数索引</h4>
<p>矩阵位置索引的逻辑与向量是一样的，只是索引需要行和列两部分构成。</p>
<ul>
<li><p>通过第n行第m列来定位一个具体的单个元素。</p></li>
<li><p>通过某几行（向量）、某几列（向量）来定位某些元素。</p></li>
<li><p>如果行或者列没有输入（即缺省），则表示不限制具体的行或者列（也就是所有行或者所有列）。</p></li>
<li><p>去掉某几行或者莫几列，用对应的负数。</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_height <span class="co"># 原矩阵，打印到屏幕上，后续的索引解决与此对比验证</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    2    3    4    5</span>
<span class="co">#&gt; [2,]    6    7    8    9   10</span>
<span class="co">#&gt; [3,]   11   12   13   14   15</span>
m_height[<span class="dv">3</span>,<span class="dv">4</span>, drop =<span class="st"> </span><span class="ot">FALSE</span>] <span class="co"># 第3行，第4列的元素</span>
<span class="co">#&gt;      [,1]</span>
<span class="co">#&gt; [1,]   14</span>
m_height[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>),<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">5</span>)] <span class="co"># 第1和第3行，第2和第5列的元素</span>
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    2    5</span>
<span class="co">#&gt; [2,]   12   15</span>
m_height[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>),] <span class="co"># 第1和第3行，所有列的元素</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    2    3    4    5</span>
<span class="co">#&gt; [2,]   11   12   13   14   15</span>
m_height[,<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">5</span>)] <span class="co"># 所有行，第2和第5列的元素</span>
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    2    5</span>
<span class="co">#&gt; [2,]    7   10</span>
<span class="co">#&gt; [3,]   12   15</span>
m_height[-<span class="dv">2</span>,<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">5</span>)] <span class="co"># 去除第2行，包含第2和第5列的元素</span>
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    2    5</span>
<span class="co">#&gt; [2,]   12   15</span></code></pre></div>
</div>
<div id="section-1.2.3.2" class="section level4">
<h4><span class="header-section-number">1.2.3.2</span> 逻辑向量索引</h4>
<p>类似于向量，矩阵的逻辑索引由行和列对应的两个逻辑向量完成，索引的结果就是对应为<code>TRUE</code>的行和列。</p>
<p>行和列的逻辑向量的长度，分别等于 <code>nrow</code> 和 <code>ncol</code>; 如果逻辑索引向量的长度小于矩阵的行列数则遵循向量循环补齐原则。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_height <span class="co"># 原矩阵</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    2    3    4    5</span>
<span class="co">#&gt; [2,]    6    7    8    9   10</span>
<span class="co">#&gt; [3,]   11   12   13   14   15</span>
m_height[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>), <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>,<span class="ot">TRUE</span>)] <span class="co"># 第3行，第4列的元素</span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]    1    3    5</span>
<span class="co">#&gt; [2,]   11   13   15</span>
m_height[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>), <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>)] <span class="co"># 行列索引的向量长度小于矩阵的行列数，索引的向量遵循循环补齐原则</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4]</span>
<span class="co">#&gt; [1,]    1    2    4    5</span>
<span class="co">#&gt; [2,]   11   12   14   15</span>

<span class="co"># 循环补齐后等价于 </span>
m_height[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>), <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">TRUE</span>)] 
<span class="co">#&gt;      [,1] [,2] [,3] [,4]</span>
<span class="co">#&gt; [1,]    1    2    4    5</span>
<span class="co">#&gt; [2,]   11   12   14   15</span></code></pre></div>
</div>
<div id="section-1.2.3.3" class="section level4">
<h4><span class="header-section-number">1.2.3.3</span> 逻辑矩阵</h4>
<p>通过逻辑表达式可以获得对应的逻辑矩阵。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_height &gt;<span class="st"> </span><span class="fl">1.7</span> <span class="co"># 矩阵中哪些元素大于 1.7</span>
<span class="co">#&gt;       [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,] FALSE TRUE TRUE TRUE TRUE</span>
<span class="co">#&gt; [2,]  TRUE TRUE TRUE TRUE TRUE</span>
<span class="co">#&gt; [3,]  TRUE TRUE TRUE TRUE TRUE</span></code></pre></div>
<p>通过逻辑矩阵来索引矩阵，得到的是矩阵中对应逻辑为真的元素，是一个向量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_height[m_height &gt;<span class="st"> </span><span class="fl">1.7</span>] <span class="co"># 索引大于 1.7 的元素</span>
<span class="co">#&gt;  [1]  6 11  2  7 12  3  8 13  4  9 14  5 10 15</span></code></pre></div>
</div>
<div id="section-1.2.3.4" class="section level4">
<h4><span class="header-section-number">1.2.3.4</span> 行列名称索引</h4>
<p>在矩阵创建时可以定义行和列的名称，但也可以在创建创建后再定义行和列的名称，这种方法更为实用。</p>
<p>通过<code>rownames()</code> 来定义行名称， <code>colnames()</code>来定义列名称。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rownames</span>(m_height) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>) <span class="co"># 行名称</span>
<span class="kw">colnames</span>(m_height) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;col_1&quot;</span>, <span class="st">&quot;col_2&quot;</span>, <span class="st">&quot;col_3&quot;</span>, <span class="st">&quot;col_4&quot;</span>, <span class="st">&quot;col_5&quot;</span>) <span class="co"># 列名称</span>
<span class="kw">print</span>(m_height)
<span class="co">#&gt;   col_1 col_2 col_3 col_4 col_5</span>
<span class="co">#&gt; A     1     2     3     4     5</span>
<span class="co">#&gt; B     6     7     8     9    10</span>
<span class="co">#&gt; C    11    12    13    14    15</span></code></pre></div>
<p>在有了矩阵的名称属性之后，就可以通过行和列的名称属性来索引向量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_height[<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;C&quot;</span>), <span class="kw">c</span>(<span class="st">&quot;col_1&quot;</span>, <span class="st">&quot;col_3&quot;</span>, <span class="st">&quot;col_5&quot;</span>)]
<span class="co">#&gt;   col_1 col_3 col_5</span>
<span class="co">#&gt; A     1     3     5</span>
<span class="co">#&gt; C    11    13    15</span></code></pre></div>
</div>
<div id="subset" class="section level4">
<h4><span class="header-section-number">1.2.3.5</span> subset筛选行和列</h4>
<p><code>subset(x, subset, select)</code>函数可以对矩阵使用，筛选符合条件的行和列。</p>
<p><code>subset</code> 参数是针对要筛选行的条件，是一个逻辑表达式，长度与函数相同。</p>
<p><code>select</code> 参数是针对要筛选的列条件，可以是位置（列数）的整数向量，也可以是列名（如果有列名称属性的话）的字符向量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">subset</span>(m_height, m_height[,<span class="dv">1</span>] &gt;<span class="st"> </span><span class="fl">1.7</span>, <span class="dv">2</span>:<span class="dv">4</span>) <span class="co"># 筛选矩阵第1列中大于1.7的行，并提取第2到第4列</span>
<span class="co">#&gt;   col_2 col_3 col_4</span>
<span class="co">#&gt; B     7     8     9</span>
<span class="co">#&gt; C    12    13    14</span>

<span class="kw">subset</span>(m_height, m_height[,<span class="dv">5</span>] &gt;<span class="st"> </span><span class="fl">1.7</span>, <span class="kw">c</span>(<span class="st">&quot;col_1&quot;</span>, <span class="st">&quot;col_3&quot;</span>, <span class="st">&quot;col_5&quot;</span>)) <span class="co"># 筛选矩阵第5列中大于1.7的行，并提取名字为&quot;col_1&quot;、&quot;col_3&quot;、&quot;col_5&quot;的列</span>
<span class="co">#&gt;   col_1 col_3 col_5</span>
<span class="co">#&gt; A     1     3     5</span>
<span class="co">#&gt; B     6     8    10</span>
<span class="co">#&gt; C    11    13    15</span>

<span class="kw">subset</span>(m_height, m_height[,<span class="dv">1</span>] &gt;<span class="st"> </span><span class="fl">1.7</span>, m_height[<span class="dv">3</span>,] &gt;<span class="st"> </span><span class="fl">1.7</span>) <span class="co"># 筛选矩阵第1列中大于1.7的行，筛选矩阵第3行中大于1.7的列</span>
<span class="co">#&gt;   col_1 col_2 col_3 col_4 col_5</span>
<span class="co">#&gt; B     6     7     8     9    10</span>
<span class="co">#&gt; C    11    12    13    14    15</span></code></pre></div>
<p><code>subset</code>函数虽然对矩阵有效，但是并不常用。</p>
</div>
<div id="headtail" class="section level4">
<h4><span class="header-section-number">1.2.3.6</span> head/tail筛选首尾行</h4>
<p><code>head()</code> 和 <code>tail()</code>同样适用与矩阵，但是参数 n 表示的是行数；也就是只能筛选行，而不能筛选列。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(m_height, <span class="dt">n =</span> <span class="dv">2</span>) <span class="co"># </span>
<span class="co">#&gt;   col_1 col_2 col_3 col_4 col_5</span>
<span class="co">#&gt; A     1     2     3     4     5</span>
<span class="co">#&gt; B     6     7     8     9    10</span>
<span class="kw">tail</span>(m_height, <span class="dv">2</span>)
<span class="co">#&gt;   col_1 col_2 col_3 col_4 col_5</span>
<span class="co">#&gt; B     6     7     8     9    10</span>
<span class="co">#&gt; C    11    12    13    14    15</span></code></pre></div>
</div>
</div>
<div id="section-1.2.4" class="section level3">
<h3><span class="header-section-number">1.2.4</span> 矩阵合并</h3>
<p>类似于向量合并是用<code>c()</code>函数，矩阵的合并分为按行合并 <code>rbind()</code> 和 按列合并 <code>cbind()</code>。</p>
<p>按行合并，要求合并的矩阵其列数相同；按列合并，要求合并的矩阵其行数相同；否则会报错。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mc_height &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> height, <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">5</span>, <span class="dt">byrow =</span> <span class="ot">FALSE</span>) <span class="co"># 排列方式更为按列填充</span>
mr_height &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> height, <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">5</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>) <span class="co"># 排列方式更为按行填充</span>
<span class="kw">print</span>(mc_height)
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    4    7   10   13</span>
<span class="co">#&gt; [2,]    2    5    8   11   14</span>
<span class="co">#&gt; [3,]    3    6    9   12   15</span>
<span class="kw">print</span>(mr_height)
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    2    3    4    5</span>
<span class="co">#&gt; [2,]    6    7    8    9   10</span>
<span class="co">#&gt; [3,]   11   12   13   14   15</span>
<span class="kw">rbind</span>(mc_height, mr_height) <span class="co"># 按行合并</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    4    7   10   13</span>
<span class="co">#&gt; [2,]    2    5    8   11   14</span>
<span class="co">#&gt; [3,]    3    6    9   12   15</span>
<span class="co">#&gt; [4,]    1    2    3    4    5</span>
<span class="co">#&gt; [5,]    6    7    8    9   10</span>
<span class="co">#&gt; [6,]   11   12   13   14   15</span>
<span class="kw">cbind</span>(mc_height, mr_height) <span class="co"># 按列合并</span>
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]</span>
<span class="co">#&gt; [1,]    1    4    7   10   13    1    2    3    4     5</span>
<span class="co">#&gt; [2,]    2    5    8   11   14    6    7    8    9    10</span>
<span class="co">#&gt; [3,]    3    6    9   12   15   11   12   13   14    15</span></code></pre></div>
</div>
<div id="section-1.2.5" class="section level3">
<h3><span class="header-section-number">1.2.5</span> 矩阵计算</h3>
<div id="section-1.2.5.1" class="section level4">
<h4><span class="header-section-number">1.2.5.1</span> 矩阵算术运算</h4>
<p>矩阵算术运算与向量类似，对应元素之间的运算。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_height &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> height, <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">5</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>) <span class="co"># 排列方式更为按行填充</span>
m_weight &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> weight, <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">5</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>) <span class="co"># 排列方式更为按行填充</span>
m_weight/(m_height^<span class="dv">2</span>) <span class="co"># 身高质量指数；对应元素之间做算术运算</span>
<span class="co">#&gt;        [,1]   [,2]  [,3]  [,4]  [,5]</span>
<span class="co">#&gt; [1,] 73.000 17.500 7.556 3.750 2.200</span>
<span class="co">#&gt; [2,]  1.444  1.633 1.172 0.963 0.540</span>
<span class="co">#&gt; [3,]  0.504  0.431 0.331 0.270 0.364</span></code></pre></div>
</div>
<div id="section-1.2.5.2" class="section level4">
<h4><span class="header-section-number">1.2.5.2</span> 矩阵代数运算</h4>
<p>矩阵代数运算，有一套自己特有的法则，对应了特殊的运算符号和函数。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(m_height)
<span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span>
<span class="co">#&gt; [1,]    1    2    3    4    5</span>
<span class="co">#&gt; [2,]    6    7    8    9   10</span>
<span class="co">#&gt; [3,]   11   12   13   14   15</span>
<span class="kw">t</span>(m_height) <span class="co"># 转置，行列转化</span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]    1    6   11</span>
<span class="co">#&gt; [2,]    2    7   12</span>
<span class="co">#&gt; [3,]    3    8   13</span>
<span class="co">#&gt; [4,]    4    9   14</span>
<span class="co">#&gt; [5,]    5   10   15</span>
<span class="kw">det</span>(m_height[<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">1</span>:<span class="dv">3</span>]) <span class="co"># 求行列式，要求矩阵必须是方阵（正方形矩阵，行数和列数相同）</span>
<span class="co">#&gt; [1] 2.22e-15</span>
<span class="kw">diag</span>(m_height[<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">1</span>:<span class="dv">3</span>]) <span class="co"># 求矩阵对角线上的元素</span>
<span class="co">#&gt; [1]  1  7 13</span></code></pre></div>
<p>线性代数中有非常多的矩阵性质与运算逻辑，这里不一一列出。</p>
</div>
</div>
<div id="section-1.2.6" class="section level3">
<h3><span class="header-section-number">1.2.6</span> 矩阵检验与转化</h3>
<p>矩阵是一种基于向量上构建的特殊结构，其类属性为 <code>matrix</code>，有一个特殊的维度属性 <code>dim</code>。</p>
<p>检验一个对象是否为矩阵，实际上是验证该对象的类是否为 matrix 及是否具有 dim 属性及 dim 的结果是否为包含连个整数值的向量。</p>
<p>类判断函数，本质上是去校验对象是否符合对应类的定义。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(m_height) <span class="co"># 显示对象的类，如果是矩阵，就显示为 matrix</span>
<span class="co">#&gt; [1] &quot;matrix&quot;</span>
<span class="kw">is.matrix</span>(m_height) <span class="co"># 对象是否为矩阵</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">as.matrix</span>(height) <span class="co"># 将对象转化为矩阵</span>
<span class="co">#&gt;       [,1]</span>
<span class="co">#&gt;  [1,]    1</span>
<span class="co">#&gt;  [2,]    2</span>
<span class="co">#&gt;  [3,]    3</span>
<span class="co">#&gt;  [4,]    4</span>
<span class="co">#&gt;  [5,]    5</span>
<span class="co">#&gt;  [6,]    6</span>
<span class="co">#&gt;  [7,]    7</span>
<span class="co">#&gt;  [8,]    8</span>
<span class="co">#&gt;  [9,]    9</span>
<span class="co">#&gt; [10,]   10</span>
<span class="co">#&gt; [11,]   11</span>
<span class="co">#&gt; [12,]   12</span>
<span class="co">#&gt; [13,]   13</span>
<span class="co">#&gt; [14,]   14</span>
<span class="co">#&gt; [15,]   15</span>
<span class="co"># 这里待转化对象是向量故而结果为列数等于1的矩阵，行数等于向量的长度</span></code></pre></div>
</div>
</div>
<div id="-array" class="section level2">
<h2><span class="header-section-number">1.3</span> 数组 array</h2>
<p>数组可以看做是具有多维结构的向量，也就是将原本一维的向量，改变索引结构变为多维表示。</p>
<p>创建数组的方法是通过 array() 函数。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">array</span>(<span class="dt">data =</span> <span class="ot">NA</span>, <span class="dt">dim =</span> <span class="kw">length</span>(data), <span class="dt">dimnames =</span> <span class="ot">NULL</span>)
<span class="co"># data 是要创建数组的向量，其元素用于构建数组</span>
<span class="co"># dim 为数组的维数向量(为数值型向 量)</span>
<span class="co"># dimnames 为由各维的名称构成的向量(为字符型向量)</span></code></pre></div>
<p>比如，将 <code>1:30</code> 的向量，按照 <code>2*3*5</code> 的3维结构重新排列为数组，则需要三个位置数字向量才能定位到一个具体的元素。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">30</span>, <span class="dt">dim =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>))
<span class="kw">print</span>(a) <span class="co"># 因为该数组是3维结构，而屏幕只能显示2维平面，故而按第3个维度每个维数切片显示</span>
<span class="co">#&gt; , , 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]    1    3    5</span>
<span class="co">#&gt; [2,]    2    4    6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; , , 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]    7    9   11</span>
<span class="co">#&gt; [2,]    8   10   12</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; , , 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]   13   15   17</span>
<span class="co">#&gt; [2,]   14   16   18</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; , , 4</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]   19   21   23</span>
<span class="co">#&gt; [2,]   20   22   24</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; , , 5</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]   25   27   29</span>
<span class="co">#&gt; [2,]   26   28   30</span>
<span class="kw">dim</span>(a) <span class="co"># 维度向量，按顺序分别代表了每个维度的维数</span>
<span class="co">#&gt; [1] 2 3 5</span>
<span class="kw">class</span>(a) <span class="co"># 对象的类，如果是数组，则结果为 array</span>
<span class="co">#&gt; [1] &quot;array&quot;</span>
<span class="kw">is.array</span>(a) <span class="co"># 检验对象是否为数组类：判断元素的模式是否相同，判断dim属性是否不为NULL</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>矩阵是数组在二维结构上的特殊形式。因为矩阵在数学上常用，且有一套矩阵运算和代数上的意义，故而将其独立作为一个类。</p>
<p>数组的索引，类似矩阵，只是维数不同。不同维度的索引，中间用逗号隔开。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a[<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>] <span class="co"># 第1为第2个切片，第2为的第1个切片，第3为的第4个切片，三个维度联合定位的元素 </span>
<span class="co">#&gt; [1] 20</span>
a[<span class="dv">1</span>:<span class="dv">2</span>, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">5</span>)] <span class="co"># 第1为第1到2个切片，第2为的第2和第3个切片，第3为的第1第4和第5个切片</span>
<span class="co">#&gt; , , 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    3    5</span>
<span class="co">#&gt; [2,]    4    6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; , , 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]   21   23</span>
<span class="co">#&gt; [2,]   22   24</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; , , 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]   27   29</span>
<span class="co">#&gt; [2,]   28   30</span></code></pre></div>
<p>同样可以使用名称索引，如果有名称属性的话。</p>
<p>每个维度的索引也可以使用对应的逻辑向量，其长度与对应的维数相同。</p>
<p><code>subset()</code>和<code>head()/tail()</code>函数，虽然可以对应用在数据上，但并无实际上的意义。</p>

</div>
<div id="-data.frame" class="section level2">
<h2><span class="header-section-number">1.4</span> 数据框 data.frame</h2>
<p>数据框是R语言中的一个种表格结构，对应于数据库中的表，类似Excel中的数据表。数据框的是由多个向量构成，每个向量的长度相同。</p>
<p>数据框类似于矩阵，也是一个二维表结构。</p>
<p>在统计学术语中，用<code>行</code>来表示<code>观测(observations)</code>，用<code>列</code>来表示<code>变量(variables)</code>。</p>
<p>类似于数据库系统，<code>行</code>代表数据表的<code>记录(records)</code>,<code>列</code>代表数据表的<code>字段(fields)</code>。</p>
<p>针对数据框来说，可能会在不同的情景下使用<code>行</code>、<code>观测</code>、<code>记录</code>这几个名称，他们指代的含义相同；类似的，也可能会在不同的情景下使用<code>列</code>、<code>变量</code>、<code>字段</code>这几个名称，他们指代的也含义相同；并不会再特别说明，怎么适合表达就怎么用。</p>
<div id="section-1.4.1" class="section level3">
<h3><span class="header-section-number">1.4.1</span> 创建数据框</h3>
<p>创建数据框，最简单的方法就是用同名的定义函数 data.frame()，输入每个变量的名称及对应的向量，每个向量的长度相同。</p>
<p>针对示例过程中创建的15名员工信息的向量，将其组合成一个员工信息表：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 当参数较多时，可以换行书写，使得函数结构更为清晰</span>
employee &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">name =</span> name,
                       <span class="dt">height =</span> height,
                       <span class="dt">weight =</span> weight,
                       <span class="dt">islocal =</span> islocal,
                       <span class="dt">gender =</span> gender,
                       <span class="dt">grade =</span> grade,
                       <span class="dt">birthday =</span> birthday
                       )
<span class="kw">print</span>(employee) <span class="co"># 打印数据框时，会在屏幕中显示行的序号和变量名称</span>
<span class="co">#&gt;          name height weight islocal gender grade   birthday</span>
<span class="co">#&gt; 宋子启 宋子启   1.73     73    TRUE     男    中 1984-02-28</span>
<span class="co">#&gt; 张伯仲 张伯仲   1.68     70    TRUE     男    良 1988-09-26</span>
<span class="co">#&gt; 孟轲舆 孟轲舆   1.72     68   FALSE     男    良 1989-07-28</span>
<span class="co">#&gt; 张伟     张伟   1.65     60    TRUE     男    中 1990-01-25</span>
<span class="co">#&gt; 王雪梅 王雪梅   1.66     55   FALSE     女    优 1987-04-30</span>
<span class="co">#&gt; 陈梦妍 陈梦妍   1.62     52   FALSE     女    良 1989-12-20</span>
<span class="co">#&gt; 李元礼 李元礼   1.81     80   FALSE     男    中 1992-06-14</span>
<span class="co">#&gt; 杨伯侨 杨伯侨   1.74     75    TRUE     男    优 1991-07-01</span>
<span class="co">#&gt; 赵蜚廉 赵蜚廉   1.78     78   FALSE     男    中 1990-08-08</span>
<span class="co">#&gt; 蒋欣     蒋欣   1.71     54   FALSE     女    良 1985-05-10</span>
<span class="co">#&gt; 沈约度 沈约度   1.72     61    TRUE     男    良 1993-04-01</span>
<span class="co">#&gt; 陈淮阳 陈淮阳   1.69     62    TRUE     男    中 1991-03-05</span>
<span class="co">#&gt; 况天佑 况天佑   1.74     56   FALSE     男    良 1991-09-25</span>
<span class="co">#&gt; 王珍珍 王珍珍   1.70     53    TRUE     女    中 1992-01-31</span>
<span class="co">#&gt; 马小玲 马小玲   1.72     82    TRUE     女    优 1988-02-14</span>
<span class="kw">class</span>(employee) <span class="co"># 对象的类，数据框类的名称为 data.frame</span>
<span class="co">#&gt; [1] &quot;data.frame&quot;</span>
<span class="kw">is.data.frame</span>(employee) <span class="co"># 判断一个对象是否为数据框</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>变量的名称可以自定义，只要符合R语言对象命名规则即可，上面的自理正好使用和已有向量相同的名字而已。例如下面创建的数据框，变量的名字是任意给定的：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>, <span class="st">&quot;A&quot;</span>, <span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dt">b =</span> <span class="kw">c</span>(-<span class="fl">0.33</span>, <span class="fl">0.07</span>, -<span class="fl">0.40</span>, <span class="fl">0.77</span>, <span class="fl">0.24</span>, <span class="fl">1.07</span>))
<span class="kw">print</span>(df)
<span class="co">#&gt;   a     b</span>
<span class="co">#&gt; 1 A -0.33</span>
<span class="co">#&gt; 2 B  0.07</span>
<span class="co">#&gt; 3 C -0.40</span>
<span class="co">#&gt; 4 A  0.77</span>
<span class="co">#&gt; 5 A  0.24</span>
<span class="co">#&gt; 6 B  1.07</span></code></pre></div>
</div>
<div id="section-1.4.2" class="section level3">
<h3><span class="header-section-number">1.4.2</span> 数据框的属性</h3>
<p>数据框是二维的数据表，故而继承了很多矩阵的属性和计算函数。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(employee) <span class="co"># 维度属性，行数和列数，也就是观测数和变量数</span>
<span class="co">#&gt; [1] 15  7</span>
<span class="kw">nrow</span>(employee) <span class="co"># 行数，也就是观测数，记录数</span>
<span class="co">#&gt; [1] 15</span>
<span class="kw">ncol</span>(employee) <span class="co"># 列数，也就是变量数，字段数</span>
<span class="co">#&gt; [1] 7</span>
<span class="kw">rownames</span>(employee) <span class="co"># 行名称，如果没有命名则返回行序号向量</span>
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot;</span>
<span class="co">#&gt;  [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;   &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot;</span>
<span class="co">#&gt; [15] &quot;马小玲&quot;</span>
<span class="kw">colnames</span>(employee) <span class="co"># 列名称，返回变量名称；数据框中变量名称是必须指定的</span>
<span class="co">#&gt; [1] &quot;name&quot;     &quot;height&quot;   &quot;weight&quot;   &quot;islocal&quot;  &quot;gender&quot;   &quot;grade&quot;   </span>
<span class="co">#&gt; [7] &quot;birthday&quot;</span>
<span class="kw">row.names</span>(employee) <span class="co"># 行的名称，数据框自己定义的属性，与 rownames 相同</span>
<span class="co">#&gt;  [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot;   &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot;</span>
<span class="co">#&gt;  [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot;   &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot;</span>
<span class="co">#&gt; [15] &quot;马小玲&quot;</span>
<span class="kw">names</span>(employee) <span class="co"># 变量名称，数据框自己定义的属性，与 colnames 相同</span>
<span class="co">#&gt; [1] &quot;name&quot;     &quot;height&quot;   &quot;weight&quot;   &quot;islocal&quot;  &quot;gender&quot;   &quot;grade&quot;   </span>
<span class="co">#&gt; [7] &quot;birthday&quot;</span>
<span class="co"># 数据框中变量名称更为重要，故而直接用 names() 函数返回，更为便捷</span></code></pre></div>
<div id="section-1.4.2.1" class="section level4">
<h4><span class="header-section-number">1.4.2.1</span> 数据框的合并</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">V1 =</span> <span class="dv">1</span>:<span class="dv">2</span>, <span class="dt">V2 =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>)) ; <span class="kw">print</span>(df_1) <span class="co"># 两个语句之间可以用`;`隔开就可以写在一行中</span>
<span class="co">#&gt;   V1 V2</span>
<span class="co">#&gt; 1  1  A</span>
<span class="co">#&gt; 2  2  B</span>
<span class="kw">print</span>(df_2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">V1 =</span> <span class="dv">3</span>:<span class="dv">3</span>, <span class="dt">V2 =</span> <span class="kw">c</span>(<span class="st">&quot;C&quot;</span>,<span class="st">&quot;D&quot;</span>))) <span class="co"># 赋值语句结束后将该表达式的结果打印出来</span>
<span class="co">#&gt;   V1 V2</span>
<span class="co">#&gt; 1  3  C</span>
<span class="co">#&gt; 2  3  D</span>
<span class="kw">rbind</span>(df_1, df_2)
<span class="co">#&gt;   V1 V2</span>
<span class="co">#&gt; 1  1  A</span>
<span class="co">#&gt; 2  2  B</span>
<span class="co">#&gt; 3  3  C</span>
<span class="co">#&gt; 4  3  D</span>
df_3 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">V3 =</span> <span class="kw">c</span>(<span class="dv">95</span>, <span class="dv">88</span>), <span class="dt">V4 =</span> <span class="kw">c</span>(<span class="st">&quot;Actor&quot;</span>, <span class="st">&quot;Farmer&quot;</span>))
<span class="kw">print</span>(df_3) <span class="co"># 这才是比较合适的书写规范，一行语句执行一个命令；以上两种写法均可，但不推荐</span>
<span class="co">#&gt;   V3     V4</span>
<span class="co">#&gt; 1 95  Actor</span>
<span class="co">#&gt; 2 88 Farmer</span>
<span class="kw">cbind</span>(df_1, df_3)
<span class="co">#&gt;   V1 V2 V3     V4</span>
<span class="co">#&gt; 1  1  A 95  Actor</span>
<span class="co">#&gt; 2  2  B 88 Farmer</span></code></pre></div>
</div>
</div>
<div id="section-1.4.3" class="section level3">
<h3><span class="header-section-number">1.4.3</span> 数据结构与数据汇总</h3>
<p><code>str()</code>可以快速显示一个对象的结构。</p>
<p>对数据框来说， <code>str()</code>返回多个信息，包含：类名称；观测个数和变量个数；每个变量也就是向量的名称，及其类型，和前10个值；如果每个变量是因子向量，则返回其水平，及水平映射的整数值。</p>
<p><code>str()</code>能显示整个数据框的数据结构，非常实用。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(employee)
<span class="co">#&gt; &#39;data.frame&#39;:    15 obs. of  7 variables:</span>
<span class="co">#&gt;  $ name    : Factor w/ 15 levels &quot;沈约度&quot;,&quot;陈淮阳&quot;,..: 9 13 8 14 10 3 6 12 15 4 ...</span>
<span class="co">#&gt;  $ height  : num  1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 ...</span>
<span class="co">#&gt;  $ weight  : num  73 70 68 60 55 52 80 75 78 54 ...</span>
<span class="co">#&gt;  $ islocal : logi  TRUE TRUE FALSE TRUE FALSE FALSE ...</span>
<span class="co">#&gt;  $ gender  : Factor w/ 2 levels &quot;男&quot;,&quot;女&quot;: 1 1 1 1 2 2 1 1 1 2 ...</span>
<span class="co">#&gt;  $ grade   : Ord.factor w/ 4 levels &quot;差&quot;&lt;&quot;中&quot;&lt;&quot;良&quot;&lt;..: 2 3 3 2 4 3 2 4 2 3 ...</span>
<span class="co">#&gt;  $ birthday: Date, format: &quot;1984-02-28&quot; &quot;1988-09-26&quot; ...</span></code></pre></div>
<p><code>summary()</code>函数，可以快速显示一个对象的汇总结果。</p>
<p>对数据框来说，返回每个变量的汇总结果：</p>
<ul>
<li>对因子向量，返回每个因子的水平及计数结果（个数）；只显示前6个，剩下的显示为<code>(Other)</code></li>
<li>对数值向量，返回5分位数及平均值，分别是</li>
<li>Min. :最小值</li>
<li>1st Qu.:四分之一分位数</li>
<li>Median :中位数</li>
<li>Mean :算术平均值</li>
<li>3rd Qu.:四分之三分位数</li>
<li>Max. :最大值</li>
<li>对逻辑向量，返回其模式(mode), TRUE 和 FALSE 的个数，缺失值的个数</li>
<li>对字符向量，返回每个唯一字符的个数，只显示前6个，剩下的显示为<code>(Other)</code></li>
</ul>
<p>查看返回数据的结果汇总，就能对数据的概括有个大致的了解。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(employee)
<span class="co">#&gt;       name       height         weight      islocal        gender  grade </span>
<span class="co">#&gt;  沈约度 :1   Min.   :1.62   Min.   :52.0   Mode :logical   男:10   差:0  </span>
<span class="co">#&gt;  陈淮阳 :1   1st Qu.:1.69   1st Qu.:55.5   FALSE:7         女: 5   中:6  </span>
<span class="co">#&gt;  陈梦妍 :1   Median :1.72   Median :62.0   TRUE :8                 良:6  </span>
<span class="co">#&gt;  蒋欣   :1   Mean   :1.71   Mean   :65.3   NA&#39;s :0                 优:3  </span>
<span class="co">#&gt;  况天佑 :1   3rd Qu.:1.74   3rd Qu.:74.0                                 </span>
<span class="co">#&gt;  李元礼 :1   Max.   :1.81   Max.   :82.0                                 </span>
<span class="co">#&gt;  (Other):9                                                               </span>
<span class="co">#&gt;     birthday         </span>
<span class="co">#&gt;  Min.   :1984-02-28  </span>
<span class="co">#&gt;  1st Qu.:1988-06-05  </span>
<span class="co">#&gt;  Median :1990-01-25  </span>
<span class="co">#&gt;  Mean   :1989-09-27  </span>
<span class="co">#&gt;  3rd Qu.:1991-08-13  </span>
<span class="co">#&gt;  Max.   :1993-04-01  </span>
<span class="co">#&gt; </span></code></pre></div>
</div>
<div id="section-1.4.4" class="section level3">
<h3><span class="header-section-number">1.4.4</span> 访问数据框变量</h3>
<p>一个数据框可能包含多个变量（向量），有时需要单独提取某个变量，使用<code>$</code>特殊的符号来访问，由<code>数据框$变量名</code>构成。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">employee$name <span class="co"># 访问 employee 数据框中名为 name 的变量；结果就是一个向量</span>
<span class="co">#&gt;  [1] 宋子启 张伯仲 孟轲舆 张伟   王雪梅 陈梦妍 李元礼 杨伯侨 赵蜚廉 蒋欣  </span>
<span class="co">#&gt; [11] 沈约度 陈淮阳 况天佑 王珍珍 马小玲</span>
<span class="co">#&gt; 15 Levels: 沈约度 陈淮阳 陈梦妍 蒋欣 况天佑 李元礼 马小玲 ... 赵蜚廉</span>
employee$height 
<span class="co">#&gt;  [1] 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70</span>
<span class="co">#&gt; [15] 1.72</span>
employee$weight
<span class="co">#&gt;  [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82</span>
employee$islocal
<span class="co">#&gt;  [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE</span>
<span class="co">#&gt; [12]  TRUE FALSE  TRUE  TRUE</span>
employee$gender
<span class="co">#&gt;  [1] 男 男 男 男 女 女 男 男 男 女 男 男 男 女 女</span>
<span class="co">#&gt; Levels: 男 女</span></code></pre></div>
<p>增加一个变量，只需要将一个等长的向量赋值给<code>数据框$新变量名</code>即可</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">employee$bmi &lt;-<span class="st"> </span>employee$weight/(employee$height^<span class="dv">2</span>)
<span class="kw">str</span>(employee)
<span class="co">#&gt; &#39;data.frame&#39;:    15 obs. of  8 variables:</span>
<span class="co">#&gt;  $ name    : Factor w/ 15 levels &quot;沈约度&quot;,&quot;陈淮阳&quot;,..: 9 13 8 14 10 3 6 12 15 4 ...</span>
<span class="co">#&gt;  $ height  : num  1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 ...</span>
<span class="co">#&gt;  $ weight  : num  73 70 68 60 55 52 80 75 78 54 ...</span>
<span class="co">#&gt;  $ islocal : logi  TRUE TRUE FALSE TRUE FALSE FALSE ...</span>
<span class="co">#&gt;  $ gender  : Factor w/ 2 levels &quot;男&quot;,&quot;女&quot;: 1 1 1 1 2 2 1 1 1 2 ...</span>
<span class="co">#&gt;  $ grade   : Ord.factor w/ 4 levels &quot;差&quot;&lt;&quot;中&quot;&lt;&quot;良&quot;&lt;..: 2 3 3 2 4 3 2 4 2 3 ...</span>
<span class="co">#&gt;  $ birthday: Date, format: &quot;1984-02-28&quot; &quot;1988-09-26&quot; ...</span>
<span class="co">#&gt;  $ bmi     : num  24.4 24.8 23 22 20 ...</span></code></pre></div>
</div>
<div id="section-1.4.5" class="section level3">
<h3><span class="header-section-number">1.4.5</span> 数据框的长度与类型</h3>
<p>数据框可以由多个不同的向量组成，故而其 <code>长度length()</code> 和 <code>模式mode()</code> 属性没太大的意义。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(employee)
<span class="co">#&gt; [1] 8</span></code></pre></div>
<p>增加一个变量，只需要将一个等长的向量赋值给<code>数据框$新变量名</code>即可</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">employee$bmi &lt;-<span class="st"> </span>employee$weight/(employee$height^<span class="dv">2</span>) 
<span class="kw">str</span>(employee)
<span class="co">#&gt; &#39;data.frame&#39;:    15 obs. of  8 variables:</span>
<span class="co">#&gt;  $ name    : Factor w/ 15 levels &quot;沈约度&quot;,&quot;陈淮阳&quot;,..: 9 13 8 14 10 3 6 12 15 4 ...</span>
<span class="co">#&gt;  $ height  : num  1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 ...</span>
<span class="co">#&gt;  $ weight  : num  73 70 68 60 55 52 80 75 78 54 ...</span>
<span class="co">#&gt;  $ islocal : logi  TRUE TRUE FALSE TRUE FALSE FALSE ...</span>
<span class="co">#&gt;  $ gender  : Factor w/ 2 levels &quot;男&quot;,&quot;女&quot;: 1 1 1 1 2 2 1 1 1 2 ...</span>
<span class="co">#&gt;  $ grade   : Ord.factor w/ 4 levels &quot;差&quot;&lt;&quot;中&quot;&lt;&quot;良&quot;&lt;..: 2 3 3 2 4 3 2 4 2 3 ...</span>
<span class="co">#&gt;  $ birthday: Date, format: &quot;1984-02-28&quot; &quot;1988-09-26&quot; ...</span>
<span class="co">#&gt;  $ bmi     : num  24.4 24.8 23 22 20 ...</span></code></pre></div>
</div>
<div id="section-1.4.6" class="section level3">
<h3><span class="header-section-number">1.4.6</span> 数据框索引与筛选</h3>
<p>类似与矩阵，数据框也用类似的方法索引和筛选子集，包括整数位置、名称属性、逻辑向量索引，但最常用的是<code>subset()</code>和<code>head()</code>函数。</p>
<p><code>subset()</code>常用是因为可以复合多个逻辑表达式条件。</p>
<p><code>head()</code>常用是因为通常数据表的行数很大，直接打印所有的行会使控制台刷屏，多数时候只需看数据库的前几行即可，结合 str() 查看数据结构、summary() 查看数据汇总情况。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 前3名员工的身高和体重</span>
employee[<span class="dv">1</span>:<span class="dv">3</span>, <span class="kw">c</span>(<span class="st">&quot;height&quot;</span>, <span class="st">&quot;weight&quot;</span>)] 
<span class="co">#&gt;        height weight</span>
<span class="co">#&gt; 宋子启   1.73     73</span>
<span class="co">#&gt; 张伯仲   1.68     70</span>
<span class="co">#&gt; 孟轲舆   1.72     68</span>

<span class="co"># employee$islocal 是逻辑向量，第2个维度就是变量，不限制条件就是选中所有变量</span>
employee[employee$islocal,] 
<span class="co">#&gt;          name height weight islocal gender grade   birthday  bmi</span>
<span class="co">#&gt; 宋子启 宋子启   1.73     73    TRUE     男    中 1984-02-28 24.4</span>
<span class="co">#&gt; 张伯仲 张伯仲   1.68     70    TRUE     男    良 1988-09-26 24.8</span>
<span class="co">#&gt; 张伟     张伟   1.65     60    TRUE     男    中 1990-01-25 22.0</span>
<span class="co">#&gt; 杨伯侨 杨伯侨   1.74     75    TRUE     男    优 1991-07-01 24.8</span>
<span class="co">#&gt; 沈约度 沈约度   1.72     61    TRUE     男    良 1993-04-01 20.6</span>
<span class="co">#&gt; 陈淮阳 陈淮阳   1.69     62    TRUE     男    中 1991-03-05 21.7</span>
<span class="co">#&gt; 王珍珍 王珍珍   1.70     53    TRUE     女    中 1992-01-31 18.3</span>
<span class="co">#&gt; 马小玲 马小玲   1.72     82    TRUE     女    优 1988-02-14 27.7</span>

<span class="co"># select 参数不选择就是所有变量</span>
<span class="kw">subset</span>(employee, employee$height &gt;<span class="st"> </span><span class="fl">1.7</span>) 
<span class="co">#&gt;          name height weight islocal gender grade   birthday  bmi</span>
<span class="co">#&gt; 宋子启 宋子启   1.73     73    TRUE     男    中 1984-02-28 24.4</span>
<span class="co">#&gt; 孟轲舆 孟轲舆   1.72     68   FALSE     男    良 1989-07-28 23.0</span>
<span class="co">#&gt; 李元礼 李元礼   1.81     80   FALSE     男    中 1992-06-14 24.4</span>
<span class="co">#&gt; 杨伯侨 杨伯侨   1.74     75    TRUE     男    优 1991-07-01 24.8</span>
<span class="co">#&gt; 赵蜚廉 赵蜚廉   1.78     78   FALSE     男    中 1990-08-08 24.6</span>
<span class="co">#&gt; 蒋欣     蒋欣   1.71     54   FALSE     女    良 1985-05-10 18.5</span>
<span class="co">#&gt; 沈约度 沈约度   1.72     61    TRUE     男    良 1993-04-01 20.6</span>
<span class="co">#&gt; 况天佑 况天佑   1.74     56   FALSE     男    良 1991-09-25 18.5</span>
<span class="co">#&gt; 马小玲 马小玲   1.72     82    TRUE     女    优 1988-02-14 27.7</span>

<span class="co"># subset 逻辑表达式可以由多个逻辑表达式的逻辑运算结果构成，所以可以有多个条件的筛选</span>
<span class="kw">subset</span>(employee, employee$height &gt;<span class="st"> </span><span class="fl">1.7</span> &amp;<span class="st"> </span>employee$weight &gt;<span class="st"> </span><span class="dv">65</span>, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;name&quot;</span>, <span class="st">&quot;gender&quot;</span>, <span class="st">&quot;bmi&quot;</span>)) 
<span class="co">#&gt;          name gender  bmi</span>
<span class="co">#&gt; 宋子启 宋子启     男 24.4</span>
<span class="co">#&gt; 孟轲舆 孟轲舆     男 23.0</span>
<span class="co">#&gt; 李元礼 李元礼     男 24.4</span>
<span class="co">#&gt; 杨伯侨 杨伯侨     男 24.8</span>
<span class="co">#&gt; 赵蜚廉 赵蜚廉     男 24.6</span>
<span class="co">#&gt; 马小玲 马小玲     女 27.7</span>

<span class="kw">head</span>(employee) <span class="co"># 显示前6个元素</span>
<span class="co">#&gt;          name height weight islocal gender grade   birthday  bmi</span>
<span class="co">#&gt; 宋子启 宋子启   1.73     73    TRUE     男    中 1984-02-28 24.4</span>
<span class="co">#&gt; 张伯仲 张伯仲   1.68     70    TRUE     男    良 1988-09-26 24.8</span>
<span class="co">#&gt; 孟轲舆 孟轲舆   1.72     68   FALSE     男    良 1989-07-28 23.0</span>
<span class="co">#&gt; 张伟     张伟   1.65     60    TRUE     男    中 1990-01-25 22.0</span>
<span class="co">#&gt; 王雪梅 王雪梅   1.66     55   FALSE     女    优 1987-04-30 20.0</span>
<span class="co">#&gt; 陈梦妍 陈梦妍   1.62     52   FALSE     女    良 1989-12-20 19.8</span></code></pre></div>

</div>
</div>
<div id="-list" class="section level2">
<h2><span class="header-section-number">1.5</span> 列表 list</h2>
<p>列表是R语言基本数据结构中最为复杂的一种，主要作为两种用途：</p>
<ul>
<li><p>第一：作为非结构化存储的数据类型，类似于Jason，并且可以同时包含不同的类型的数据，比如字符和数值；</p></li>
<li><p>第二：作为对象的集合，可以包含多个不同数据对象，比如向量、矩阵、数据库，甚至还可以包含图像、表达式、函数等对象。</p></li>
</ul>
<div id="section-1.5.1" class="section level3">
<h3><span class="header-section-number">1.5.1</span> 多种类型的复合数据</h3>
<p>比如在员工信息表中，我们将每个员工的信息存储在一个对象中，由于该信息包含了多种不同的模式，故而不能用向量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e_list &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">name =</span> <span class="st">&quot;宋子启&quot;</span>, <span class="dt">height =</span> <span class="fl">1.73</span>, <span class="dt">weight =</span> <span class="dv">73</span>, <span class="dt">islocal =</span> <span class="ot">TRUE</span>)
<span class="kw">print</span>(e_list)
<span class="co">#&gt; $name</span>
<span class="co">#&gt; [1] &quot;宋子启&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $height</span>
<span class="co">#&gt; [1] 1.73</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $weight</span>
<span class="co">#&gt; [1] 73</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $islocal</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>在这个列表 <code>e_list</code> 中，<code>list()</code>函数定义了一个列表，有多个对象构成（又称为组件），每个对象代表中包含了一个对应的信息。</p>
<p>虽然看起来和向量的定义有些类似，但最大的区别是列表中各元素的模式是可以不同的。</p>
<p>将这个 <code>e_list</code> 的信息扩充，每个对象可以包含多个信息，且每个对象中的元素个数相同的话，则可以转为数据框。</p>
<p>实际上，数据框是列表的特殊形式。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e_list &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">name =</span> <span class="kw">c</span>(<span class="st">&quot;宋子启&quot;</span>,<span class="st">&quot;张伯仲&quot;</span>), <span class="dt">height =</span> <span class="kw">c</span>(<span class="fl">1.73</span>, <span class="fl">1.68</span>), <span class="dt">weight =</span> <span class="kw">c</span>(<span class="dv">73</span>, <span class="dv">70</span>), <span class="dt">islocal =</span> <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>))
<span class="kw">print</span>(e_list)
<span class="co">#&gt; $name</span>
<span class="co">#&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $height</span>
<span class="co">#&gt; [1] 1.73 1.68</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $weight</span>
<span class="co">#&gt; [1] 73 70</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $islocal</span>
<span class="co">#&gt; [1] TRUE TRUE</span>

<span class="co"># 直接转为数据框</span>
<span class="kw">as.data.frame</span>(e_list)
<span class="co">#&gt;     name height weight islocal</span>
<span class="co">#&gt; 1 宋子启   1.73     73    TRUE</span>
<span class="co">#&gt; 2 张伯仲   1.68     70    TRUE</span></code></pre></div>
</div>
<div id="section-1.5.2" class="section level3">
<h3><span class="header-section-number">1.5.2</span> 非结构化的数据存储方式</h3>
<p>列表还有一个特点是可以嵌套列表对象，则可使得非结构化的数据仓储变得可能。</p>
<p>在员工信息表中，可以存储技能特长这类数据。由于具体的技能数量是未确定的，且是多选项问题，可以用非结构化的数据格式来存储较为方便（实际上非结构化数据是可以转化为结构化数据的，但如果非结构关系较为负责，这种转化的过程和记录各结构化之间关系的问题反而可能更负责，还不如直接存储非结构化关系更为方便）。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e001 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">name =</span> <span class="st">&quot;宋子启&quot;</span>, <span class="dt">height =</span> <span class="fl">1.73</span>, <span class="dt">weight =</span> <span class="dv">73</span>, <span class="dt">islocal =</span> <span class="ot">TRUE</span>, <span class="dt">skills =</span> <span class="kw">c</span>(<span class="st">&quot;SQL&quot;</span>, <span class="st">&quot;R&quot;</span>))
e002 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">name =</span> <span class="st">&quot;张伯仲&quot;</span>, <span class="dt">height =</span> <span class="fl">1.68</span>, <span class="dt">weight =</span> <span class="dv">70</span>, <span class="dt">islocal =</span> <span class="ot">TRUE</span>, <span class="dt">skills =</span> <span class="kw">c</span>(<span class="st">&quot;SQL&quot;</span>, <span class="st">&quot;R&quot;</span>, <span class="st">&quot;Python&quot;</span>))

<span class="co"># list 中包含 list</span>
e_list &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">e001 =</span> e001, <span class="dt">e002 =</span> e002)

<span class="co"># 查看 list 的结构使用 str() 更为方便</span>
<span class="kw">str</span>(e_list)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ e001:List of 5</span>
<span class="co">#&gt;   ..$ name   : chr &quot;宋子启&quot;</span>
<span class="co">#&gt;   ..$ height : num 1.73</span>
<span class="co">#&gt;   ..$ weight : num 73</span>
<span class="co">#&gt;   ..$ islocal: logi TRUE</span>
<span class="co">#&gt;   ..$ skills : chr [1:2] &quot;SQL&quot; &quot;R&quot;</span>
<span class="co">#&gt;  $ e002:List of 5</span>
<span class="co">#&gt;   ..$ name   : chr &quot;张伯仲&quot;</span>
<span class="co">#&gt;   ..$ height : num 1.68</span>
<span class="co">#&gt;   ..$ weight : num 70</span>
<span class="co">#&gt;   ..$ islocal: logi TRUE</span>
<span class="co">#&gt;   ..$ skills : chr [1:3] &quot;SQL&quot; &quot;R&quot; &quot;Python&quot;</span></code></pre></div>
</div>
<div id="section-1.5.3" class="section level3">
<h3><span class="header-section-number">1.5.3</span> 对象的集合</h3>
<p>列表作为对象的集合，最为典型的场景是线性回归模型的结果存储在列表中。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 以自变量为 height 因变量为 weight 的简单线性回归模型 lm(y ~ x)</span>
<span class="co"># 将模型的结果存储在 m_list 这个对象中</span>
m_list &lt;-<span class="st"> </span><span class="kw">lm</span>(weight ~<span class="st"> </span>height)

<span class="co"># 线性回归模型会返回非常多的信息，会存在不同对象中，故而使用 list 来存储相对合适</span>
<span class="kw">summary</span>(m_list)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = weight ~ height)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residuals:</span>
<span class="co">#&gt;     Min      1Q  Median      3Q     Max </span>
<span class="co">#&gt; -13.400  -4.190   0.506   4.310  15.484 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;             Estimate Std. Error t value Pr(&gt;|t|)   </span>
<span class="co">#&gt; (Intercept)   -181.5       76.7   -2.37   0.0341 * </span>
<span class="co">#&gt; height         144.2       44.8    3.22   0.0067 **</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residual standard error: 8.13 on 13 degrees of freedom</span>
<span class="co">#&gt; Multiple R-squared:  0.444,  Adjusted R-squared:  0.401 </span>
<span class="co">#&gt; F-statistic: 10.4 on 1 and 13 DF,  p-value: 0.0067</span></code></pre></div>
<p>在日常自定义函数中，如果函数返回的结果包含多种数据（多个对象），将其存储在一个列表中也是最为方便的。</p>
</div>
<div id="section-1.5.4" class="section level3">
<h3><span class="header-section-number">1.5.4</span> 列表子集筛选</h3>
<p>如果列表对象是有名称属性的，也就是各个组件是有标签的，则可以直接使用 <code>$</code> 对象的名字提取该子对象。</p>
<p>将列表作为对象的集合多数属于这种情况，每个子对象通常都有名字便于提取。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 查看对象的名称属性</span>
<span class="kw">names</span>(m_list)
<span class="co">#&gt;  [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;         </span>
<span class="co">#&gt;  [5] &quot;fitted.values&quot; &quot;assign&quot;        &quot;qr&quot;            &quot;df.residual&quot;  </span>
<span class="co">#&gt;  [9] &quot;xlevels&quot;       &quot;call&quot;          &quot;terms&quot;         &quot;model&quot;</span>

<span class="co"># 查看回归模型的残差</span>
m_list$residuals
<span class="co">#&gt;        1        2        3        4        5        6        7        8 </span>
<span class="co">#&gt;   5.0416   9.2515   1.4836   3.5774  -2.8645  -0.0966   0.5059   5.5997 </span>
<span class="co">#&gt;        9       10       11       12       13       14       15 </span>
<span class="co">#&gt;   2.8318 -11.0744  -5.5164  -0.1905 -13.4003 -10.6324  15.4836</span>


<span class="kw">names</span>(e_list)
<span class="co">#&gt; [1] &quot;e001&quot; &quot;e002&quot;</span>
e_list$e002
<span class="co">#&gt; $name</span>
<span class="co">#&gt; [1] &quot;张伯仲&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $height</span>
<span class="co">#&gt; [1] 1.68</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $weight</span>
<span class="co">#&gt; [1] 70</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $islocal</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $skills</span>
<span class="co">#&gt; [1] &quot;SQL&quot;    &quot;R&quot;      &quot;Python&quot;</span></code></pre></div>
<p>如果对象没有名称属性，可使用位置索引，与向量类使用<code>[]</code>类似，但子对象的提取需要使用<code>[[]]</code>。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_list[[<span class="dv">2</span>]] <span class="co"># 等价于 m_list$residuals 因为 residuals 是第2个子对象</span>
<span class="co">#&gt;        1        2        3        4        5        6        7        8 </span>
<span class="co">#&gt;   5.0416   9.2515   1.4836   3.5774  -2.8645  -0.0966   0.5059   5.5997 </span>
<span class="co">#&gt;        9       10       11       12       13       14       15 </span>
<span class="co">#&gt;   2.8318 -11.0744  -5.5164  -0.1905 -13.4003 -10.6324  15.4836</span></code></pre></div>
<p><code>[]</code>通常用来提取子集，返回的结果与与对象具有相同的类型，是一种子结构。该操作符可以用在列表上，但返回的是列表结构。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_list[<span class="dv">2</span>]
<span class="co">#&gt; $residuals</span>
<span class="co">#&gt;        1        2        3        4        5        6        7        8 </span>
<span class="co">#&gt;   5.0416   9.2515   1.4836   3.5774  -2.8645  -0.0966   0.5059   5.5997 </span>
<span class="co">#&gt;        9       10       11       12       13       14       15 </span>
<span class="co">#&gt;   2.8318 -11.0744  -5.5164  -0.1905 -13.4003 -10.6324  15.4836</span>

<span class="kw">str</span>(m_list[[<span class="dv">2</span>]]) <span class="co"># 返回第二个子对象，是一个向量</span>
<span class="co">#&gt;  Named num [1:15] 5.04 9.25 1.48 3.58 -2.86 ...</span>
<span class="co">#&gt;  - attr(*, &quot;names&quot;)= chr [1:15] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</span>
<span class="kw">str</span>(m_list[<span class="dv">2</span>]) <span class="co"># 返回原列表的第二个子列表，还是一个列表</span>
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ residuals: Named num [1:15] 5.04 9.25 1.48 3.58 -2.86 ...</span>
<span class="co">#&gt;   ..- attr(*, &quot;names&quot;)= chr [1:15] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</span></code></pre></div>
<p>在<code>[[]]</code>提取子对象后，如果是向量，还可以继续使用<code>[]</code>来提取子元素来定位结果的元素；如果是矩阵或数据框还可以用<code>[,]</code>定位子集，如果是列表，依然可以用 <code>[[]]</code> 来继续提取子集。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_list[[<span class="dv">2</span>]][<span class="dv">2</span>]  <span class="co"># 第二个子对象的第二个元素</span>
<span class="co">#&gt;    2 </span>
<span class="co">#&gt; 9.25</span>

<span class="kw">str</span>(m_list[[<span class="dv">2</span>]]) <span class="co"># 返回第二个子对象，是一个向量</span>
<span class="co">#&gt;  Named num [1:15] 5.04 9.25 1.48 3.58 -2.86 ...</span>
<span class="co">#&gt;  - attr(*, &quot;names&quot;)= chr [1:15] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</span>
<span class="kw">str</span>(m_list[<span class="dv">2</span>]) <span class="co"># 返回原列表的第二个子列表，还是一个列表</span>
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ residuals: Named num [1:15] 5.04 9.25 1.48 3.58 -2.86 ...</span>
<span class="co">#&gt;   ..- attr(*, &quot;names&quot;)= chr [1:15] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</span></code></pre></div>

</div>
</div>
<div id="-special-values" class="section level2">
<h2><span class="header-section-number">1.6</span> 特殊值 Special Values</h2>
<p>```</p>
<p>为确保所有数据都能被正确识别、计算或统计等，R语言定义了一些特殊值数据：</p>
<ul>
<li>NULL：空值，什么都没有</li>
<li>NA：Not Available 的缩写，更多是时候被称作 Missing value，也就是缺失值；有数据值，但具体是什么却不知道</li>
<li>NaN：Not a Number 的缩写，表示非数值</li>
<li>Inf：positive infinity，正无穷大</li>
<li>-Inf：negative infinity，负无穷大</li>
</ul>
<p>前两者可以包含在任意类型的向量中，后三者是数值型向量。</p>
<div id="-null" class="section level3">
<h3><span class="header-section-number">1.6.1</span> 空值 NULL</h3>
<p>NULL 代表一个空对象，通常作为表达式的返回结果（也就是什么都不返回)，或者作为函数中未定义的参数值。</p>
<p>as.null(x) 是转化函数，is.null(x) 是判断函数。</p>
<p>NULL 作为向量中的值时，表示什么都没有，在打印过程中的不不会被显示，都不占用一个元素位置。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 只打印值 1</span>
<span class="kw">print</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NULL</span>))
<span class="co">#&gt; [1] 1</span>

<span class="co"># 合并后长度只有 1</span>
<span class="kw">length</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NULL</span>))
<span class="co">#&gt; [1] 1</span></code></pre></div>
</div>
<div id="-na" class="section level3">
<h3><span class="header-section-number">1.6.2</span> 缺失值 NA</h3>
<p>缺失值是R语言中非常重要的概念，且有专门的缺失值处理方法，这里只介绍几本的概念。</p>
<p>缺失值 NA 与 SQL 中的 NULL 概念相似，表示应该有值，但目前缺失。</p>
<p>NA 作为向量中的值，可以包含在任意类型中。不同与 NULL，缺失值是占位一个向量元素的。</p>
<p>NA 作为一个独立的向量时，其类型为逻辑型。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># NA 作为一个值会被打印出来</span>
<span class="kw">print</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>))
<span class="co">#&gt; [1]  1 NA</span>

<span class="co"># NA 作为一个向量的元素是包含在长度中的</span>
<span class="kw">length</span>(<span class="kw">c</span>(<span class="st">&quot;test&quot;</span>, <span class="ot">NA</span>))
<span class="co">#&gt; [1] 2</span>

<span class="co"># NA 的模式（类型）为逻辑型</span>
<span class="kw">mode</span>(<span class="ot">NA</span>)
<span class="co">#&gt; [1] &quot;logical&quot;</span></code></pre></div>
<p>将向量中的某些值改变为NA，等价于将 NA 赋值给指定的元素。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 将向量中的某些值改变为NA</span>
test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">9</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span>
<span class="kw">print</span>(test_weight)
<span class="co">#&gt;  [1] 73 70 NA 60 55 52 80 75 NA 54 61 62 56 53 82</span></code></pre></div>
<p>在提取向量子集时，如果索引下标超过向量长度，则返回的结果为 NA。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">31</span>,<span class="dv">99</span>)]
<span class="co">#&gt; [1] NA NA</span>
<span class="kw">print</span>(test_weight)
<span class="co">#&gt;  [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82</span></code></pre></div>
<p>在给向量赋值时，如果赋值的元素超过原本向量的长度，则中间未定义赋值的元素，其值为NA。</p>
<p>用这种向量赋值方式，可以预先定义数据结构，或者增加向量长度。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">30</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span>
<span class="kw">print</span>(test_weight)
<span class="co">#&gt;  [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 NA NA NA NA NA NA NA NA</span>
<span class="co">#&gt; [24] NA NA NA NA NA NA NA</span>

test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">30</span>)] &lt;-<span class="st"> </span><span class="dv">66</span>
<span class="kw">print</span>(test_weight)
<span class="co">#&gt;  [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 NA NA NA NA NA NA NA NA</span>
<span class="co">#&gt; [24] NA NA NA NA NA NA 66</span></code></pre></div>
<p>is.na(x) 函数用来判断向量中的每个元素是否为 NA，返回长度相同的逻辑向量。</p>
<p>结合元素子集筛选函数可以提取非缺失值的部分，或者将缺失值替换为某个值或者表达式结果。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 提取非缺失值子集</span>
test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">30</span>)] &lt;-<span class="st"> </span><span class="dv">66</span>
test_weight[!<span class="kw">is.na</span>(test_weight)]
<span class="co">#&gt;  [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 66</span>

<span class="co"># 将缺失值替换为非缺失值的均值</span>
test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">30</span>)] &lt;-<span class="st"> </span><span class="dv">66</span>
test_weight[!<span class="kw">is.na</span>(test_weight)]
<span class="co">#&gt;  [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 66</span>
test_weight[<span class="kw">is.na</span>(test_weight)] &lt;-<span class="st"> </span><span class="kw">mean</span>(test_weight, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="kw">print</span>(test_weight)
<span class="co">#&gt;  [1] 73.0 70.0 68.0 60.0 55.0 52.0 80.0 75.0 78.0 54.0 61.0 62.0 56.0 53.0</span>
<span class="co">#&gt; [15] 82.0 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3</span>
<span class="co">#&gt; [29] 65.3 66.0</span></code></pre></div>
<p>anyNA(x) 函数用来判断对象中是否包含 NA 元素，返回一个逻辑值。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">30</span>)] &lt;-<span class="st"> </span><span class="dv">66</span>
<span class="co"># 返回是否包含缺失值</span>
<span class="kw">anyNA</span>(test_weight)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>关于缺失值的处理函数中，经常会遇一个名为 na.rm 的参数，用来选择是否排除缺失值。</p>
<p>比如在求均值的函数 mean() 中，参数 na.rm 默认为 FALSE：如果数值型向量包含 NA，则其均值返回 NA；如果 na.rm 设置为 TRUE 则会在求均值中忽略 NA，得到数值结果的平均值。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 函数中是否移除缺失值</span>
test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">30</span>)] &lt;-<span class="st"> </span><span class="dv">66</span>
<span class="kw">mean</span>(test_weight) <span class="co"># 默认 na.rm = FALSE</span>
<span class="co">#&gt; [1] NA</span>
<span class="kw">mean</span>(test_weight, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 65.3</span></code></pre></div>
<p>还有一个常用的缺失值处理函数 <code>na.omit()</code>，用来移除包含缺失值所在的行记录，多用在 data.frame 中。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 函数中是否移除缺失值</span>
test_employee &lt;-<span class="st"> </span>employee
test_employee$height[<span class="dv">6</span>] &lt;-<span class="st"> </span><span class="ot">NA</span>
test_employee$weight[<span class="dv">8</span>] &lt;-<span class="st"> </span><span class="ot">NA</span>

<span class="co"># test_employee 中第6和8行包含有NA元素，先这两行都被移除</span>
<span class="kw">na.omit</span>(test_employee) <span class="co"># 结果中不含任何包含 NA 元素的行</span>
<span class="co">#&gt;          name height weight islocal gender grade   birthday</span>
<span class="co">#&gt; 宋子启 宋子启   1.73     73    TRUE     男    中 1984-02-28</span>
<span class="co">#&gt; 张伯仲 张伯仲   1.68     70    TRUE     男    良 1988-09-26</span>
<span class="co">#&gt; 孟轲舆 孟轲舆   1.72     68   FALSE     男    良 1989-07-28</span>
<span class="co">#&gt; 张伟     张伟   1.65     60    TRUE     男    中 1990-01-25</span>
<span class="co">#&gt; 王雪梅 王雪梅   1.66     55   FALSE     女    优 1987-04-30</span>
<span class="co">#&gt; 李元礼 李元礼   1.81     80   FALSE     男    中 1992-06-14</span>
<span class="co">#&gt; 赵蜚廉 赵蜚廉   1.78     78   FALSE     男    中 1990-08-08</span>
<span class="co">#&gt; 蒋欣     蒋欣   1.71     54   FALSE     女    良 1985-05-10</span>
<span class="co">#&gt; 沈约度 沈约度   1.72     61    TRUE     男    良 1993-04-01</span>
<span class="co">#&gt; 陈淮阳 陈淮阳   1.69     62    TRUE     男    中 1991-03-05</span>
<span class="co">#&gt; 况天佑 况天佑   1.74     56   FALSE     男    良 1991-09-25</span>
<span class="co">#&gt; 王珍珍 王珍珍   1.70     53    TRUE     女    中 1992-01-31</span>
<span class="co">#&gt; 马小玲 马小玲   1.72     82    TRUE     女    优 1988-02-14</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 函数中是否移除缺失值</span>
test_weight &lt;-<span class="st"> </span>weight
test_weight[<span class="kw">c</span>(<span class="dv">30</span>)] &lt;-<span class="st"> </span><span class="dv">66</span>
<span class="kw">mean</span>(test_weight) <span class="co"># 默认 na.rm = FALSE</span>
<span class="co">#&gt; [1] NA</span>
<span class="kw">mean</span>(test_weight, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 65.3</span></code></pre></div>
</div>
<div id="-nan" class="section level3">
<h3><span class="header-section-number">1.6.3</span> 非数值 NaN</h3>
<p>在数值计算过程中，可能会产生无意义的值，为了使得计算不中断，在 R 中预先定义了 NaN 的特殊值，作为无效数值的表示。</p>
<p>比如 0/0 是没有意义的；还有初等函数中自变量的值不在定义域范围内则函数结果也是无意义的，比如对数函数中自变量小于0也是没有意义的。</p>
<p>当结果产生 NaN 时，控制台会打印一条警告信息“产生了NaNs”（不会中断运行过程，实际上是运行成功后才会显示该消息）。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 典型会产生 NaN 的情况</span>
<span class="dv">0</span>/<span class="dv">0</span> <span class="co"># 分子和分母均为 0 的结果无意义</span>
<span class="co">#&gt; [1] NaN</span>
<span class="kw">log</span>(-<span class="dv">1</span>) <span class="co"># 对数函数在定义域 &gt; 0 的情况下才有意义</span>
<span class="co">#&gt; Warning in log(-1): 产生了NaNs</span>
<span class="co">#&gt; [1] NaN</span></code></pre></div>
<p>is.nan(x) 是判断非数值的函数，返回对象中元素是否为 NaN 的等长逻辑向量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.nan</span>(<span class="kw">c</span>(<span class="dv">0</span>/<span class="dv">0</span>, <span class="kw">log</span>(-<span class="dv">1</span>)))
<span class="co">#&gt; Warning in log(-1): 产生了NaNs</span>
<span class="co">#&gt; [1] TRUE TRUE</span></code></pre></div>
<p>NaN 是一种特殊的 NA 值，可以用 is.na() 来验证。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.na</span>(<span class="kw">c</span>(<span class="dv">0</span>/<span class="dv">0</span>, <span class="kw">log</span>(-<span class="dv">1</span>)))
<span class="co">#&gt; Warning in log(-1): 产生了NaNs</span>
<span class="co">#&gt; [1] TRUE TRUE</span></code></pre></div>
</div>
<div id="-inf--inf" class="section level3">
<h3><span class="header-section-number">1.6.4</span> 无穷大/无穷小 Inf /-Inf</h3>
<p>数学中的无穷大和无穷小是一种特殊的数值，不同与 NaN，他们是有意义的数值，故而有特殊的符号表示， <code>Inf</code> 为正无穷大，<code>-Inf</code> 为负无穷小。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 典型的无穷大和无穷小数值</span>
<span class="dv">1</span>/<span class="dv">0</span>  <span class="co"># 分子为正，分母为 0 数值为无穷大</span>
<span class="co">#&gt; [1] Inf</span>
-<span class="dv">1</span>/<span class="dv">0</span>  <span class="co">#分子为负，分母为 0 数值为无穷小</span>
<span class="co">#&gt; [1] -Inf</span></code></pre></div>
<p>Inf 是 infinite 的缩写，表示无穷尽的，无限大的。判读一个数值是否为无穷大或者无穷小，使用 <code>is.infinite()</code> 函数。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 1/0 和 -1/0 是 Inf  和 -Inf</span>
<span class="co"># 0/0 是 NaN</span>
<span class="co">#  1, -1 是正常数值</span>
<span class="kw">is.infinite</span>(<span class="kw">c</span>(<span class="dv">1</span>/<span class="dv">0</span>, -<span class="dv">1</span>/<span class="dv">0</span>, <span class="dv">0</span>/<span class="dv">0</span>, <span class="dv">1</span>, -<span class="dv">1</span>))
<span class="co">#&gt; [1]  TRUE  TRUE FALSE FALSE FALSE</span></code></pre></div>
<p>相对地，判断数值有限大小的函数，就是 <code>is.finite()</code>。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 1/0 和 -1/0 是 Inf  和 -Inf</span>
<span class="co"># 0/0 是 NaN</span>
<span class="co">#  1, -1 是正常数值</span>
<span class="kw">is.finite</span>(<span class="kw">c</span>(<span class="dv">1</span>/<span class="dv">0</span>, -<span class="dv">1</span>/<span class="dv">0</span>, <span class="dv">0</span>/<span class="dv">0</span>, <span class="dv">1</span>, -<span class="dv">1</span>)) 
<span class="co">#&gt; [1] FALSE FALSE FALSE  TRUE  TRUE</span></code></pre></div>
<p>Inf 和 -Inf，既不是 NaN，也不是 NA。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 1/0 和 -1/0 是 Inf  和 -Inf</span>
<span class="co"># 0/0 是 NaN</span>
<span class="co">#  1, -1 是正常数值</span>
<span class="kw">is.nan</span>(<span class="kw">c</span>(<span class="dv">1</span>/<span class="dv">0</span>, -<span class="dv">1</span>/<span class="dv">0</span>, <span class="dv">0</span>/<span class="dv">0</span>, <span class="dv">1</span>, -<span class="dv">1</span>)) 
<span class="co">#&gt; [1] FALSE FALSE  TRUE FALSE FALSE</span>
<span class="kw">is.na</span>(<span class="kw">c</span>(<span class="dv">1</span>/<span class="dv">0</span>, -<span class="dv">1</span>/<span class="dv">0</span>, <span class="dv">0</span>/<span class="dv">0</span>, <span class="dv">1</span>, -<span class="dv">1</span>)) 
<span class="co">#&gt; [1] FALSE FALSE  TRUE FALSE FALSE</span></code></pre></div>
<p>既然 Inf 和 -Inf 分别是正无穷大和负无穷小，则说明两者的大小在比较的时候是不同的。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 无穷大的结果 大于 无穷小的结果</span>
(<span class="dv">1</span>/<span class="dv">0</span>) &gt;<span class="st"> </span>(-<span class="dv">1</span>/<span class="dv">0</span>) 
<span class="co">#&gt; [1] TRUE</span>

<span class="co"># 无穷大 大于 无穷小</span>
<span class="ot">Inf</span> &gt;<span class="st"> </span>-<span class="ot">Inf</span>
<span class="co">#&gt; [1] TRUE</span>

<span class="co"># 无穷大 大于 所有有限数值</span>
<span class="ot">Inf</span> &gt;<span class="st"> </span><span class="dv">0</span>
<span class="co">#&gt; [1] TRUE</span>

<span class="co"># 一个无穷大并不会大于另一个无穷大</span>
(<span class="dv">2</span>/<span class="dv">0</span>) &gt;<span class="st"> </span>(<span class="dv">1</span>/<span class="dv">0</span>) 
<span class="co">#&gt; [1] FALSE</span>

<span class="co"># 两个无穷大的大小比较结果是相等</span>
(<span class="dv">2</span>/<span class="dv">0</span>) ==<span class="st"> </span>(<span class="dv">1</span>/<span class="dv">0</span>) 
<span class="co">#&gt; [1] TRUE</span>

<span class="co"># 无穷大与非数值比较结果为 NA</span>
<span class="co"># NaN 也是 NA</span>
<span class="co"># 任何值与 NA 比大小的结果都是 NA</span>
<span class="ot">Inf</span> &gt;<span class="st"> </span><span class="ot">NaN</span>
<span class="co">#&gt; [1] NA</span>

<span class="co"># 无穷大与 NA 比大小的结果都是 NA</span>
<span class="ot">Inf</span> &gt;<span class="st"> </span><span class="ot">NA</span>
<span class="co">#&gt; [1] NA</span></code></pre></div>
<p><code>is.infinite()</code> 函数只是判断一个数值是否为无穷尽的，至于该数值是无穷大还是无穷大，则并未给出对应的函数。</p>
<p>可以结合 Inf 和 -Inf 的大小比较来辅助判断。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 自定义一个函数</span>
<span class="co"># 先判断对象 x 是否为无穷尽的数值</span>
<span class="co">#    如果是则将 x 值与 0 做比较，</span>
<span class="co">#        x &gt; 0 为 TRUE，则 x 为无穷大</span>
<span class="co">#        x &gt; 0 为 FALSE，则 x 为无穷小</span>
<span class="co"># 如果 x 不是无穷尽的数值，则返回结果为 NA</span>
is.infinite.positive &lt;-<span class="st"> </span>function(x) { <span class="co"># 输入的形式参数为 x</span>
  <span class="kw">ifelse</span>(<span class="kw">is.infinite</span>(x), x &gt;<span class="st"> </span><span class="dv">0</span>, <span class="ot">NA</span>) <span class="co"># 返回该表达式的结果</span>
}

<span class="co"># 在函数中输入 x 的值即返回该函数的计算结果</span>
<span class="kw">is.infinite.positive</span>(<span class="dv">1</span>/<span class="dv">0</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.infinite.positive</span>(-<span class="dv">1</span>/<span class="dv">0</span>)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">is.infinite.positive</span>(<span class="dv">0</span>/<span class="dv">0</span>)
<span class="co">#&gt; [1] NA</span></code></pre></div>

</div>
</div>
<div id="section-1.7" class="section level2">
<h2><span class="header-section-number">1.7</span> 数据模式、类型与对象的类辨析</h2>
<div id="section-1.7.1" class="section level3">
<h3><span class="header-section-number">1.7.1</span> 数据模式、类型</h3>
</div>
<div id="section-1.7.2" class="section level3">
<h3><span class="header-section-number">1.7.2</span> 对象的类</h3>
</div>
<div id="section-1.7.3" class="section level3">
<h3><span class="header-section-number">1.7.3</span> 基本数据结构的联系与区别</h3>
<div id="section-1.7.3.1" class="section level4">
<h4><span class="header-section-number">1.7.3.1</span> 向量与矩阵和数组</h4>
</div>
<div id="section-1.7.3.2" class="section level4">
<h4><span class="header-section-number">1.7.3.2</span> 向量与列表</h4>
</div>
<div id="section-1.7.3.3" class="section level4">
<h4><span class="header-section-number">1.7.3.3</span> 列表与数据框</h4>
</div>
<div id="section-1.7.3.4" class="section level4">
<h4><span class="header-section-number">1.7.3.4</span> 矩阵和数据框</h4>
</div>
<div id="section-1.7.3.5" class="section level4">
<h4><span class="header-section-number">1.7.3.5</span> 列表与向量</h4>

</div>
</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="section-2.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/lixionghui/r4da/edit/master/data_structure.Rmd",
"text": "编辑"
},
"download": ["r4da.pdf", "r4da.epub", "r4da.mobi"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
