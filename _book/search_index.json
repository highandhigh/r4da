[
["index.html", "利用R语言进行数据分析 前言", " 利用R语言进行数据分析 李雄辉 2016-08-07 前言 R语言是一种用于统计分析、绘图、数据挖掘的编程语言。 随着这几年大数据和数据科学等概念的火爆，很多数据分析师都开始学习这门语言。 虽然市面上已经有很多R语言相关的中英文教材，并且出现了一些在线课程和视频，但是由于R语言学习曲线比较陡峭，特别是对于非统计学专业的初学者而已还是很难掌握。 我自己是一名互联网行业的数据分析师，几年前开始学习R语言，在接近两年左右的时间后，才算是入门掌握了数据处理。期间一直都有记录笔记的习惯，现将其完善并整理成为体系，分享给大家，希望能对大家有所帮助。 "],
["section-1.html", "第1章 基本数据结构 1.1 向量 vector 1.2 矩阵 matrix 1.3 数组 array 1.4 数据框 data.frame 1.5 列表 list 1.6 特殊值 Special Values 1.7 数据模式、类型与对象的类辨析", " 第1章 基本数据结构 R语言借用了面向对象的结构，使用了“类”的抽象数据结构概念。 1.1 向量 vector 向量是R语言中最基本的数据结构, 其他类型的数据结构都可以由向量构成。 1.1.1 向量的类型与长度 最常见的向量有三种类型 数值型 字符型 逻辑型 1.1.1.1 数值型向量 numeric 假设有这样一个数据集, 包含上海某互联网公司数据部门12个员工的相关信息。 这些员工的身高分别是：176cm, 168cm, 172cm, 165cm, 166cm, 162cm, 181cm, 174cm, 178cm, 171cm, 172cm, 169cm。 R语言中的向量, 实际上就是一列数据集合。比如这些员工的身高序列 {176, 168, 172, 165, 166, 162, 181, 174, 178, 171, 172, 169}, 将这些身高数值用c()这个函数将其拼接起来, 每个数值之间用英文逗号隔开，就构成了一个向量。 这个向量中的每个数值就是该向量的一个元素。 在R语言中, &lt;-是赋值符号, 可以将值赋予给一个对象，或者说是变量。 下面的示例代码，将这些员工的身高按顺序拼接组合起来，并赋值给名为 height 的这个对象。 执行这行代码后，这个 height 对象，就是一个向量。 向量根据其元素的数据类型，可以分为几种不同的数据类型，比如员工的身高都是数值，该类型的向量就是数值型。 height &lt;- c(173, 168, 172, 165, 166, 162, 181, 174, 178, 171, 172, 169) 上面的c()函数，其作用是将每个元素的值合并成一个向量。 R语言中，所谓的函数，就是执行某类操作。 在控制台中直接输入对象的名字并运行, R语言程序就会将该对象包含的内容打印到显示屏幕上。 屏幕上显示的结果，每行都会以[1]这样标识开头，后面跟着具体的向量每个元素的值。 如果在控制台屏幕上一行显示不下，会继续在第二行显示，第二行开头也会以[n]开始，至于n具体是多少，就看第二行是从第几个元素开始显示。第三行、第四行以此类推。 height #&gt; [1] 173 168 172 165 166 162 181 174 178 171 172 169 直接运行对象的名字, 实际上等于使用了 print() 函数, 两者等价。 print(height) #&gt; [1] 173 168 172 165 166 162 181 174 178 171 172 169 1.1.1.2 字符型向量 character 这12名员工的姓名分别是：宋子启, 张伯仲, 孟轲舆, 张伟, 王雪梅, 陈梦妍, 李元礼, 杨伯侨, 赵蜚廉, 蒋欣, 沈约度, 陈淮阳。 他们的姓名也可以组成一个向量，姓名是字符，所以向量的类型是字符型。 在R语言中, 字符串类型的值需要用引号括起来, 可以使用双引号, 也可以使用单引号。推荐使用双引号。 当然, 无论是哪种引号, 都是英文输入法下的引号, 中文下的引号是不被系统识别的。 实际上，所有以英文为自己的编程语言，所能识别的关键字符都是英文的，比如之前提到的c()函数中连接字符串的逗号，字符串的引号，以及后面陆续会使用的符号，都是在英文输入法环境下的符号，不再累述。 创建12名员工的字符创向量代码如下： name &lt;- c(&quot;宋子启&quot;, &quot;张伯仲&quot;, &quot;孟轲舆&quot;, &quot;张伟&quot;, &quot;王雪梅&quot;, &quot;陈梦妍&quot;, &quot;李元礼&quot;, &quot;杨伯侨&quot;, &quot;赵蜚廉&quot;, &quot;蒋欣&quot;, &quot;沈约度&quot;, &quot;陈淮阳&quot;) 显示name这个向量中的所有名字，并在命令行中添加注释文本。 井号后面文本是代码注释，不会被执行。很多时候在大段的代码中，需要输入一些备注文本说明一些逻辑或者结构等。井号个数不限，井号开始后面的一整行都被注释。 name # 井号后面文本是代码注释，不会被执行 #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot; #&gt; [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; 1.1.1.3 逻辑型向量 logical 在公司的员工信息登记表中，还会记录是否本地户口信息，便于办理社会保险等相关事项。相应的也会有该12名员工的是否本地户口信息，如{是，是，否，是，否，否，否，是，否，否，是，是}。 我可以直接使用“是”和“否”两个字符来表示该信息，作为一个字符型向量。 不过，大多数编程语言中都会有专门的一种逻辑型数据类型来表示这种是否问题，记录真假值，可以用来做条件判断和逻辑运算。 R语言中，用TRUE来表示逻辑真，用FALSE表示逻辑假，也就是计算机二进制的两种状态0和1。这两个英文字符都是大写，也可以使用T和F代替。 这里的是否本地户口的原始数据“是”和“否”，我们这里就用TRUE和FALSE来代替，并创建这个逻辑型向量如下： islocal &lt;- c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE) islocal #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE #&gt; [12] TRUE 1.1.1.4 向量的类属性 class “类”是一种对象的属性，用来定义数据结构，是面对对象编程的概念。 这里的“类”，可以理解为对象的数据结构类型。 函数class() 获得对象的“类”属性。 对向量来说，向量的类，就是向量的类型。 class(height) # &quot;numeric&quot; 数值型 #&gt; [1] &quot;numeric&quot; class(name) # &quot;character&quot; 字符型 #&gt; [1] &quot;character&quot; class(islocal) # &quot;logical&quot; 逻辑型 #&gt; [1] &quot;logical&quot; 向量的类型，还可以用 typeof() 和 mode() 这两个函数获得，返回的结果只在“数值型”的向量上略有区别，主要是角度不同。 1.1.1.4.1 检验向量的类型 R语言还提供了判断向量是否属于某种类型的一系列函数，对应上面三种类型分别是 is.numeric(x) is.character(x) is.logical(x) 其中参数 x 是待检验的对象，该函数返回类型检验结果的逻辑值，TRUE 或 FALSE. is.numeric(height) # &quot;numeric&quot; 数值型 #&gt; [1] TRUE is.character(name) # &quot;character&quot; 字符型 #&gt; [1] TRUE is.logical(islocal) # &quot;logical&quot; 逻辑型 #&gt; [1] TRUE 判断其他两类是否为数值型 is.numeric(name) #&gt; [1] FALSE is.numeric(islocal) #&gt; [1] FALSE 判断其他两类是否为字符型 is.character(height) #&gt; [1] FALSE is.character(islocal) #&gt; [1] FALSE 判断其他两类是否为逻辑型 is.logical(height) #&gt; [1] FALSE is.logical(name) #&gt; [1] FALSE 1.1.1.5 向量的长度 length 向量的长度，就是向量中包含的元素的个数。 获得向量长度的函数是 length(x) ，返回的是一个整数。 这里“身高”、“姓名”、“是否本地”三个向量，都是记录了 12 名员工的信息，故而这三个向量长度的结果应该都是 12。 length(height) #&gt; [1] 12 length(name) #&gt; [1] 12 length(islocal) #&gt; [1] 12 1.1.1.6 单个元素的向量 假设这个数据分析团队现在新加入了一名员工，其身高是 174cm，姓名是“况天佑”，不是本地人。 将这三个数据分别赋值给三个对象，它们分别是只包含一个元素的向量。 h1 &lt;- c(174) h1 #&gt; [1] 174 n1 &lt;- c(&quot;况天佑&quot;) n1 #&gt; [1] &quot;况天佑&quot; l1 &lt;- c(FALSE) l1 #&gt; [1] FALSE 对于单个元素的数据赋值给一个对象时，不需要c()函数，因为c()函数的作用是将多个元素合并成一个向量。直接将值赋给对象给方便。 h1 &lt;- 174 n1 &lt;- &quot;况天佑&quot; l1 &lt;- FALSE 有些地方会将只包含单个元素的向量，也就是长度为一的向量，另外起一个名字叫“标量”。 实际上，R语言没有标量这个说法，也没有判读一个对象是否为标量的函数。 所有的数据都是向量。 # 单个元素的向量，其长度为 1 length(h1) #&gt; [1] 1 length(n1) #&gt; [1] 1 length(l1) #&gt; [1] 1 1.1.1.7 检验对象是否为向量 is.atomic 判断一个对象是否为向量的函数是 is.atomic() , 如果是向量, 则返回值为 TRUE, 如果不是则返回 FALSE。 这里讨论的“向量”是狭义的概念，是原子向量(atomic vector)。 R中还有其他的广义的向量，如矩阵和数组，以及泛化的向量，如列表。 故而检验对象是否为原子向量是用 is.atomic()，而不是is.vector()。 # 长度为 12 的向量，判断结果返回的结果是 TRUE is.atomic(height) #&gt; [1] TRUE is.atomic(name) #&gt; [1] TRUE is.atomic(islocal) #&gt; [1] TRUE # 长度为 1 的向量，判断结果返回的结果也是 TRUE is.atomic(h1) #&gt; [1] TRUE is.atomic(n1) #&gt; [1] TRUE is.atomic(l1) #&gt; [1] TRUE 1.1.1.8 向量的合并 combine 我们将第13名员工的信息，合并到前12名员工的向量中，依然使用 c() 函数。 # 这里讲合并后的结果还是还是赋值给原来的对象 # 新对象就包含13个元素 height &lt;- c(height, h1) height #&gt; [1] 173 168 172 165 166 162 181 174 178 171 172 169 174 length(height) #&gt; [1] 13 name &lt;- c(name, n1) name #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot; #&gt; [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; length(name) #&gt; [1] 13 islocal &lt;- c(islocal, l1) islocal #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE #&gt; [12] TRUE FALSE length(islocal) #&gt; [1] 13 假设，该团队又有两名新成员加入，依然使用c()函数添加，并且可以直接追加向量的值，而不需要先赋予给另一个对象。 # 新对象继续添加了两名员工的信息 # 现在向量的元素一共包含了 15 个员工的信息 height &lt;- c(height, 170, 172) height #&gt; [1] 173 168 172 165 166 162 181 174 178 171 172 169 174 170 172 length(height) #&gt; [1] 15 name &lt;- c(name, &quot;王珍珍&quot;, &quot;马小玲&quot;) name #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot; #&gt; [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; #&gt; [15] &quot;马小玲&quot; length(name) #&gt; [1] 15 islocal &lt;- c(islocal, TRUE, TRUE) islocal #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE #&gt; [12] TRUE FALSE TRUE TRUE length(islocal) #&gt; [1] 15 1.1.1.9 不同类型向量转化 向量的一个内在要求是，其内部元素之间的类型要相同。 1.1.1.10 合并向量时类型不同自动转化 创建或者合并向量时，如果元素类型之间不相同，则会遵循优先兼容递升原则，自动转为兼容性更高的类型。 逻辑型会被转为数值型 数值型会被转为字符型 在数值型向量中，严格意义上来说，还区分两种类型，一个是子类：“整数型”，一个是父类“复数型”，而“数值型”实际上就是“实数型”。 在数学上，整数 ∈ 实数 ∈ 复数。 按类型转化原则，在数值型之间，整数型会转为实数型，数值型会转为复数型。 class(c(TRUE, 1, FALSE, 0)) # 逻辑型转为数值型 #&gt; [1] &quot;numeric&quot; print(c(TRUE, 1, FALSE, 0)) # TRUE 转为 1, FASLE 转为 0 #&gt; [1] 1 1 0 0 class(c(TRUE, &quot;真&quot;, FALSE, &quot;假&quot;)) # 逻辑型转为数值型 #&gt; [1] &quot;character&quot; print(c(TRUE, &quot;真&quot;, FALSE, &quot;假&quot;)) # TRUE 转为 &quot;TRUE&quot;（字符）, FASLE 转为 &quot;FASLE&quot;（字符） #&gt; [1] &quot;TRUE&quot; &quot;真&quot; &quot;FALSE&quot; &quot;假&quot; class(c(3.14, &quot;PI&quot;)) # 数值型转为字符型 #&gt; [1] &quot;character&quot; print(c(3.14, &quot;PI&quot;)) # 3.14 转为 &quot;3.14&quot;（字符） #&gt; [1] &quot;3.14&quot; &quot;PI&quot; print(c(1, 3.14)) # 整数型转为数值型 #&gt; [1] 1.00 3.14 class(c(3.14, 2 + 5i)) # 数值型转为复数型 #&gt; [1] &quot;complex&quot; print(c(3.14, 2 + 5i)) # 数值型转为复数型 #&gt; [1] 3.14+0i 2.00+5i 1.1.1.10.1 强制类型转化函数 类似于 is.FUN 一系列向量类型检验函数，强制类型转化也相似的一系列函数 as.logical(x) as.number(x) as.integer(x) as.complex(x) as.character(x) 强制类型转化遵循一定的原则，比如 数值型可以转为逻辑型：0 转为逻辑值 FALSE, 非 0 都转为 TRUE 字符型可以转为数值型的条件是：去掉字符符号（引号）之后是可以被识别的数值 如果不符合转化条件，则强制转化后对应的元素的结果将变成 NA，这是 R 语言中的缺失值，因为系统不知道该显示什么值是正确的，相当于信息丢失; 在强制转化过程中如果产生了NA，则会出现系统“警告”。实际上这时候程序已经执行成功了，并不会等待确认或者要放弃执行，警告信息只是一种提醒。 as.logical(c(1,0,2)) # 0 转为逻辑值 FALSE, 非 0 都转为 TRUE #&gt; [1] TRUE FALSE TRUE as.logical(c(0, 0.68, 1, 3.14)) # 0 转为逻辑值 FALSE, 非 0 都转为 TRUE #&gt; [1] FALSE TRUE TRUE TRUE as.numeric(name) # 将名字转为数值，得到的都是 NA，程序不知道该转为什么值合适 #&gt; Warning: 强制改变过程中产生了NA #&gt; [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA as.numeric(&quot;3.14&quot;) # 如果去掉字符型的符号后能被系统识别为数值，则可顺利转化 #&gt; [1] 3.14 class(as.numeric(&quot;3.14&quot;)) # 打印出转化后的类型 #&gt; [1] &quot;numeric&quot; 字符和数值之间类型转化是很常见的。 比如爬虫系统，从网页上爬取所需数据，最迟得到的数据是字符型的（网页是富文本），要做数值运行就需要将其转为数值型。 在需要输出特殊格式化的结果时，通常会将数值转为字符。最常见的例子是，将一个百分比数值显示为带有百分号的格式。 1.1.2 等差序列向量 sequence 对这 15 名员工，我想给他们编一个序号，从 1 到 15。 我可以用 c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15) 这样的原始输入方式获得，但这种手动输入不是很方便，特别是数量很大的时候。 这些数字是有规律的，是等差递增向量，其步长为 1. 只要是有规律的，实际上程序就可以自动生成。 R语言中有一个专门的函数来生成这种等差序列的向量，该函数是 seq() ，其参数是 from 表示开始的数值， to 是结束的数值，by 是步长（每次增加的数值）。 我们用 seq() 函数来生成从 1 到 15 的向量，间隔为 1，并将结果赋值给 no 这个对象。 no &lt;- seq(from = 1, to = 15, by = 1) no #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 函数的参数名称是形式参数，其值是实际参数, 这里的 from, to, by 是形式参数，其值 1, 15, 1 是对象的实际参数。 在R语言中，形式参数是可以不直接写出来的，这种情况下，按照参数的值所在的位置去对应参数的名称，这样就可以简化一些常用函数的书写过程。 比如上面这个创建等差序列向量的过程，我们就可以简化为 no &lt;- seq(1, 15, 1) 函数的参数有时候会定义默认值，比如 seq() 中 by 的默认值为 1，则在使用该函数的不指定该参数的值，就会在运行过程中使用该参数的默认值，这时候函数的书写就可以进一步简化。 no &lt;- seq(1, 15) 这也是之前在使用函数 head() 和 tail() 时，不指定参数 n 的情况下，只显示首尾 6 个元素的原因，因为参数 n 的默认值就是 6. seq() 函数还有另外一个用法，当我们知道等差序列的起止数值，但不知道步长应该是多少，只知道应该产生多少个元素的向量，可以使用参数 length.out 产生等差序列还有一种情况：已知起始值 from 和 终止值 to ，但不知道步长 by 的值，但知道应该要产生多少个元素的向量，这时可以使用 seq() 函数的另一个参数 length.out , 表示要产生多少个元素。 seq(from = 1, to = 15, length.out = 15) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 但这里要注意的是，seq() 函数中 by 和 length.out 两个参数不能同时使用，只能使用一个，否则会报错。 实际上，seq() 函数中如果指定了 length.out 这个参数，则 by 的值会被自动计算出来， by = ((to - from)/(length.out - 1) 。 因为等差序列的关键参数还是 from, to 和 by ，程序最终还是需要知道步长是多少，否则无法计算。不能同时指定的原因是，可能会出现用户输入的 by 和从 length.out 计算的 by = ((to - from)/(length.out - 1) 两者不相等，就会出问题。 这种情况下 by = ((to - from)/(length.out - 1) 这个表达式，使用了 from, to, length.out 这三个参数的具体的值。R语言中可以允许这种一个参数调用其他参数值的情况，可以使得函数更为灵活。 步长为 1 的等差序列最为常用，故而还有一种更为便捷的书写方式，n:m，这种包含符号的写法成为表达式。比如 1:15 就等价于 seq(1,15) , 等价于 seq(from = 1, to = 15, by = 1)。 表达式，本质上也是一种函数。R语言中所有的操作，都是函数过程。 n &lt;- 1:15 如果我们要等到递减的等差序列，则 to 的值大于 from 即可。 15:1 #&gt; [1] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 另外，等差序列可以产生实数，并不限于整数（上面的值都是整数）。 seq(from = 0.01, to = 0.15, by = 0.01) #&gt; [1] 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 #&gt; [15] 0.15 对于函数的参数是否书写的问题，建议如下：如果已经对该函数中的参数名称、顺序、参数默认值等情况比较清楚，自己简化书写的时候不会产生困惑，则可以简化。在不熟悉的情况下，建议书写完整，容易阅读。 另外，函数的各参数之间，尽量空一格；参数名和参数值与等号之间，尽量空一格，使得代码更规范，便于阅读。 1.1.3 循环重复向量 replicate 有时候，我们需要产生一些重复的向量，R语言中有专门的函数来处理。 假设我们要对这15名员工做个分组，按照顺序分为3组，每个组给予1,2,3,4,5这样的序号。 R语言中有一个函数 rep() ，可以生成具有重复性质的向量，或者说将一个向量按重复循环生成更多元素的向量。 该函数有一个参数 times 可以，可以指定对一个向量重复的次数。 这里的分组，我们就可以先创建一个 c(1, 2, 3, 4, 5) 向量，然后将其循环 3 次到达目标。 three_group_3 &lt;- rep(c(1, 2, 3, 4, 5), times = 3) print(three_group_3) #&gt; [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 假设我们做个不同的分组，共分为5组，前3名员工分为第1组，记录他们的组号为1，随后的3名分为第2组，记录为2，直到最后一组，也就是第5组，记录为5。 该函数还有另外一个参数 each，可以指定向量的每个元素按顺序循环的次数。上面的分组我们可以用 each 参数来实现。 three_group_5 &lt;- rep(c(1, 2, 3, 4, 5), each = 3) print(three_group_5) #&gt; [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 rep() 函数中的 times 参数，是对整个向量循环重复；而 each 参数，是对向量中的元素循环重复。 times 和 each 两个参数是可以同时使用的， each 参数的优先级高于 times 参数，先循环重复每个元素得到新向量对象，然后再对此新结果整个向量做循环重复。 times 和 each 的默认参数都是 1 ，故而可以只设定一个即可。多数情况下，我们只选择一种用法，也就是只使用一个参数。 对于 seq() 函数的用法，可以使用 help() 函数来获得更进一步的信息。执行 help(seq) 就会打开一个页面，介绍关于seq()函数的各种信息，通常都会包括 描述(Description) 用法(Usage) 参数(Arguments) 详情(Details) 参数值(Value) 参考文献(References) 参考更多信息(See Also) 示例(Examples) 其中 Arguments 和 Examples 是最有用的部分。 help(seq) # 查看关于该函数的帮助信息 ?seq # 也可以使用“?”开头紧接着函数名的方式 1.1.4 数值向量的算术运算 这个数据分析团队中的每个成员都已经有身高信息了，我们再来提供他们的体重信息，单位为 kg. weight &lt;- c(73, 70, 68, 60, 55, 52, 80, 75, 78, 54, 61, 62, 56, 53, 82) print(weight) #&gt; [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 现在，我们想要计算每个人的“身高体重指数”(BMI, Body Mass Index)，计算该指数用来反映一个人的整体营养状态，比如是否偏瘦，还是偏胖等。 身高质量指数的公式是 \\[BMI = \\frac{w}{h^2}\\] w = 体重, 单位：千克(kg)； h = 身高，单位：米(m)； BMI = 身高体重指数，单位：千克/平方米(kg/m^2) 之前的身高向量 height 的单位是 cm(厘米)，按照公式需要，先转换单位为 m(米)，只要每个元素除以100即可。 将一个数值向量，除以一个数值时，每个元素都会做相同的算术运算。 height &lt;- height / 100 # / 是除法符号，左边除以右边 print(height) #&gt; [1] 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70 #&gt; [15] 1.72 这时我们得到了单位为米的身高数据。 我们要计算每个人的身高质量指数，只要对身高和体重两个向量直接做算术运算即可。 当两个向量的长度相同（包含的元素相同）时，算术运算时每个元素都是一一对应的。 BMI &lt;- weight / (height ^ 2) # ^ 是幂符号，^2就是2次方，也就是平方 print(BMI) #&gt; [1] 24.4 24.8 23.0 22.0 20.0 19.8 24.4 24.8 24.6 18.5 20.6 21.7 18.5 18.3 #&gt; [15] 27.7 最后，我们根据身高质量指数的统计分析对照表来做这 15 名员工的体质做分析。 总体来说，BMI值小于18.5属于偏瘦，大于25属于偏胖。 从结果上看，第10名员工的BMI约等于18.5，算是标准体质范围；有两位员工需要注意自己的体质健康状况： 第14名员工就属于偏瘦，需要多补充点营养即可； 第15名员工就属于偏胖，需要加强身体锻炼了。 R语言中关于数值的算术运算符号及含义见下表 算术运算符号 符号含义 + 加号，数值相加 - 减号，数值相减 * 乘号，数值相乘 / 除号，数值相除 %% 取模，数值相除取不能整除的余数 %/% 取整，数值相除取整除的部分 ^ 幂，幂运算，x^y 表示 x 连续乘以 x 自身 y 次 15 + 6 #&gt; [1] 21 15 - 6 #&gt; [1] 9 15 * 6 #&gt; [1] 90 15 / 6 #&gt; [1] 2.5 15 %% 6 #&gt; [1] 3 15 %/% 6 #&gt; [1] 2 2^3 #&gt; [1] 8 1.1.5 向量运算的循环补齐 我们再回过头来看 height/100 一个向量直接除以一个数值的情况。 我们知道，一个数值，实际上就是一个只包含一个元素的向量。那么这里的情况是，一个包含 15 个元素的向量，除以一个只包含一个元素的向量。 向量的算术运算实际上是需要两个个数相同，每个元素之间相互对应做运算的。那么这里是怎么实现最终的运算的呢？ 这里引出了一个R语言向量运算过程中的一个重要概念，向量循环补齐。 100这个数值是只包含一个元素的向量，对应要运算的向量是包含15个元素的向量，根据循环补齐原则，这里先向量长度少的向量，按照循环重复的原则补齐到相同长度，使用 rep() 的规则，且重复的参数是 times。 这里 100 这个单个元素（长度为1的向量），先处理为 rep(100, time = 15) 的向量，再做计算，等价于 height/rep(100, times = 15) 如果我们将包含15个元素的体重向量 weight，除以包含4个元素的向量c(1, 2, 3, 4)，会发生什么呢？ weight/c(1, 2, 3, 4) #&gt; Warning in weight/c(1, 2, 3, 4): 长的对象长度不是短的对象长度的整倍数 #&gt; [1] 73.0 35.0 22.7 15.0 55.0 26.0 26.7 18.8 78.0 27.0 20.3 15.5 56.0 26.5 #&gt; [15] 27.3 运算后该表达式会得到一个结果值，但是同时会打印出一条红色警告信息：“长的对象长度不是短的对象长度的整倍数” 。 该计算过程会去重复循环长度短的向量，如果“长的对象长度不是短的对象长度的整倍数”，则重复次数 = (长的对象长度/短的对象长度)除数的整数部分 + 1。这里 15/4的除数3倍 + 1 ，times = 4. c(1, 2, 3, 4) 重复 4 次之后，就得到长度为 16 的向量，比原来长的对象的长度还要多，则多出的部分会被丢弃，使得计算的两个向量长度相同。 因为有丢弃的情况出现，故而计算后会有一个警告信息，作为提示。 如果“长的对象长度”正好是“短的对象长度”的整倍数，则直接循环重复后计算，且不会提出警告信息。 weight/c(1, 2, 3) #&gt; [1] 73.0 35.0 22.7 60.0 27.5 17.3 80.0 37.5 26.0 54.0 30.5 20.7 56.0 26.5 #&gt; [15] 27.3 1.1.6 向量索引与子集筛选 向量是多个元素的集合，当我们只需要指定或者说提取该向量中的某个元素时，就可以使用向量的索引(Indexing)。 向量元素可以由三种基本类型的向量索引 整数型，索引的是元素位置 字符型，索引的是名称属性 逻辑型，索引的是相同长度的逻辑向量对应的逻辑值为真的元素 1.1.6.1 通过元素位置索引向量 第一种元素的索引方式，是通过在向量后面加中括号，其中输入需要索引的元素的位置（第几个）。 比如我们想要获得该数据分析团队中的第2个人的身高，第5个人的名字，第9个人的体重，以及第14个人的身高体重指数，则直接索引对应向量的位置序号即可。 height[2] # 第2个人的身高 #&gt; [1] 1.68 name[5] # 第5个人的名字 #&gt; [1] &quot;王雪梅&quot; weight[9] # 第9个人的体重 #&gt; [1] 78 BMI[14] # 第14个人的身高体重指数 #&gt; [1] 18.3 还是回到单个数值本身就是向量的问题，这里的位置索引，只要求是整数向量即可，故而一次索引多个元素。 height[1:5] # 第1到第5个人的身高 #&gt; [1] 1.73 1.68 1.72 1.65 1.66 name[c(2, 6, 8)] # 第2,6,8个人的名字 #&gt; [1] &quot;张伯仲&quot; &quot;陈梦妍&quot; &quot;杨伯侨&quot; weight[c(15, 4, 12, 1)] # 第15,4,12,1个人的体重，具体的顺序可以任意指定 #&gt; [1] 82 60 62 73 BMI[15:12] # 第15到12个人的身高体重指数 #&gt; [1] 27.7 18.3 18.5 21.7 这里需要注意的是，作为位置索引的数字整数，不能超过该向量的长度。否则会得到一个值为 NA 的结果，也就是一个空值。 height[16] # 第16个元素不存在 #&gt; [1] NA name[c(-2, -6, -8)] # 第2,6,8个人的名字 #&gt; [1] &quot;宋子启&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;李元礼&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; #&gt; [8] &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; &quot;马小玲&quot; weight[-c(15, 4, 12, 1)] # 第15,4,12,1个人的体重，具体的顺序可以任意指定 #&gt; [1] 70 68 55 52 80 75 78 54 61 56 53 BMI[15:12] # 第15到12个人的身高体重指数 #&gt; [1] 27.7 18.3 18.5 21.7 当我们想要获得排除某个位置元素的剩余其他元素向量的时候，位置索引数字变成负数即可。 height[-15] # 排除第15个元素的身高向量 #&gt; [1] 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70 name[c(-2, -6, -8)] # 排除第2,6,8个人的名字 #&gt; [1] &quot;宋子启&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;李元礼&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; #&gt; [8] &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; &quot;马小玲&quot; weight[-c(15, 4, 12, 1)] # -c(15, 4, 12, 1) 等价于 -1 * c(15, 4, 12, 1) #&gt; [1] 70 68 55 52 80 75 78 54 61 56 53 BMI[-15:-12] # 排除第15到第12个人的身高体重指数 #&gt; [1] 24.4 24.8 23.0 22.0 20.0 19.8 24.4 24.8 24.6 18.5 20.6 1.1.6.2 通过名称属性索引向量 向量可以设置一个名称属性，从而可以通过名称来索引向量。 名称属性可以通过 names() 来指定，将一个包含名称的向量，指定给等长度的向量。 例如，我们将这 15 名员工的姓名向量，赋值给身高向量作为名称属性。 这样，身高向量就具有了名称属性，每个身高元素都会对应一个姓名。print(height) 时候也会将元素的名称显示出来。 print(name) #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot; #&gt; [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; #&gt; [15] &quot;马小玲&quot; print(height) #&gt; [1] 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70 #&gt; [15] 1.72 names(height) &lt;- name # 这里将 name 作为 height 的 names 属性 print(height) #&gt; 宋子启 张伯仲 孟轲舆 张伟 王雪梅 陈梦妍 李元礼 杨伯侨 赵蜚廉 蒋欣 #&gt; 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 #&gt; 沈约度 陈淮阳 况天佑 王珍珍 马小玲 #&gt; 1.72 1.69 1.74 1.70 1.72 通过名称向量即可索引具体的元素，用法和位置索引类似，但是名称是字符，故而索引的名称要作为字符处理，需要添加字符引号。 通过名称来索引，有个显而易见的好处，记住名字比位置更为方便。 height[&quot;马小玲&quot;] #&gt; 马小玲 #&gt; 1.72 height[c(&quot;马小玲&quot;,&quot;蒋欣&quot;)] #&gt; 马小玲 蒋欣 #&gt; 1.72 1.71 1.1.6.3 通过逻辑表达式筛选子集 用逻辑向量来筛选向量元素，也是常见的用法。在索引符号中输入逻辑向量，就会筛选出对应的逻辑为真(TRUE)的元素。 比如，在这 15 名员工中，筛选出户口是本地的员工。现在已经有了 islocal 的逻辑向量，可直接筛选出本地户口的员工了。 print(name) #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot; #&gt; [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; #&gt; [15] &quot;马小玲&quot; print(islocal) #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE #&gt; [12] TRUE FALSE TRUE TRUE name[islocal] #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;张伟&quot; &quot;杨伯侨&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;王珍珍&quot; &quot;马小玲&quot; # 如果把 islocal 原本的逻辑值显示完整等价于 name[c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE)] #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;张伟&quot; &quot;杨伯侨&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; 如果逻辑向量长度少于被筛选向量, 则会通过向量循环补齐的方式自动补全为与筛选对象等长的逻辑向量在筛选， name[c(TRUE, FALSE, TRUE, FALSE, FALSE)] # 第1个和第3个元素逻辑值为TRUE #&gt; [1] &quot;宋子启&quot; &quot;孟轲舆&quot; &quot;陈梦妍&quot; &quot;杨伯侨&quot; &quot;沈约度&quot; &quot;况天佑&quot; # 等价于索引的逻辑向量先循环补齐长度与被筛选对象相同，这里正好是3倍 name[rep(c(TRUE, FALSE, TRUE, FALSE, FALSE), times = 3)] #&gt; [1] &quot;宋子启&quot; &quot;孟轲舆&quot; &quot;陈梦妍&quot; &quot;杨伯侨&quot; &quot;沈约度&quot; &quot;况天佑&quot; 这种逻辑索引的方式，更为重建的用法是逻辑表达式：一个向量经过逻辑运算后得到相同长度的逻辑向量，然后用此结果逻辑向量来筛选符合逻辑为真的元素。 比如，weight &gt; 60 就是一个逻辑表达式，大于号是一个比较运算符，类似于算术运算，这里也是一个向量与另一个向量的对应的值的比较，返回的结果是一个逻辑向量，也就是每个比较的结果，是否为真，为真就记录为 TRUE，否则就记录为 FALSE。 这里的 60 虽然只是一个数值，但它就是只包含一个元素的向量，这里的运算还是会类似于算术运算中，先对其做向量循环补齐，然后再一一对应做比较运算。关于单个数值的向量循环补齐原则，后续将不再单独说明。 weight &gt; 60 # 逻辑表达式，返回相同长度的逻辑向量 #&gt; [1] TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE TRUE #&gt; [12] TRUE FALSE FALSE TRUE height[weight &gt; 60] #&gt; 宋子启 张伯仲 孟轲舆 李元礼 杨伯侨 赵蜚廉 沈约度 陈淮阳 马小玲 #&gt; 1.73 1.68 1.72 1.81 1.74 1.78 1.72 1.69 1.72 如果要对一个逻辑结果做一个转化，真变为假，假变为真，则有一个运算符号来完成，在逻辑表达式前加“!”(英文状态下的惊叹号)，也可以将在一个逻辑表达式前面。 weight[!(weight &gt;= 60)] # 这里加入括号，更容易理解其优先级顺序 #&gt; [1] 55 52 54 56 53 weight[!weight &gt;= 60] # 这里 !weight &gt;= 60 等价于 !(weight &gt;= 60) 是因为 ! 的优先级比 &gt;= 低 #&gt; [1] 55 52 54 56 53 weight[islocal] #&gt; [1] 73 70 60 75 61 62 53 82 weight[!islocal] #&gt; [1] 68 55 52 80 78 54 56 weight[!rep(c(TRUE, FALSE, TRUE, FALSE, FALSE), times = 3)] #&gt; [1] 70 60 55 80 78 54 62 53 82 判断一个值是否等于另一个只，是用 “==” 两个连续等号，因为单个等号有其他两个含义，一个是赋值符号，一个是在函数中指定参数值。 而判断一个值是否不等于另一个值，是否“!=”，一个否定的惊叹号紧接着一个等号。这里也是需要特别注意，因为有很多其他的编程语言用了其他的方式来表示不相等，比如“&lt;&gt;”，小于和大于号连用这种方式在R语言中是不能识别的。 1 == 1 # TRUE #&gt; [1] TRUE 1 != 1 # FALSE #&gt; [1] FALSE 1 == 2 # FALSE #&gt; [1] FALSE 1 != 2 # TRUE #&gt; [1] TRUE weight[weight == 80] #&gt; [1] 80 weight[weight != 80] #&gt; [1] 73 70 68 60 55 52 75 78 54 61 62 56 53 82 下表是常用的比较运算符号及其含义： 比较运算符号 含义 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 == 等于 != 等于 1.1.6.4 通过 subset() 筛选子集 R语言中，有一个专门用来筛选子集的函数 subset(), 其参数为待筛选子集的对象，和一个逻辑表达式。 对向量来说，subset() 的用法和逻辑表达式筛选是类似的，subset()的含义，更多的是使用函数来操作，这在管道操作中比较有效，而不是“[]”这种符号化的操作。 subset(weight, weight &gt;= 60) # 等价于 weight[weight &gt;= 60] #&gt; [1] 73 70 68 60 80 75 78 61 62 82 1.1.6.5 通过 head() 和 tail() 筛选首尾向量 有时候，我们想要快速的查看某个向量的前几个元素，而不要在屏幕上将所有元素都出来，这样的函数就非常有用。 显示前几个元素函数是 head()，默认显示前6个元素。 对应地，也有一个显示最后几个元素的函数是 tail()，默认显示最后6个元素。 也就是 头(head) 和 尾(tail)。 head(height) #&gt; 宋子启 张伯仲 孟轲舆 张伟 王雪梅 陈梦妍 #&gt; 1.73 1.68 1.72 1.65 1.66 1.62 head(name) #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;陈梦妍&quot; head(islocal) #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE tail(height) #&gt; 蒋欣 沈约度 陈淮阳 况天佑 王珍珍 马小玲 #&gt; 1.71 1.72 1.69 1.74 1.70 1.72 tail(name) #&gt; [1] &quot;蒋欣&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; &quot;马小玲&quot; head(islocal) #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE head() 和 tail() 都有一个参数 n 可以指定具体显示元素的个数。 head(height, n = 10) #&gt; 宋子启 张伯仲 孟轲舆 张伟 王雪梅 陈梦妍 李元礼 杨伯侨 赵蜚廉 蒋欣 #&gt; 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 head(name, n = 3) #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; head(islocal, n = 6) #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE tail(height, n = 10) #&gt; 陈梦妍 李元礼 杨伯侨 赵蜚廉 蒋欣 沈约度 陈淮阳 况天佑 王珍珍 马小玲 #&gt; 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70 1.72 tail(name, n = 3) #&gt; [1] &quot;况天佑&quot; &quot;王珍珍&quot; &quot;马小玲&quot; head(islocal, n = 6) #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE 1.1.7 因子向量 factor 在这 15 名员工的信息中，现在新添加一列用来存储性别。 在R语言中有一种特殊的数据类型，可以用方便处理类别变量，称其为“因子(factor)”。 因子根据类别是否具有顺序上的意义分为两类： 无序因子：类别变量并未实际的顺序意义，如性别 有序因子：类别变量有实际的顺序意义，如年龄层、收入区间、优良中差等级，类别之间是有大小、高低、好坏等顺序信息的 因子的类别，在R语言中有一个专有的名称，称为“水平(levels)”。 因子是通过 factor() 函数来定义的，跟普通的字符型向量创建类似，但需要指定 levels 有哪些，如果是有序因子则还要指定个水平的顺序。 gender &lt;- factor(x = c(&quot;男&quot;, &quot;男&quot;, &quot;男&quot;, &quot;男&quot;, &quot;女&quot;, &quot;女&quot;, &quot;男&quot;, &quot;男&quot;, &quot;男&quot;, &quot;女&quot;, &quot;男&quot;, &quot;男&quot;, &quot;男&quot;, &quot;女&quot;, &quot;女&quot;), levels = c(&quot;男&quot;, &quot;女&quot;)) # 一段完整的代码未结束时，其他参数可另起一行书写 print(gender) # 除了显示该向量具体的类别信息外，还是显示所有水平 #&gt; [1] 男 男 男 男 女 女 男 男 男 女 男 男 男 女 女 #&gt; Levels: 男 女 class(gender) # 类为 factor #&gt; [1] &quot;factor&quot; 因子是一种向量，可以用 is.atomic(x) 来检验。 检验一个对象是否为因子，可以用 is.factor(x) 函数。 is.atomic(gender) # 因子是一种向量 #&gt; [1] TRUE is.factor(gender) # 检验一个对象是否为因子 #&gt; [1] TRUE 从对象的类上来说，因子是一种向量，或者说是一种因子型向量，与逻辑型、数值型、字符型相对。 公司每年在年终结束的时候，需要进行绩效考核，评估员工在过去一年的表现，评级为“优”、“良”、“中”、“差”四种。 而该数据分析团队最终考核是结果只在“优”、“良”、“中”三个等级里，没有人被评级为“差”。在这种情况下，因子的水平就会体现出其作用来。绩效等级因子对应着四个水平，虽然团队考核最终只出现了三种，但从因子水平中可以看到有四种。 “优”、“良”、“中”、“差”四个等级，依次从好到差，是有顺序的，这种情况下因子的顺序也变成了一种有用的信息。 grade &lt;- factor(x = c(&quot;中&quot;, &quot;良&quot;, &quot;良&quot;, &quot;中&quot;, &quot;优&quot;, &quot;良&quot;, &quot;中&quot;, &quot;优&quot;, &quot;中&quot;, &quot;良&quot;, &quot;良&quot;, &quot;中&quot;, &quot;良&quot;, &quot;中&quot;, &quot;优&quot;), levels = c(&quot;差&quot;, &quot;中&quot;, &quot;良&quot;, &quot;优&quot;), ordered = TRUE) # ordered = TRUE 使用排序，具体的排序就是levels中的先后顺序，从小到大（从低到高） print(grade) # 除了显示该向量具体的类别信息外，还是显示所有水平 #&gt; [1] 中 良 良 中 优 良 中 优 中 良 良 中 良 中 优 #&gt; Levels: 差 &lt; 中 &lt; 良 &lt; 优 class(grade) # 有序的因子出了 factor 类之外，还有一个 ordered 的类 #&gt; [1] &quot;ordered&quot; &quot;factor&quot; 类似地，可以检验该对象是否为向量，是否为因子，是否是有序的。 is.atomic(grade) # 因子是一种向量 #&gt; [1] TRUE is.factor(grade) # 检验一个对象是否为因子对象 #&gt; [1] TRUE is.ordered(grade) # 检验一个对象是否为有序对象 #&gt; [1] TRUE 因子在统计分析中可能会用的比较多，但在我自己的实践中用得很少，多数情况下可以将其作为字符型向量使用即可。 我个人会在 ggplot2 的画图中有时会用到有序的因子，用来指定图例和分面的顺序。 1.1.8 日期向量 Date 还有一种常用的数据格式是日期型向量，比如该数据分析团队15名成员的出生日期，类似“1984-02-28”这样的日期。 最常用的日期格式是“yyyy-mm-dd”这样表示的，分别代表年月日。如果单就这样用引号引起来的格式，那应该算字符，需要将其特殊定义为“日期”类或者说转化为日期类，系统才能真正识别其为日期。 将系统能够识别为日期的字符串，强制转为为日期类 as.Date(x) 是最为常见的定义日期的方法。 birthday &lt;- as.Date(c(&quot;1984-02-28&quot;, &quot;1988-09-26&quot;, &quot;1989-07-28&quot;, &quot;1990-01-25&quot;, &quot;1987-04-30&quot;, &quot;1989-12-20&quot;, &quot;1992-06-14&quot;, &quot;1991-07-01&quot;, &quot;1990-08-08&quot;, &quot;1985-05-10&quot;, &quot;1993-04-01&quot;, &quot;1991-03-05&quot;, &quot;1991-09-25&quot;, &quot;1992-01-31&quot;, &quot;1988-02-14&quot;)) print(birthday) # 屏幕上打印的结果，看起来和字符串没什么分别 #&gt; [1] &quot;1984-02-28&quot; &quot;1988-09-26&quot; &quot;1989-07-28&quot; &quot;1990-01-25&quot; &quot;1987-04-30&quot; #&gt; [6] &quot;1989-12-20&quot; &quot;1992-06-14&quot; &quot;1991-07-01&quot; &quot;1990-08-08&quot; &quot;1985-05-10&quot; #&gt; [11] &quot;1993-04-01&quot; &quot;1991-03-05&quot; &quot;1991-09-25&quot; &quot;1992-01-31&quot; &quot;1988-02-14&quot; class(birthday) # 类是 Date #&gt; [1] &quot;Date&quot; is.atomic(birthday) # 是否为向量 #&gt; [1] TRUE class(birthday) == &quot;Date&quot; # 系统没有自带的 is.Date 的函数，可以用此方法来检验 #&gt; [1] TRUE 日期实际上是一种以“日”为单位的时间，是一维单向的向量，只要定义一个点为 0 点，则可用实数来表示。 在 R语言中，系统定义的 0 点是 “1970-01-01”，这与Unix系统中日期的原点保持一致。 实际上起点定义为哪天是无所谓的，因为时间既没有开始也没有结算，只有相对的差值是有意义的。 日期类向量在存储上是以数字来存储的。 日期的差值有意义，故而两个日期值可以相减，得到结果是数值型。从此可以推演出来，两个日期之间不能直接相减，但一个日期与一个数值相加减可以得到另一个有意义的日期值。 as.Date(&quot;1984-01-02&quot;) - as.Date(&quot;1984-01-01&quot;) # 两个日期之间相差的天数 #&gt; Time difference of 1 days as.Date(&quot;1984-01-01&quot;) + 1 # 一个日期加一个天数可以得到另一个日期 #&gt; [1] &quot;1984-01-02&quot; Sys.Date() # 系统函数，返回当前日期，并且为日期型 #&gt; [1] &quot;2016-08-07&quot; Sys.Date() - 1 # 昨天，定期执行脚本的程序常用系统日期函数引申出来的日期作为变量 #&gt; [1] &quot;2016-08-06&quot; 1.2 矩阵 matrix 1.2.1 创建矩阵 矩阵是线性代数上常用的一个概念，是由行和列组成的数据结构。 创建矩阵的方法是通过 matrix() 函数来定义。 # 矩阵的定义函数、参数及参数默认值 matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) # 参数 # data 是原始数据，通常是一个向量 # nrow 是行的数量（行数） # ncol 是列的数量（两书） # byrow 是原始数据（向量）是否按行排列填充，默认 FALSE 则默认不按行排列，即默认按列来排列填充 # dimnames 是维度的名称属性，也就是行和列的名称向量，默认是空（不启用名称属性） 通过向量来创建矩阵，可以看做是将原来一维的向量元素，按照行和列重新排列填充，形成一个新结构的对象。 比如我们对原来15名员工的身高进行重排列变成一个3行5列的矩阵： height &lt;- c(1:15) print(height) # 先将原来15名员工的身高数据显示出来 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 matrix(data = height, nrow = 3, ncol = 5) # 将身高 height 数据转变成3*5的矩阵 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 4 7 10 13 #&gt; [2,] 2 5 8 11 14 #&gt; [3,] 3 6 9 12 15 # 对比height向量和新矩阵数据，两者包含的数据和顺序都一样 # 两者只是排列方式从一维数据，变成了3行5列的二维数据 # 可以将员工每连续3个一组分共5组，或者每隔5个分为一组共3组 数据的排列方式默认是按列填充，但可以更改 m_height &lt;- matrix(data = height, nrow = 3, ncol = 5, byrow = TRUE) # 排列方式更为按行填充 print(m_height) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 2 3 4 5 #&gt; [2,] 6 7 8 9 10 #&gt; [3,] 11 12 13 14 15 1.2.2 矩阵维度 矩阵有一个属性叫做维度(dim)，因为矩阵是二维的，所以矩阵的维度分别是行和列，其值就是行数(nrow)和列数(ncol)组成的包含两个整数的向量。 dim(m_height) #&gt; [1] 3 5 # 第一个数值对应的就是 nrow ，第二个数值对应的就是 ncol # nrow 和 ncol 与 matrix() 矩阵定义中两个参数 nrow 和 ncol 是一一对应的 # nrow 的全称是 Number of Rows # ncol 的全称是 Number of Columns 如果只需要单独获得矩阵的行数或者列数，可则使用 nrow() 和 ncol(). nrow(m_height) # 行数；等价于 dim(m_height)[1] #&gt; [1] 3 ncol(m_height) # 列数；等价于 dim(m_height)[2] #&gt; [1] 5 R语言中每个对象都有其长度，对矩阵而言，length()返回的是矩阵所有元素的个数，并且等于矩阵的行数与列数乘积。 对矩阵而言，长度并不是一个常用的概念；更多的时候，用行数和列数更实用。 length(m_height) # 矩阵的长度表示矩阵的所有元素个数 #&gt; [1] 15 #等价于行数与列数的乘积 nrow(m_height) * ncol(m_height) #&gt; [1] 15 1.2.3 矩阵索引 类似于向量通过[]来索引定位具体的元素，矩阵也沿用此方法，但需要行和列两部分[,]才能索引定位到具体的元素，他们中间用逗号分隔，前者表示行索引，后者表示列索引。 1.2.3.1 位置整数索引 矩阵位置索引的逻辑与向量是一样的，只是索引需要行和列两部分构成。 通过第n行第m列来定位一个具体的单个元素。 通过某几行（向量）、某几列（向量）来定位某些元素。 如果行或者列没有输入（即缺省），则表示不限制具体的行或者列（也就是所有行或者所有列）。 去掉某几行或者莫几列，用对应的负数。 m_height # 原矩阵，打印到屏幕上，后续的索引解决与此对比验证 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 2 3 4 5 #&gt; [2,] 6 7 8 9 10 #&gt; [3,] 11 12 13 14 15 m_height[3,4, drop = FALSE] # 第3行，第4列的元素 #&gt; [,1] #&gt; [1,] 14 m_height[c(1,3),c(2,5)] # 第1和第3行，第2和第5列的元素 #&gt; [,1] [,2] #&gt; [1,] 2 5 #&gt; [2,] 12 15 m_height[c(1,3),] # 第1和第3行，所有列的元素 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 2 3 4 5 #&gt; [2,] 11 12 13 14 15 m_height[,c(2,5)] # 所有行，第2和第5列的元素 #&gt; [,1] [,2] #&gt; [1,] 2 5 #&gt; [2,] 7 10 #&gt; [3,] 12 15 m_height[-2,c(2,5)] # 去除第2行，包含第2和第5列的元素 #&gt; [,1] [,2] #&gt; [1,] 2 5 #&gt; [2,] 12 15 1.2.3.2 逻辑向量索引 类似于向量，矩阵的逻辑索引由行和列对应的两个逻辑向量完成，索引的结果就是对应为TRUE的行和列。 行和列的逻辑向量的长度，分别等于 nrow 和 ncol; 如果逻辑索引向量的长度小于矩阵的行列数则遵循向量循环补齐原则。 m_height # 原矩阵 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 2 3 4 5 #&gt; [2,] 6 7 8 9 10 #&gt; [3,] 11 12 13 14 15 m_height[c(TRUE, FALSE, TRUE), c(TRUE, FALSE, TRUE, FALSE,TRUE)] # 第3行，第4列的元素 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 11 13 15 m_height[c(TRUE, FALSE), c(TRUE, TRUE, FALSE)] # 行列索引的向量长度小于矩阵的行列数，索引的向量遵循循环补齐原则 #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 4 5 #&gt; [2,] 11 12 14 15 # 循环补齐后等价于 m_height[c(TRUE, FALSE, TRUE), c(TRUE, TRUE, FALSE, TRUE, TRUE)] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 4 5 #&gt; [2,] 11 12 14 15 1.2.3.3 逻辑矩阵 通过逻辑表达式可以获得对应的逻辑矩阵。 m_height &gt; 1.7 # 矩阵中哪些元素大于 1.7 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] FALSE TRUE TRUE TRUE TRUE #&gt; [2,] TRUE TRUE TRUE TRUE TRUE #&gt; [3,] TRUE TRUE TRUE TRUE TRUE 通过逻辑矩阵来索引矩阵，得到的是矩阵中对应逻辑为真的元素，是一个向量。 m_height[m_height &gt; 1.7] # 索引大于 1.7 的元素 #&gt; [1] 6 11 2 7 12 3 8 13 4 9 14 5 10 15 1.2.3.4 行列名称索引 在矩阵创建时可以定义行和列的名称，但也可以在创建创建后再定义行和列的名称，这种方法更为实用。 通过rownames() 来定义行名称， colnames()来定义列名称。 rownames(m_height) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # 行名称 colnames(m_height) &lt;- c(&quot;col_1&quot;, &quot;col_2&quot;, &quot;col_3&quot;, &quot;col_4&quot;, &quot;col_5&quot;) # 列名称 print(m_height) #&gt; col_1 col_2 col_3 col_4 col_5 #&gt; A 1 2 3 4 5 #&gt; B 6 7 8 9 10 #&gt; C 11 12 13 14 15 在有了矩阵的名称属性之后，就可以通过行和列的名称属性来索引向量。 m_height[c(&quot;A&quot;, &quot;C&quot;), c(&quot;col_1&quot;, &quot;col_3&quot;, &quot;col_5&quot;)] #&gt; col_1 col_3 col_5 #&gt; A 1 3 5 #&gt; C 11 13 15 1.2.3.5 subset筛选行和列 subset(x, subset, select)函数可以对矩阵使用，筛选符合条件的行和列。 subset 参数是针对要筛选行的条件，是一个逻辑表达式，长度与函数相同。 select 参数是针对要筛选的列条件，可以是位置（列数）的整数向量，也可以是列名（如果有列名称属性的话）的字符向量。 subset(m_height, m_height[,1] &gt; 1.7, 2:4) # 筛选矩阵第1列中大于1.7的行，并提取第2到第4列 #&gt; col_2 col_3 col_4 #&gt; B 7 8 9 #&gt; C 12 13 14 subset(m_height, m_height[,5] &gt; 1.7, c(&quot;col_1&quot;, &quot;col_3&quot;, &quot;col_5&quot;)) # 筛选矩阵第5列中大于1.7的行，并提取名字为&quot;col_1&quot;、&quot;col_3&quot;、&quot;col_5&quot;的列 #&gt; col_1 col_3 col_5 #&gt; A 1 3 5 #&gt; B 6 8 10 #&gt; C 11 13 15 subset(m_height, m_height[,1] &gt; 1.7, m_height[3,] &gt; 1.7) # 筛选矩阵第1列中大于1.7的行，筛选矩阵第3行中大于1.7的列 #&gt; col_1 col_2 col_3 col_4 col_5 #&gt; B 6 7 8 9 10 #&gt; C 11 12 13 14 15 subset函数虽然对矩阵有效，但是并不常用。 1.2.3.6 head/tail筛选首尾行 head() 和 tail()同样适用与矩阵，但是参数 n 表示的是行数；也就是只能筛选行，而不能筛选列。 head(m_height, n = 2) # #&gt; col_1 col_2 col_3 col_4 col_5 #&gt; A 1 2 3 4 5 #&gt; B 6 7 8 9 10 tail(m_height, 2) #&gt; col_1 col_2 col_3 col_4 col_5 #&gt; B 6 7 8 9 10 #&gt; C 11 12 13 14 15 1.2.4 矩阵合并 类似于向量合并是用c()函数，矩阵的合并分为按行合并 rbind() 和 按列合并 cbind()。 按行合并，要求合并的矩阵其列数相同；按列合并，要求合并的矩阵其行数相同；否则会报错。 mc_height &lt;- matrix(data = height, nrow = 3, ncol = 5, byrow = FALSE) # 排列方式更为按列填充 mr_height &lt;- matrix(data = height, nrow = 3, ncol = 5, byrow = TRUE) # 排列方式更为按行填充 print(mc_height) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 4 7 10 13 #&gt; [2,] 2 5 8 11 14 #&gt; [3,] 3 6 9 12 15 print(mr_height) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 2 3 4 5 #&gt; [2,] 6 7 8 9 10 #&gt; [3,] 11 12 13 14 15 rbind(mc_height, mr_height) # 按行合并 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 4 7 10 13 #&gt; [2,] 2 5 8 11 14 #&gt; [3,] 3 6 9 12 15 #&gt; [4,] 1 2 3 4 5 #&gt; [5,] 6 7 8 9 10 #&gt; [6,] 11 12 13 14 15 cbind(mc_height, mr_height) # 按列合并 #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 1 4 7 10 13 1 2 3 4 5 #&gt; [2,] 2 5 8 11 14 6 7 8 9 10 #&gt; [3,] 3 6 9 12 15 11 12 13 14 15 1.2.5 矩阵计算 1.2.5.1 矩阵算术运算 矩阵算术运算与向量类似，对应元素之间的运算。 m_height &lt;- matrix(data = height, nrow = 3, ncol = 5, byrow = TRUE) # 排列方式更为按行填充 m_weight &lt;- matrix(data = weight, nrow = 3, ncol = 5, byrow = TRUE) # 排列方式更为按行填充 m_weight/(m_height^2) # 身高质量指数；对应元素之间做算术运算 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 73.000 17.500 7.556 3.750 2.200 #&gt; [2,] 1.444 1.633 1.172 0.963 0.540 #&gt; [3,] 0.504 0.431 0.331 0.270 0.364 1.2.5.2 矩阵代数运算 矩阵代数运算，有一套自己特有的法则，对应了特殊的运算符号和函数。 print(m_height) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 2 3 4 5 #&gt; [2,] 6 7 8 9 10 #&gt; [3,] 11 12 13 14 15 t(m_height) # 转置，行列转化 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 6 11 #&gt; [2,] 2 7 12 #&gt; [3,] 3 8 13 #&gt; [4,] 4 9 14 #&gt; [5,] 5 10 15 det(m_height[1:3,1:3]) # 求行列式，要求矩阵必须是方阵（正方形矩阵，行数和列数相同） #&gt; [1] 2.22e-15 diag(m_height[1:3,1:3]) # 求矩阵对角线上的元素 #&gt; [1] 1 7 13 线性代数中有非常多的矩阵性质与运算逻辑，这里不一一列出。 1.2.6 矩阵检验与转化 矩阵是一种基于向量上构建的特殊结构，其类属性为 matrix，有一个特殊的维度属性 dim。 检验一个对象是否为矩阵，实际上是验证该对象的类是否为 matrix 及是否具有 dim 属性及 dim 的结果是否为包含连个整数值的向量。 类判断函数，本质上是去校验对象是否符合对应类的定义。 class(m_height) # 显示对象的类，如果是矩阵，就显示为 matrix #&gt; [1] &quot;matrix&quot; is.matrix(m_height) # 对象是否为矩阵 #&gt; [1] TRUE as.matrix(height) # 将对象转化为矩阵 #&gt; [,1] #&gt; [1,] 1 #&gt; [2,] 2 #&gt; [3,] 3 #&gt; [4,] 4 #&gt; [5,] 5 #&gt; [6,] 6 #&gt; [7,] 7 #&gt; [8,] 8 #&gt; [9,] 9 #&gt; [10,] 10 #&gt; [11,] 11 #&gt; [12,] 12 #&gt; [13,] 13 #&gt; [14,] 14 #&gt; [15,] 15 # 这里待转化对象是向量故而结果为列数等于1的矩阵，行数等于向量的长度 1.3 数组 array 数组可以看做是具有多维结构的向量，也就是将原本一维的向量，改变索引结构变为多维表示。 创建数组的方法是通过 array() 函数。 array(data = NA, dim = length(data), dimnames = NULL) # data 是要创建数组的向量，其元素用于构建数组 # dim 为数组的维数向量(为数值型向 量) # dimnames 为由各维的名称构成的向量(为字符型向量) 比如，将 1:30 的向量，按照 2*3*5 的3维结构重新排列为数组，则需要三个位置数字向量才能定位到一个具体的元素。 a &lt;- array(1:30, dim = c(2, 3, 5)) print(a) # 因为该数组是3维结构，而屏幕只能显示2维平面，故而按第3个维度每个维数切片显示 #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 13 15 17 #&gt; [2,] 14 16 18 #&gt; #&gt; , , 4 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 19 21 23 #&gt; [2,] 20 22 24 #&gt; #&gt; , , 5 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 25 27 29 #&gt; [2,] 26 28 30 dim(a) # 维度向量，按顺序分别代表了每个维度的维数 #&gt; [1] 2 3 5 class(a) # 对象的类，如果是数组，则结果为 array #&gt; [1] &quot;array&quot; is.array(a) # 检验对象是否为数组类：判断元素的模式是否相同，判断dim属性是否不为NULL #&gt; [1] TRUE 矩阵是数组在二维结构上的特殊形式。因为矩阵在数学上常用，且有一套矩阵运算和代数上的意义，故而将其独立作为一个类。 数组的索引，类似矩阵，只是维数不同。不同维度的索引，中间用逗号隔开。 a[2, 1, 4] # 第1为第2个切片，第2为的第1个切片，第3为的第4个切片，三个维度联合定位的元素 #&gt; [1] 20 a[1:2, c(2,3), c(1,4,5)] # 第1为第1到2个切片，第2为的第2和第3个切片，第3为的第1第4和第5个切片 #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 3 5 #&gt; [2,] 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 21 23 #&gt; [2,] 22 24 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] #&gt; [1,] 27 29 #&gt; [2,] 28 30 同样可以使用名称索引，如果有名称属性的话。 每个维度的索引也可以使用对应的逻辑向量，其长度与对应的维数相同。 subset()和head()/tail()函数，虽然可以对应用在数据上，但并无实际上的意义。 1.4 数据框 data.frame 数据框是R语言中的一个种表格结构，对应于数据库中的表，类似Excel中的数据表。数据框的是由多个向量构成，每个向量的长度相同。 数据框类似于矩阵，也是一个二维表结构。 在统计学术语中，用行来表示观测(observations)，用列来表示变量(variables)。 类似于数据库系统，行代表数据表的记录(records),列代表数据表的字段(fields)。 针对数据框来说，可能会在不同的情景下使用行、观测、记录这几个名称，他们指代的含义相同；类似的，也可能会在不同的情景下使用列、变量、字段这几个名称，他们指代的也含义相同；并不会再特别说明，怎么适合表达就怎么用。 1.4.1 创建数据框 创建数据框，最简单的方法就是用同名的定义函数 data.frame()，输入每个变量的名称及对应的向量，每个向量的长度相同。 针对示例过程中创建的15名员工信息的向量，将其组合成一个员工信息表： # 当参数较多时，可以换行书写，使得函数结构更为清晰 employee &lt;- data.frame(name = name, height = height, weight = weight, islocal = islocal, gender = gender, grade = grade, birthday = birthday ) print(employee) # 打印数据框时，会在屏幕中显示行的序号和变量名称 #&gt; name height weight islocal gender grade birthday #&gt; 宋子启 宋子启 1.73 73 TRUE 男 中 1984-02-28 #&gt; 张伯仲 张伯仲 1.68 70 TRUE 男 良 1988-09-26 #&gt; 孟轲舆 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 #&gt; 张伟 张伟 1.65 60 TRUE 男 中 1990-01-25 #&gt; 王雪梅 王雪梅 1.66 55 FALSE 女 优 1987-04-30 #&gt; 陈梦妍 陈梦妍 1.62 52 FALSE 女 良 1989-12-20 #&gt; 李元礼 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 杨伯侨 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 #&gt; 赵蜚廉 赵蜚廉 1.78 78 FALSE 男 中 1990-08-08 #&gt; 蒋欣 蒋欣 1.71 54 FALSE 女 良 1985-05-10 #&gt; 沈约度 沈约度 1.72 61 TRUE 男 良 1993-04-01 #&gt; 陈淮阳 陈淮阳 1.69 62 TRUE 男 中 1991-03-05 #&gt; 况天佑 况天佑 1.74 56 FALSE 男 良 1991-09-25 #&gt; 王珍珍 王珍珍 1.70 53 TRUE 女 中 1992-01-31 #&gt; 马小玲 马小玲 1.72 82 TRUE 女 优 1988-02-14 class(employee) # 对象的类，数据框类的名称为 data.frame #&gt; [1] &quot;data.frame&quot; is.data.frame(employee) # 判断一个对象是否为数据框 #&gt; [1] TRUE 变量的名称可以自定义，只要符合R语言对象命名规则即可，上面的自理正好使用和已有向量相同的名字而已。例如下面创建的数据框，变量的名字是任意给定的： df &lt;- data.frame(a = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;), b = c(-0.33, 0.07, -0.40, 0.77, 0.24, 1.07)) print(df) #&gt; a b #&gt; 1 A -0.33 #&gt; 2 B 0.07 #&gt; 3 C -0.40 #&gt; 4 A 0.77 #&gt; 5 A 0.24 #&gt; 6 B 1.07 1.4.2 数据框的属性 数据框是二维的数据表，故而继承了很多矩阵的属性和计算函数。 dim(employee) # 维度属性，行数和列数，也就是观测数和变量数 #&gt; [1] 15 7 nrow(employee) # 行数，也就是观测数，记录数 #&gt; [1] 15 ncol(employee) # 列数，也就是变量数，字段数 #&gt; [1] 7 rownames(employee) # 行名称，如果没有命名则返回行序号向量 #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot; #&gt; [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; #&gt; [15] &quot;马小玲&quot; colnames(employee) # 列名称，返回变量名称；数据框中变量名称是必须指定的 #&gt; [1] &quot;name&quot; &quot;height&quot; &quot;weight&quot; &quot;islocal&quot; &quot;gender&quot; &quot;grade&quot; #&gt; [7] &quot;birthday&quot; row.names(employee) # 行的名称，数据框自己定义的属性，与 rownames 相同 #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; &quot;孟轲舆&quot; &quot;张伟&quot; &quot;王雪梅&quot; &quot;陈梦妍&quot; &quot;李元礼&quot; #&gt; [8] &quot;杨伯侨&quot; &quot;赵蜚廉&quot; &quot;蒋欣&quot; &quot;沈约度&quot; &quot;陈淮阳&quot; &quot;况天佑&quot; &quot;王珍珍&quot; #&gt; [15] &quot;马小玲&quot; names(employee) # 变量名称，数据框自己定义的属性，与 colnames 相同 #&gt; [1] &quot;name&quot; &quot;height&quot; &quot;weight&quot; &quot;islocal&quot; &quot;gender&quot; &quot;grade&quot; #&gt; [7] &quot;birthday&quot; # 数据框中变量名称更为重要，故而直接用 names() 函数返回，更为便捷 1.4.2.1 数据框的合并 df_1 &lt;- data.frame(V1 = 1:2, V2 = c(&quot;A&quot;,&quot;B&quot;)) ; print(df_1) # 两个语句之间可以用`;`隔开就可以写在一行中 #&gt; V1 V2 #&gt; 1 1 A #&gt; 2 2 B print(df_2 &lt;- data.frame(V1 = 3:3, V2 = c(&quot;C&quot;,&quot;D&quot;))) # 赋值语句结束后将该表达式的结果打印出来 #&gt; V1 V2 #&gt; 1 3 C #&gt; 2 3 D rbind(df_1, df_2) #&gt; V1 V2 #&gt; 1 1 A #&gt; 2 2 B #&gt; 3 3 C #&gt; 4 3 D df_3 &lt;- data.frame(V3 = c(95, 88), V4 = c(&quot;Actor&quot;, &quot;Farmer&quot;)) print(df_3) # 这才是比较合适的书写规范，一行语句执行一个命令；以上两种写法均可，但不推荐 #&gt; V3 V4 #&gt; 1 95 Actor #&gt; 2 88 Farmer cbind(df_1, df_3) #&gt; V1 V2 V3 V4 #&gt; 1 1 A 95 Actor #&gt; 2 2 B 88 Farmer 1.4.3 数据结构与数据汇总 str()可以快速显示一个对象的结构。 对数据框来说， str()返回多个信息，包含：类名称；观测个数和变量个数；每个变量也就是向量的名称，及其类型，和前10个值；如果每个变量是因子向量，则返回其水平，及水平映射的整数值。 str()能显示整个数据框的数据结构，非常实用。 str(employee) #&gt; &#39;data.frame&#39;: 15 obs. of 7 variables: #&gt; $ name : Factor w/ 15 levels &quot;沈约度&quot;,&quot;陈淮阳&quot;,..: 9 13 8 14 10 3 6 12 15 4 ... #&gt; $ height : num 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 ... #&gt; $ weight : num 73 70 68 60 55 52 80 75 78 54 ... #&gt; $ islocal : logi TRUE TRUE FALSE TRUE FALSE FALSE ... #&gt; $ gender : Factor w/ 2 levels &quot;男&quot;,&quot;女&quot;: 1 1 1 1 2 2 1 1 1 2 ... #&gt; $ grade : Ord.factor w/ 4 levels &quot;差&quot;&lt;&quot;中&quot;&lt;&quot;良&quot;&lt;..: 2 3 3 2 4 3 2 4 2 3 ... #&gt; $ birthday: Date, format: &quot;1984-02-28&quot; &quot;1988-09-26&quot; ... summary()函数，可以快速显示一个对象的汇总结果。 对数据框来说，返回每个变量的汇总结果： 对因子向量，返回每个因子的水平及计数结果（个数）；只显示前6个，剩下的显示为(Other) 对数值向量，返回5分位数及平均值，分别是 Min. :最小值 1st Qu.:四分之一分位数 Median :中位数 Mean :算术平均值 3rd Qu.:四分之三分位数 Max. :最大值 对逻辑向量，返回其模式(mode), TRUE 和 FALSE 的个数，缺失值的个数 对字符向量，返回每个唯一字符的个数，只显示前6个，剩下的显示为(Other) 查看返回数据的结果汇总，就能对数据的概括有个大致的了解。 summary(employee) #&gt; name height weight islocal gender grade #&gt; 沈约度 :1 Min. :1.62 Min. :52.0 Mode :logical 男:10 差:0 #&gt; 陈淮阳 :1 1st Qu.:1.69 1st Qu.:55.5 FALSE:7 女: 5 中:6 #&gt; 陈梦妍 :1 Median :1.72 Median :62.0 TRUE :8 良:6 #&gt; 蒋欣 :1 Mean :1.71 Mean :65.3 NA&#39;s :0 优:3 #&gt; 况天佑 :1 3rd Qu.:1.74 3rd Qu.:74.0 #&gt; 李元礼 :1 Max. :1.81 Max. :82.0 #&gt; (Other):9 #&gt; birthday #&gt; Min. :1984-02-28 #&gt; 1st Qu.:1988-06-05 #&gt; Median :1990-01-25 #&gt; Mean :1989-09-27 #&gt; 3rd Qu.:1991-08-13 #&gt; Max. :1993-04-01 #&gt; 1.4.4 访问数据框变量 一个数据框可能包含多个变量（向量），有时需要单独提取某个变量，使用$特殊的符号来访问，由数据框$变量名构成。 employee$name # 访问 employee 数据框中名为 name 的变量；结果就是一个向量 #&gt; [1] 宋子启 张伯仲 孟轲舆 张伟 王雪梅 陈梦妍 李元礼 杨伯侨 赵蜚廉 蒋欣 #&gt; [11] 沈约度 陈淮阳 况天佑 王珍珍 马小玲 #&gt; 15 Levels: 沈约度 陈淮阳 陈梦妍 蒋欣 况天佑 李元礼 马小玲 ... 赵蜚廉 employee$height #&gt; [1] 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 1.72 1.69 1.74 1.70 #&gt; [15] 1.72 employee$weight #&gt; [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 employee$islocal #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE #&gt; [12] TRUE FALSE TRUE TRUE employee$gender #&gt; [1] 男 男 男 男 女 女 男 男 男 女 男 男 男 女 女 #&gt; Levels: 男 女 增加一个变量，只需要将一个等长的向量赋值给数据框$新变量名即可 employee$bmi &lt;- employee$weight/(employee$height^2) str(employee) #&gt; &#39;data.frame&#39;: 15 obs. of 8 variables: #&gt; $ name : Factor w/ 15 levels &quot;沈约度&quot;,&quot;陈淮阳&quot;,..: 9 13 8 14 10 3 6 12 15 4 ... #&gt; $ height : num 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 ... #&gt; $ weight : num 73 70 68 60 55 52 80 75 78 54 ... #&gt; $ islocal : logi TRUE TRUE FALSE TRUE FALSE FALSE ... #&gt; $ gender : Factor w/ 2 levels &quot;男&quot;,&quot;女&quot;: 1 1 1 1 2 2 1 1 1 2 ... #&gt; $ grade : Ord.factor w/ 4 levels &quot;差&quot;&lt;&quot;中&quot;&lt;&quot;良&quot;&lt;..: 2 3 3 2 4 3 2 4 2 3 ... #&gt; $ birthday: Date, format: &quot;1984-02-28&quot; &quot;1988-09-26&quot; ... #&gt; $ bmi : num 24.4 24.8 23 22 20 ... 1.4.5 数据框的长度与类型 数据框可以由多个不同的向量组成，故而其 长度length() 和 模式mode() 属性没太大的意义。 length(employee) #&gt; [1] 8 增加一个变量，只需要将一个等长的向量赋值给数据框$新变量名即可 employee$bmi &lt;- employee$weight/(employee$height^2) str(employee) #&gt; &#39;data.frame&#39;: 15 obs. of 8 variables: #&gt; $ name : Factor w/ 15 levels &quot;沈约度&quot;,&quot;陈淮阳&quot;,..: 9 13 8 14 10 3 6 12 15 4 ... #&gt; $ height : num 1.73 1.68 1.72 1.65 1.66 1.62 1.81 1.74 1.78 1.71 ... #&gt; $ weight : num 73 70 68 60 55 52 80 75 78 54 ... #&gt; $ islocal : logi TRUE TRUE FALSE TRUE FALSE FALSE ... #&gt; $ gender : Factor w/ 2 levels &quot;男&quot;,&quot;女&quot;: 1 1 1 1 2 2 1 1 1 2 ... #&gt; $ grade : Ord.factor w/ 4 levels &quot;差&quot;&lt;&quot;中&quot;&lt;&quot;良&quot;&lt;..: 2 3 3 2 4 3 2 4 2 3 ... #&gt; $ birthday: Date, format: &quot;1984-02-28&quot; &quot;1988-09-26&quot; ... #&gt; $ bmi : num 24.4 24.8 23 22 20 ... 1.4.6 数据框索引与筛选 类似与矩阵，数据框也用类似的方法索引和筛选子集，包括整数位置、名称属性、逻辑向量索引，但最常用的是subset()和head()函数。 subset()常用是因为可以复合多个逻辑表达式条件。 head()常用是因为通常数据表的行数很大，直接打印所有的行会使控制台刷屏，多数时候只需看数据库的前几行即可，结合 str() 查看数据结构、summary() 查看数据汇总情况。 # 前3名员工的身高和体重 employee[1:3, c(&quot;height&quot;, &quot;weight&quot;)] #&gt; height weight #&gt; 宋子启 1.73 73 #&gt; 张伯仲 1.68 70 #&gt; 孟轲舆 1.72 68 # employee$islocal 是逻辑向量，第2个维度就是变量，不限制条件就是选中所有变量 employee[employee$islocal,] #&gt; name height weight islocal gender grade birthday bmi #&gt; 宋子启 宋子启 1.73 73 TRUE 男 中 1984-02-28 24.4 #&gt; 张伯仲 张伯仲 1.68 70 TRUE 男 良 1988-09-26 24.8 #&gt; 张伟 张伟 1.65 60 TRUE 男 中 1990-01-25 22.0 #&gt; 杨伯侨 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 24.8 #&gt; 沈约度 沈约度 1.72 61 TRUE 男 良 1993-04-01 20.6 #&gt; 陈淮阳 陈淮阳 1.69 62 TRUE 男 中 1991-03-05 21.7 #&gt; 王珍珍 王珍珍 1.70 53 TRUE 女 中 1992-01-31 18.3 #&gt; 马小玲 马小玲 1.72 82 TRUE 女 优 1988-02-14 27.7 # select 参数不选择就是所有变量 subset(employee, employee$height &gt; 1.7) #&gt; name height weight islocal gender grade birthday bmi #&gt; 宋子启 宋子启 1.73 73 TRUE 男 中 1984-02-28 24.4 #&gt; 孟轲舆 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 23.0 #&gt; 李元礼 李元礼 1.81 80 FALSE 男 中 1992-06-14 24.4 #&gt; 杨伯侨 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 24.8 #&gt; 赵蜚廉 赵蜚廉 1.78 78 FALSE 男 中 1990-08-08 24.6 #&gt; 蒋欣 蒋欣 1.71 54 FALSE 女 良 1985-05-10 18.5 #&gt; 沈约度 沈约度 1.72 61 TRUE 男 良 1993-04-01 20.6 #&gt; 况天佑 况天佑 1.74 56 FALSE 男 良 1991-09-25 18.5 #&gt; 马小玲 马小玲 1.72 82 TRUE 女 优 1988-02-14 27.7 # subset 逻辑表达式可以由多个逻辑表达式的逻辑运算结果构成，所以可以有多个条件的筛选 subset(employee, employee$height &gt; 1.7 &amp; employee$weight &gt; 65, select = c(&quot;name&quot;, &quot;gender&quot;, &quot;bmi&quot;)) #&gt; name gender bmi #&gt; 宋子启 宋子启 男 24.4 #&gt; 孟轲舆 孟轲舆 男 23.0 #&gt; 李元礼 李元礼 男 24.4 #&gt; 杨伯侨 杨伯侨 男 24.8 #&gt; 赵蜚廉 赵蜚廉 男 24.6 #&gt; 马小玲 马小玲 女 27.7 head(employee) # 显示前6个元素 #&gt; name height weight islocal gender grade birthday bmi #&gt; 宋子启 宋子启 1.73 73 TRUE 男 中 1984-02-28 24.4 #&gt; 张伯仲 张伯仲 1.68 70 TRUE 男 良 1988-09-26 24.8 #&gt; 孟轲舆 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 23.0 #&gt; 张伟 张伟 1.65 60 TRUE 男 中 1990-01-25 22.0 #&gt; 王雪梅 王雪梅 1.66 55 FALSE 女 优 1987-04-30 20.0 #&gt; 陈梦妍 陈梦妍 1.62 52 FALSE 女 良 1989-12-20 19.8 1.5 列表 list 列表是R语言基本数据结构中最为复杂的一种，主要作为两种用途： 第一：作为非结构化存储的数据类型，类似于Jason，并且可以同时包含不同的类型的数据，比如字符和数值； 第二：作为对象的集合，可以包含多个不同数据对象，比如向量、矩阵、数据库，甚至还可以包含图像、表达式、函数等对象。 1.5.1 多种类型的复合数据 比如在员工信息表中，我们将每个员工的信息存储在一个对象中，由于该信息包含了多种不同的模式，故而不能用向量。 e_list &lt;- list(name = &quot;宋子启&quot;, height = 1.73, weight = 73, islocal = TRUE) print(e_list) #&gt; $name #&gt; [1] &quot;宋子启&quot; #&gt; #&gt; $height #&gt; [1] 1.73 #&gt; #&gt; $weight #&gt; [1] 73 #&gt; #&gt; $islocal #&gt; [1] TRUE 在这个列表 e_list 中，list()函数定义了一个列表，有多个对象构成（又称为组件），每个对象代表中包含了一个对应的信息。 虽然看起来和向量的定义有些类似，但最大的区别是列表中各元素的模式是可以不同的。 将这个 e_list 的信息扩充，每个对象可以包含多个信息，且每个对象中的元素个数相同的话，则可以转为数据框。 实际上，数据框是列表的特殊形式。 e_list &lt;- list(name = c(&quot;宋子启&quot;,&quot;张伯仲&quot;), height = c(1.73, 1.68), weight = c(73, 70), islocal = c(TRUE, TRUE)) print(e_list) #&gt; $name #&gt; [1] &quot;宋子启&quot; &quot;张伯仲&quot; #&gt; #&gt; $height #&gt; [1] 1.73 1.68 #&gt; #&gt; $weight #&gt; [1] 73 70 #&gt; #&gt; $islocal #&gt; [1] TRUE TRUE # 直接转为数据框 as.data.frame(e_list) #&gt; name height weight islocal #&gt; 1 宋子启 1.73 73 TRUE #&gt; 2 张伯仲 1.68 70 TRUE 1.5.2 非结构化的数据存储方式 列表还有一个特点是可以嵌套列表对象，则可使得非结构化的数据仓储变得可能。 在员工信息表中，可以存储技能特长这类数据。由于具体的技能数量是未确定的，且是多选项问题，可以用非结构化的数据格式来存储较为方便（实际上非结构化数据是可以转化为结构化数据的，但如果非结构关系较为负责，这种转化的过程和记录各结构化之间关系的问题反而可能更负责，还不如直接存储非结构化关系更为方便）。 e001 &lt;- list(name = &quot;宋子启&quot;, height = 1.73, weight = 73, islocal = TRUE, skills = c(&quot;SQL&quot;, &quot;R&quot;)) e002 &lt;- list(name = &quot;张伯仲&quot;, height = 1.68, weight = 70, islocal = TRUE, skills = c(&quot;SQL&quot;, &quot;R&quot;, &quot;Python&quot;)) # list 中包含 list e_list &lt;- list(e001 = e001, e002 = e002) # 查看 list 的结构使用 str() 更为方便 str(e_list) #&gt; List of 2 #&gt; $ e001:List of 5 #&gt; ..$ name : chr &quot;宋子启&quot; #&gt; ..$ height : num 1.73 #&gt; ..$ weight : num 73 #&gt; ..$ islocal: logi TRUE #&gt; ..$ skills : chr [1:2] &quot;SQL&quot; &quot;R&quot; #&gt; $ e002:List of 5 #&gt; ..$ name : chr &quot;张伯仲&quot; #&gt; ..$ height : num 1.68 #&gt; ..$ weight : num 70 #&gt; ..$ islocal: logi TRUE #&gt; ..$ skills : chr [1:3] &quot;SQL&quot; &quot;R&quot; &quot;Python&quot; 1.5.3 对象的集合 列表作为对象的集合，最为典型的场景是线性回归模型的结果存储在列表中。 # 以自变量为 height 因变量为 weight 的简单线性回归模型 lm(y ~ x) # 将模型的结果存储在 m_list 这个对象中 m_list &lt;- lm(weight ~ height) # 线性回归模型会返回非常多的信息，会存在不同对象中，故而使用 list 来存储相对合适 summary(m_list) #&gt; #&gt; Call: #&gt; lm(formula = weight ~ height) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -13.400 -4.190 0.506 4.310 15.484 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) -181.5 76.7 -2.37 0.0341 * #&gt; height 144.2 44.8 3.22 0.0067 ** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 8.13 on 13 degrees of freedom #&gt; Multiple R-squared: 0.444, Adjusted R-squared: 0.401 #&gt; F-statistic: 10.4 on 1 and 13 DF, p-value: 0.0067 在日常自定义函数中，如果函数返回的结果包含多种数据（多个对象），将其存储在一个列表中也是最为方便的。 1.5.4 列表子集筛选 如果列表对象是有名称属性的，也就是各个组件是有标签的，则可以直接使用 $ 对象的名字提取该子对象。 将列表作为对象的集合多数属于这种情况，每个子对象通常都有名字便于提取。 # 查看对象的名称属性 names(m_list) #&gt; [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; #&gt; [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; #&gt; [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; # 查看回归模型的残差 m_list$residuals #&gt; 1 2 3 4 5 6 7 8 #&gt; 5.0416 9.2515 1.4836 3.5774 -2.8645 -0.0966 0.5059 5.5997 #&gt; 9 10 11 12 13 14 15 #&gt; 2.8318 -11.0744 -5.5164 -0.1905 -13.4003 -10.6324 15.4836 names(e_list) #&gt; [1] &quot;e001&quot; &quot;e002&quot; e_list$e002 #&gt; $name #&gt; [1] &quot;张伯仲&quot; #&gt; #&gt; $height #&gt; [1] 1.68 #&gt; #&gt; $weight #&gt; [1] 70 #&gt; #&gt; $islocal #&gt; [1] TRUE #&gt; #&gt; $skills #&gt; [1] &quot;SQL&quot; &quot;R&quot; &quot;Python&quot; 如果对象没有名称属性，可使用位置索引，与向量类使用[]类似，但子对象的提取需要使用[[]]。 m_list[[2]] # 等价于 m_list$residuals 因为 residuals 是第2个子对象 #&gt; 1 2 3 4 5 6 7 8 #&gt; 5.0416 9.2515 1.4836 3.5774 -2.8645 -0.0966 0.5059 5.5997 #&gt; 9 10 11 12 13 14 15 #&gt; 2.8318 -11.0744 -5.5164 -0.1905 -13.4003 -10.6324 15.4836 []通常用来提取子集，返回的结果与与对象具有相同的类型，是一种子结构。该操作符可以用在列表上，但返回的是列表结构。 m_list[2] #&gt; $residuals #&gt; 1 2 3 4 5 6 7 8 #&gt; 5.0416 9.2515 1.4836 3.5774 -2.8645 -0.0966 0.5059 5.5997 #&gt; 9 10 11 12 13 14 15 #&gt; 2.8318 -11.0744 -5.5164 -0.1905 -13.4003 -10.6324 15.4836 str(m_list[[2]]) # 返回第二个子对象，是一个向量 #&gt; Named num [1:15] 5.04 9.25 1.48 3.58 -2.86 ... #&gt; - attr(*, &quot;names&quot;)= chr [1:15] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... str(m_list[2]) # 返回原列表的第二个子列表，还是一个列表 #&gt; List of 1 #&gt; $ residuals: Named num [1:15] 5.04 9.25 1.48 3.58 -2.86 ... #&gt; ..- attr(*, &quot;names&quot;)= chr [1:15] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... 在[[]]提取子对象后，如果是向量，还可以继续使用[]来提取子元素来定位结果的元素；如果是矩阵或数据框还可以用[,]定位子集，如果是列表，依然可以用 [[]] 来继续提取子集。 m_list[[2]][2] # 第二个子对象的第二个元素 #&gt; 2 #&gt; 9.25 str(m_list[[2]]) # 返回第二个子对象，是一个向量 #&gt; Named num [1:15] 5.04 9.25 1.48 3.58 -2.86 ... #&gt; - attr(*, &quot;names&quot;)= chr [1:15] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... str(m_list[2]) # 返回原列表的第二个子列表，还是一个列表 #&gt; List of 1 #&gt; $ residuals: Named num [1:15] 5.04 9.25 1.48 3.58 -2.86 ... #&gt; ..- attr(*, &quot;names&quot;)= chr [1:15] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... 1.6 特殊值 Special Values ``` 为确保所有数据都能被正确识别、计算或统计等，R语言定义了一些特殊值数据： NULL：空值，什么都没有 NA：Not Available 的缩写，更多是时候被称作 Missing value，也就是缺失值；有数据值，但具体是什么却不知道 NaN：Not a Number 的缩写，表示非数值 Inf：positive infinity，正无穷大 -Inf：negative infinity，负无穷大 前两者可以包含在任意类型的向量中，后三者是数值型向量。 1.6.1 空值 NULL NULL 代表一个空对象，通常作为表达式的返回结果（也就是什么都不返回)，或者作为函数中未定义的参数值。 as.null(x) 是转化函数，is.null(x) 是判断函数。 NULL 作为向量中的值时，表示什么都没有，在打印过程中的不不会被显示，都不占用一个元素位置。 # 只打印值 1 print(c(1, NULL)) #&gt; [1] 1 # 合并后长度只有 1 length(c(1, NULL)) #&gt; [1] 1 1.6.2 缺失值 NA 缺失值是R语言中非常重要的概念，且有专门的缺失值处理方法，这里只介绍几本的概念。 缺失值 NA 与 SQL 中的 NULL 概念相似，表示应该有值，但目前缺失。 NA 作为向量中的值，可以包含在任意类型中。不同与 NULL，缺失值是占位一个向量元素的。 NA 作为一个独立的向量时，其类型为逻辑型。 # NA 作为一个值会被打印出来 print(c(1, NA)) #&gt; [1] 1 NA # NA 作为一个向量的元素是包含在长度中的 length(c(&quot;test&quot;, NA)) #&gt; [1] 2 # NA 的模式（类型）为逻辑型 mode(NA) #&gt; [1] &quot;logical&quot; 将向量中的某些值改变为NA，等价于将 NA 赋值给指定的元素。 # 将向量中的某些值改变为NA test_weight &lt;- weight test_weight[c(3,9)] &lt;- NA print(test_weight) #&gt; [1] 73 70 NA 60 55 52 80 75 NA 54 61 62 56 53 82 在提取向量子集时，如果索引下标超过向量长度，则返回的结果为 NA。 test_weight &lt;- weight test_weight[c(31,99)] #&gt; [1] NA NA print(test_weight) #&gt; [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 在给向量赋值时，如果赋值的元素超过原本向量的长度，则中间未定义赋值的元素，其值为NA。 用这种向量赋值方式，可以预先定义数据结构，或者增加向量长度。 test_weight &lt;- weight test_weight[c(30)] &lt;- NA print(test_weight) #&gt; [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 NA NA NA NA NA NA NA NA #&gt; [24] NA NA NA NA NA NA NA test_weight &lt;- weight test_weight[c(30)] &lt;- 66 print(test_weight) #&gt; [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 NA NA NA NA NA NA NA NA #&gt; [24] NA NA NA NA NA NA 66 is.na(x) 函数用来判断向量中的每个元素是否为 NA，返回长度相同的逻辑向量。 结合元素子集筛选函数可以提取非缺失值的部分，或者将缺失值替换为某个值或者表达式结果。 # 提取非缺失值子集 test_weight &lt;- weight test_weight[c(30)] &lt;- 66 test_weight[!is.na(test_weight)] #&gt; [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 66 # 将缺失值替换为非缺失值的均值 test_weight &lt;- weight test_weight[c(30)] &lt;- 66 test_weight[!is.na(test_weight)] #&gt; [1] 73 70 68 60 55 52 80 75 78 54 61 62 56 53 82 66 test_weight[is.na(test_weight)] &lt;- mean(test_weight, na.rm = TRUE) print(test_weight) #&gt; [1] 73.0 70.0 68.0 60.0 55.0 52.0 80.0 75.0 78.0 54.0 61.0 62.0 56.0 53.0 #&gt; [15] 82.0 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 65.3 #&gt; [29] 65.3 66.0 anyNA(x) 函数用来判断对象中是否包含 NA 元素，返回一个逻辑值。 test_weight &lt;- weight test_weight[c(30)] &lt;- 66 # 返回是否包含缺失值 anyNA(test_weight) #&gt; [1] TRUE 关于缺失值的处理函数中，经常会遇一个名为 na.rm 的参数，用来选择是否排除缺失值。 比如在求均值的函数 mean() 中，参数 na.rm 默认为 FALSE：如果数值型向量包含 NA，则其均值返回 NA；如果 na.rm 设置为 TRUE 则会在求均值中忽略 NA，得到数值结果的平均值。 # 函数中是否移除缺失值 test_weight &lt;- weight test_weight[c(30)] &lt;- 66 mean(test_weight) # 默认 na.rm = FALSE #&gt; [1] NA mean(test_weight, na.rm = TRUE) #&gt; [1] 65.3 还有一个常用的缺失值处理函数 na.omit()，用来移除包含缺失值所在的行记录，多用在 data.frame 中。 # 函数中是否移除缺失值 test_employee &lt;- employee test_employee$height[6] &lt;- NA test_employee$weight[8] &lt;- NA # test_employee 中第6和8行包含有NA元素，先这两行都被移除 na.omit(test_employee) # 结果中不含任何包含 NA 元素的行 #&gt; name height weight islocal gender grade birthday #&gt; 宋子启 宋子启 1.73 73 TRUE 男 中 1984-02-28 #&gt; 张伯仲 张伯仲 1.68 70 TRUE 男 良 1988-09-26 #&gt; 孟轲舆 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 #&gt; 张伟 张伟 1.65 60 TRUE 男 中 1990-01-25 #&gt; 王雪梅 王雪梅 1.66 55 FALSE 女 优 1987-04-30 #&gt; 李元礼 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 赵蜚廉 赵蜚廉 1.78 78 FALSE 男 中 1990-08-08 #&gt; 蒋欣 蒋欣 1.71 54 FALSE 女 良 1985-05-10 #&gt; 沈约度 沈约度 1.72 61 TRUE 男 良 1993-04-01 #&gt; 陈淮阳 陈淮阳 1.69 62 TRUE 男 中 1991-03-05 #&gt; 况天佑 况天佑 1.74 56 FALSE 男 良 1991-09-25 #&gt; 王珍珍 王珍珍 1.70 53 TRUE 女 中 1992-01-31 #&gt; 马小玲 马小玲 1.72 82 TRUE 女 优 1988-02-14 # 函数中是否移除缺失值 test_weight &lt;- weight test_weight[c(30)] &lt;- 66 mean(test_weight) # 默认 na.rm = FALSE #&gt; [1] NA mean(test_weight, na.rm = TRUE) #&gt; [1] 65.3 1.6.3 非数值 NaN 在数值计算过程中，可能会产生无意义的值，为了使得计算不中断，在 R 中预先定义了 NaN 的特殊值，作为无效数值的表示。 比如 0/0 是没有意义的；还有初等函数中自变量的值不在定义域范围内则函数结果也是无意义的，比如对数函数中自变量小于0也是没有意义的。 当结果产生 NaN 时，控制台会打印一条警告信息“产生了NaNs”（不会中断运行过程，实际上是运行成功后才会显示该消息）。 # 典型会产生 NaN 的情况 0/0 # 分子和分母均为 0 的结果无意义 #&gt; [1] NaN log(-1) # 对数函数在定义域 &gt; 0 的情况下才有意义 #&gt; Warning in log(-1): 产生了NaNs #&gt; [1] NaN is.nan(x) 是判断非数值的函数，返回对象中元素是否为 NaN 的等长逻辑向量。 is.nan(c(0/0, log(-1))) #&gt; Warning in log(-1): 产生了NaNs #&gt; [1] TRUE TRUE NaN 是一种特殊的 NA 值，可以用 is.na() 来验证。 is.na(c(0/0, log(-1))) #&gt; Warning in log(-1): 产生了NaNs #&gt; [1] TRUE TRUE 1.6.4 无穷大/无穷小 Inf /-Inf 数学中的无穷大和无穷小是一种特殊的数值，不同与 NaN，他们是有意义的数值，故而有特殊的符号表示， Inf 为正无穷大，-Inf 为负无穷小。 # 典型的无穷大和无穷小数值 1/0 # 分子为正，分母为 0 数值为无穷大 #&gt; [1] Inf -1/0 #分子为负，分母为 0 数值为无穷小 #&gt; [1] -Inf Inf 是 infinite 的缩写，表示无穷尽的，无限大的。判读一个数值是否为无穷大或者无穷小，使用 is.infinite() 函数。 # 1/0 和 -1/0 是 Inf 和 -Inf # 0/0 是 NaN # 1, -1 是正常数值 is.infinite(c(1/0, -1/0, 0/0, 1, -1)) #&gt; [1] TRUE TRUE FALSE FALSE FALSE 相对地，判断数值有限大小的函数，就是 is.finite()。 # 1/0 和 -1/0 是 Inf 和 -Inf # 0/0 是 NaN # 1, -1 是正常数值 is.finite(c(1/0, -1/0, 0/0, 1, -1)) #&gt; [1] FALSE FALSE FALSE TRUE TRUE Inf 和 -Inf，既不是 NaN，也不是 NA。 # 1/0 和 -1/0 是 Inf 和 -Inf # 0/0 是 NaN # 1, -1 是正常数值 is.nan(c(1/0, -1/0, 0/0, 1, -1)) #&gt; [1] FALSE FALSE TRUE FALSE FALSE is.na(c(1/0, -1/0, 0/0, 1, -1)) #&gt; [1] FALSE FALSE TRUE FALSE FALSE 既然 Inf 和 -Inf 分别是正无穷大和负无穷小，则说明两者的大小在比较的时候是不同的。 # 无穷大的结果 大于 无穷小的结果 (1/0) &gt; (-1/0) #&gt; [1] TRUE # 无穷大 大于 无穷小 Inf &gt; -Inf #&gt; [1] TRUE # 无穷大 大于 所有有限数值 Inf &gt; 0 #&gt; [1] TRUE # 一个无穷大并不会大于另一个无穷大 (2/0) &gt; (1/0) #&gt; [1] FALSE # 两个无穷大的大小比较结果是相等 (2/0) == (1/0) #&gt; [1] TRUE # 无穷大与非数值比较结果为 NA # NaN 也是 NA # 任何值与 NA 比大小的结果都是 NA Inf &gt; NaN #&gt; [1] NA # 无穷大与 NA 比大小的结果都是 NA Inf &gt; NA #&gt; [1] NA is.infinite() 函数只是判断一个数值是否为无穷尽的，至于该数值是无穷大还是无穷大，则并未给出对应的函数。 可以结合 Inf 和 -Inf 的大小比较来辅助判断。 # 自定义一个函数 # 先判断对象 x 是否为无穷尽的数值 # 如果是则将 x 值与 0 做比较， # x &gt; 0 为 TRUE，则 x 为无穷大 # x &gt; 0 为 FALSE，则 x 为无穷小 # 如果 x 不是无穷尽的数值，则返回结果为 NA is.infinite.positive &lt;- function(x) { # 输入的形式参数为 x ifelse(is.infinite(x), x &gt; 0, NA) # 返回该表达式的结果 } # 在函数中输入 x 的值即返回该函数的计算结果 is.infinite.positive(1/0) #&gt; [1] TRUE is.infinite.positive(-1/0) #&gt; [1] FALSE is.infinite.positive(0/0) #&gt; [1] NA 1.7 数据模式、类型与对象的类辨析 1.7.1 数据模式、类型 1.7.2 对象的类 1.7.3 基本数据结构的联系与区别 1.7.3.1 向量与矩阵和数组 1.7.3.2 向量与列表 1.7.3.3 列表与数据框 1.7.3.4 矩阵和数据框 1.7.3.5 列表与向量 "],
["section-2.html", "第2章 函数式编程 2.1 基础包中的函数 2.2 编写自定义函数 2.3 扩展函数包", " 第2章 函数式编程 2.1 基础包中的函数 2.1.1 基本数学函数 2.1.2 描述统计函数 2.1.3 字符处理函数 2.2 编写自定义函数 2.3 扩展函数包 "],
["section-3.html", "第3章 数据处理 3.1 magrittr 管道操作符：流式编程 3.2 dplyr 数据表处理语法", " 第3章 数据处理 在本章中我们将讲解如何利用特定扩展包，高效处理数据集。 3.1 magrittr 管道操作符：流式编程 3.1.1 magrittr介绍 magrittr包被定义为一个高效的管道操作工具包，通过管道的连接方式，让数据或表达式的传递更高效，使用操作符%&gt;%，可以直接把数据传递给下一个函数调用。 magrittr包有两个主要目标: 第一是减少代码开发时间，提高代码的可读性和维护性 第二是让你的代码更短 magrittr包，主要定义了4个管道操作符，分别是: %&gt;%, Forward pipe operator，向右操作符，主操作符 将左边的结果传递给右边的函数作为第一个参数值，其结果可以继续又右边传递 %T&gt;%，Tee operations，向左操作符 与%&gt;%的区别是其结果不能向右传递，继续向右传递的是%T&gt;%左边的结果，%T&gt;%通常用来输出图形、打印结果到屏幕或者输出到文件，然后继续%&gt;%操作 %$% ，Pipe with exposition of variables，解释操作符 通常左边是数据框，%$% 之后右边函数可直接通过使用该数据框的变量 %&lt;&gt;%，Compound assignment pipe operations，复合赋值管道操作符 只能出现在最左边的对象之后，用于在一长串处理管道操作之后直接赋值到最左边的对象上 magrittr的项目主页： https://github.com/smbache/magrittr 3.1.2 管道操作符 3.1.2.1 %&gt;% 和 %T% install.packages(&quot;magrittr&quot;) # 第一次使用前先从 CRAN 安装 magrittr 包 library(magrittr) # 使用前载入 magrittr 包 %&gt;% 主管道操作符的基本用法：x 是一个数据对象, f(data, p = value) 是一个函数 x %&gt;% f() 等价于 f(x) x %&gt;% f(p = value) 等价于 f(data = x, p = value) x %&gt;% f(p = .) 等价于 f(data = x, p = x) ；这里的 . 代表从左边传递过来的对象（没有名字故而使用.替代）[这个说法不太严谨，暂且先这么用] x %&gt;% f1() %&gt;% f2() 等价于 f2(f1(x)) %T&gt;% 操作符的基本用法： x %T&gt;% f() 等价于 f(x) x %T&gt;% f1() %&gt;% f2() 等价于 f1(x); f2(x) 如果只是做一次管道传递是没必要定义这样特殊操作符的，通常情况下是一连串的管道操作才其优势。 这里对员工数据集中出生日期向量做操作案例，目的是筛选出在1900年后出生的员工，并计算这些人出生年份的中位数。 这里先将出生日期按照字符串处理，而不是用日期函数来直接提取，使得多几个操作步骤，以显示管道操作符的便捷性。 birthday %&gt;% as.character() %&gt;% # 先将 Date 类转化为字符型 substr(1, 4) %&gt;% # 提取字符串，从第1个字符到第4个字符，年份 as.integer() %&gt;% # 将出生年份字符转化为整数型 set_names(name) %&gt;% # 将员工名字赋值给生年份的结果向量 subset(. &gt;= 1990) %T&gt;% # 使用 . 代表从左边传递过来的对象 print() %&gt;% # %T&gt;% 之后操作结果不作为下一个操作符的结果 median # 当一个函数没有其他参数时可省略函数的括号 #&gt; 张伟 李元礼 杨伯侨 赵蜚廉 沈约度 陈淮阳 况天佑 王珍珍 #&gt; 1990 1992 1991 1990 1993 1991 1991 1992 #&gt; [1] 1991 其中 set_names 是 magrittr 中的函数，set_names(x, name) 等价于 names(x) &lt;- name。这里将其定位为f(x, p = value) 的形式，便于在管道符操作中使用函数。 上面出生年份的示例，如果不使用管道操作符，有两种传统写法，分别如下： 分步顺序操作，使用临时变量 temp &lt;- as.character(birthday) temp &lt;- substr(temp, 1, 4) temp &lt;- as.integer(temp) names(temp) &lt;- name # 或者 magrittr 中的函数 set_names(temp, name) temp &lt;- subset(temp, temp &gt;= 1990) print(temp) #&gt; 张伟 李元礼 杨伯侨 赵蜚廉 沈约度 陈淮阳 况天佑 王珍珍 #&gt; 1990 1992 1991 1990 1993 1991 1991 1992 median(temp) #&gt; [1] 1991 函数嵌套 temp &lt;- set_names(as.integer(substr(as.character(birthday), 1, 4)), name) temp &lt;- subset(temp, temp &gt;= 1990) # subset 中用到了两次同一个变量，这里用一个中间临时变量还方便些 print(temp) # print 和 meian 两次不同的输出，还得使用一次中间变量 #&gt; 张伟 李元礼 杨伯侨 赵蜚廉 沈约度 陈淮阳 况天佑 王珍珍 #&gt; 1990 1992 1991 1990 1993 1991 1991 1992 median(temp) #&gt; [1] 1991 分步操作中需要多次书写同一个变量名称，较为繁琐；过多的函数嵌套时，不便于理解操作步骤且容易输错。 管道操作符使得程序逻辑更为通顺便于理解，减少中间结果的重复输入。 代码最佳书写风格是，在每个管道操作符后换行，便于执行选择前半部分操作执行结果，或者注释中间操作。 3.1.2.2 %$% 管道操作符对所有数据对象有效，而不仅仅是向量，我们来看数据框计算的例子。 使用 employee 数据集，做 subset 子集筛选，和直接用其中的变量作图和计算 employee %&gt;% subset(gender == &quot;男&quot;) %$% #筛选男性 plot(weight, height) # %$% 之后可直接使用data.frame中的variables，做散点图 employee %&gt;% subset(islocal = TRUE) %$% #筛选本地 cor(weight, height) # %$% 之后可直接使用数据框中的变量，计算相关系数 #&gt; [1] 0.666 3.1.2.3 %&lt;&gt;% 有时候我们需要将管道操作后最后的结果赋值给最初的对象以更新其结果，这时可以用%&lt;&gt;%操作符。 建议，在最初的时候还是使用%&gt;%操作符，在确认最终的结果正确后需要该写初始对象，则再修改第一个操作符为%&lt;&gt;%。 temp &lt;- seq(1:10) print(temp) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 temp %&lt;&gt;% # 将管道操作最后一个结果返回给最开始的 temp sqrt %&gt;% log # 最后的结果重新复制给 temp；等价于 log 之后的结果 -&gt; temp print(temp) # 验证 temp 是否已经改变 #&gt; [1] 0.000 0.347 0.549 0.693 0.805 0.896 0.973 1.040 1.099 1.151 3.1.3 运算符号的通用函数 在管道操作中间过程，有时会用到一些算术符号运算，在 maggrittr 中做一些常用的运算符号定义为通用函数，使其可以像普通函数那样调用，且支持直接使用操作符，但需要用特殊符号将其标记。 # 将身高数值从单位为米转化为厘米，并包含“厘米”转化字符串输出 height %&gt;% `*` (100) %&gt;% paste0(sep = &quot;厘米&quot;) #&gt; [1] &quot;173厘米&quot; &quot;168厘米&quot; &quot;172厘米&quot; &quot;165厘米&quot; &quot;166厘米&quot; &quot;162厘米&quot; &quot;181厘米&quot; #&gt; [8] &quot;174厘米&quot; &quot;178厘米&quot; &quot;171厘米&quot; &quot;172厘米&quot; &quot;169厘米&quot; &quot;174厘米&quot; &quot;170厘米&quot; #&gt; [15] &quot;172厘米&quot; height %&gt;% multiply_by(100) %&gt;% paste0(sep = &quot;厘米&quot;) # multiply_by 是 `*` 乘法符号的函数写法 #&gt; [1] &quot;173厘米&quot; &quot;168厘米&quot; &quot;172厘米&quot; &quot;165厘米&quot; &quot;166厘米&quot; &quot;162厘米&quot; &quot;181厘米&quot; #&gt; [8] &quot;174厘米&quot; &quot;178厘米&quot; &quot;171厘米&quot; &quot;172厘米&quot; &quot;169厘米&quot; &quot;174厘米&quot; &quot;170厘米&quot; #&gt; [15] &quot;172厘米&quot; 通用函数和操作符号一栏表 函数 操作符 extract [ multiply_by * extract2 [[ inset [&lt;- inset2 [[&lt;- use_series $ add + subtract - multiply_by * raise_to_power ^ multiply_by_matrix %*% divide_by / divide_by_int %/% mod %% is_in %in% and &amp; or | equals == is_greater_than &gt; is_weakly_greater_than &gt;= is_less_than &lt; is_weakly_less_than &lt;= not (n'est pas) ! set_colnames colnames&lt;- set_rownames rownames&lt;- set_names names&lt;- 在后续章节的综合数据处理过程中，将会大量使用到 magrittr 中管道操作符，有需要特别指出的时候会做做进一步说明。 3.2 dplyr 数据表处理语法 3.2.1 dplyr介绍 dplyr包是从plyr演化而来，关注处理 data.frame 等对象的表格形式数据。该包有三个主要目标： 简化表格数据的预处理过程 用C++重写了计算底层以提高性能 统一了接口函数，使得处理 data.frame 等对象和数据库中的表对象保持一致 前两个目标和在一起就是提高处理 data.frame 的效率；至于数据库处理留存专门的读写数据库章节中再讲解。 dplyr的项目主页： https://github.com/hadley/dplyr 3.2.2 单表操作的 6 个主函数 dplyr提供了6个主函数来处理 data.frame。 我们可以用数据库SQL查询语句的关键字来做类比。 数据库中单表操作的主要语法是 select from where group by order by dplyr 中主操作函数是 select() 列筛选，类似于 SQL 中的 select filter() 行筛选，类似于 SQL 中的 where arrage() 排序，类似于 SQL 中的 order by group_by 分组，类似于 SQL 中的 group by summarise() 汇总，类似于 SQL 中的 aggregate Functions muate() 变形, 类似于 SQL 中的 analytic functions / window funtions RStudio 官网上有一个关于 dplyr 的速查表，是最佳学习资源，强烈推荐！ Data Wrangling Cheat Sheet https://www.rstudio.com/resources/cheatsheets/ install.packages(&quot;dplyr&quot;) # 第一次使用之前先从 CRAN 中安装 library(dplyr) # 使用之前载入 # 特别要说明的是，dplyr 已经预置了管道操作符 %&gt;% # 可直接使用 管道操作符 %&gt;% 而不用再单独载入 magrittr 3.2.2.1 列筛选 select 在 base 中 data.frame 的子集筛选通常使用 subset() 包含了筛选行的条件 subset 以及列筛选条件 select。 在 dplyr 中 参数 subset 逻辑表达式拆分出来成为 filter() 函数，而参数 select 也被拆分出来独立出来成为 select() 函数。 独立拆分使得行列筛选功能变得更为强大，也使其方便在管道操作符、分步流式编程中更为方便。 select() 函数用来做 data.frame 的变量筛选，最基本地，支持整数位置索引。 #&gt; height weight #&gt; 宋子启 1.73 73 #&gt; 张伯仲 1.68 70 #&gt; 孟轲舆 1.72 68 在 dplyr 中，主函数的第一个参数对象都是 data.frame ，其后的参数即可直接使用 variables 。 employee %&gt;% select(height, weight) %&gt;% head(3) #&gt; height weight #&gt; 宋子启 1.73 73 #&gt; 张伯仲 1.68 70 #&gt; 孟轲舆 1.72 68 # 从某个变量A到变量B中所有变量（包含A和B） employee %&gt;% select(height:birthday) %&gt;% head(3) #&gt; height weight islocal gender grade birthday #&gt; 宋子启 1.73 73 TRUE 男 中 1984-02-28 #&gt; 张伯仲 1.68 70 TRUE 男 良 1988-09-26 #&gt; 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 在 select 中，编写了辅助选取变量名的匹配函数，用来高效完成有规则的变量筛选。 # 包含字符 ght 的变量（普通匹配） employee %&gt;% select(contains(&quot;ght&quot;)) %&gt;% head(3) #&gt; height weight #&gt; 宋子启 1.73 73 #&gt; 张伯仲 1.68 70 #&gt; 孟轲舆 1.72 68 # 以字符 de 结尾的变量 (正则匹配) employee %&gt;% select(matches(&quot;.*de$&quot;)) %&gt;% head(3) #&gt; grade #&gt; 宋子启 中 #&gt; 张伯仲 良 #&gt; 孟轲舆 良 3.2.2.2 行筛选 filter filter()中的筛选，与 subset() 中的 subset 逻辑表达式最大的不同是，filter()中多个逻辑条件可以用逗号隔开（他们之间的逻辑是 &amp; 的关系）, 类似于 SQL 中 where 各个条件中间用 and 隔开，使得书写更为自然。 employee %&gt;% filter(height &gt;= 1.75) #&gt; name height weight islocal gender grade birthday #&gt; 1 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 2 赵蜚廉 1.78 78 FALSE 男 中 1990-08-08 # 多个 &amp; 的逻辑表达式，可用逗号隔开 employee %&gt;% filter(height &gt;= 1.70, gender == &quot;女&quot;) #&gt; name height weight islocal gender grade birthday #&gt; 1 蒋欣 1.71 54 FALSE 女 良 1985-05-10 #&gt; 2 王珍珍 1.70 53 TRUE 女 中 1992-01-31 #&gt; 3 马小玲 1.72 82 TRUE 女 优 1988-02-14 行筛选还有一些函数来实现类似于SQL中的用法，对于连接的数据库表对象，可直接使用 dplyr 函数，而不用通过 SQL 语法。 3.2.2.2.1 结果排重 排重函数 distinct() 类似于 SQL 中的 disttinct 关键字，用来排除有重复记录的行 distinct(employee) #&gt; name height weight islocal gender grade birthday #&gt; 1 宋子启 1.73 73 TRUE 男 中 1984-02-28 #&gt; 2 张伯仲 1.68 70 TRUE 男 良 1988-09-26 #&gt; 3 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 #&gt; 4 张伟 1.65 60 TRUE 男 中 1990-01-25 #&gt; 5 王雪梅 1.66 55 FALSE 女 优 1987-04-30 #&gt; 6 陈梦妍 1.62 52 FALSE 女 良 1989-12-20 #&gt; 7 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 8 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 #&gt; 9 赵蜚廉 1.78 78 FALSE 男 中 1990-08-08 #&gt; 10 蒋欣 1.71 54 FALSE 女 良 1985-05-10 #&gt; 11 沈约度 1.72 61 TRUE 男 良 1993-04-01 #&gt; 12 陈淮阳 1.69 62 TRUE 男 中 1991-03-05 #&gt; 13 况天佑 1.74 56 FALSE 男 良 1991-09-25 #&gt; 14 王珍珍 1.70 53 TRUE 女 中 1992-01-31 #&gt; 15 马小玲 1.72 82 TRUE 女 优 1988-02-14 3.2.2.2.2 Top / Bottom top_n()函数，用来筛选 data.frame 的前 N 行记录，类似于 SQL Server 中的 top 、 MySQL 中 limit 、Oracle 中的 rownum 关键字。 top_n(x, n, wt)用法 参数 x 是继承 data.frame 的数据表对象，如果 x 是包含分组信息的表对象 ，则 top_n 就是返回每个分组中的 n 行结果；没有分组的 data.frame 是分为一组的特殊情况 参数 n 是返回结果的行数，可以是正整数，返回正序的前 n 行；如果是负数，返回倒序的后 n 行 参数 wt 是排序的权重字段，是可选项，如果没有指定，则以最后一个字段为排序；这里的排序只是用来做筛选条件的排序，但不会将结果重新排列 # 筛选前3行，按照最后一个字段排序的前3个 employee %&gt;% top_n(3) #&gt; Selecting by birthday #&gt; name height weight islocal gender grade birthday #&gt; 1 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 2 沈约度 1.72 61 TRUE 男 良 1993-04-01 #&gt; 3 王珍珍 1.70 53 TRUE 女 中 1992-01-31 # 指定 wt ，等到年龄最小的3名员工(birthday的数值最大) employee %&gt;% top_n(3, wt = birthday) #&gt; name height weight islocal gender grade birthday #&gt; 1 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 2 沈约度 1.72 61 TRUE 男 良 1993-04-01 #&gt; 3 王珍珍 1.70 53 TRUE 女 中 1992-01-31 # 筛选得到体重最轻的3名员工 employee %&gt;% top_n(-3, wt = weight) #&gt; name height weight islocal gender grade birthday #&gt; 1 陈梦妍 1.62 52 FALSE 女 良 1989-12-20 #&gt; 2 蒋欣 1.71 54 FALSE 女 良 1985-05-10 #&gt; 3 王珍珍 1.70 53 TRUE 女 中 1992-01-31 3.2.2.2.3 随机排序筛选，随机抽样 随机抽样有两个行数，sample_n() 是指定抽出 n 行，sample_frac() 是指定抽取总行数的百分比。 还有其他两个参数可选，一个是 replace 为抽样是否放回，默认是否；另一个参数是 weight 指定权重，默认不指定。 同样地，如果 data.frame 是分组的数据表，则按每组返回随机抽样结果。 随机抽样，类似于 SQL Server 中的 order by newid()、MySQL中 ordery rand()、Oracle 中 order by dbms_random.value() 并且还要加上筛选 n 个结果的条件。 # 指定 wt ，等到年龄最小的3名员工(birthday的数值最大) employee %&gt;% sample_n(3) #&gt; name height weight islocal gender grade birthday #&gt; 张伯仲 张伯仲 1.68 70 TRUE 男 良 1988-09-26 #&gt; 陈淮阳 陈淮阳 1.69 62 TRUE 男 中 1991-03-05 #&gt; 杨伯侨 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 # 总行数 15 * 抽样比例 0.3 = 4.5 再向下取整得到 4 employee %&gt;% sample_frac(0.3) #&gt; name height weight islocal gender grade birthday #&gt; 孟轲舆 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 #&gt; 宋子启 宋子启 1.73 73 TRUE 男 中 1984-02-28 #&gt; 李元礼 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 陈梦妍 陈梦妍 1.62 52 FALSE 女 良 1989-12-20 3.2.2.2.4 指定行范围 切片函数 slice() 用来筛选 data.frame 的行，等价于 data.frame[n:m,]，使用的是行号的整数位置筛选。 类似于，在 SQL 中先获得行号 row_number ，然后在 where 中指定 row_number 的范围。 employee %&gt;% slice(3:8) # 不使用 %&gt;% 则写为 slice(employee, 3:8) # 等价于 employee[3:8,] #&gt; name height weight islocal gender grade birthday #&gt; 1 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 #&gt; 2 张伟 1.65 60 TRUE 男 中 1990-01-25 #&gt; 3 王雪梅 1.66 55 FALSE 女 优 1987-04-30 #&gt; 4 陈梦妍 1.62 52 FALSE 女 良 1989-12-20 #&gt; 5 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 6 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 3.2.2.3 结果重排序 arrange 在 base 包中对 data.frame 做排序需要使用 order() 函数，并使用 [,] 做索引筛选； 用 dplyr 包中的 arrage() 函数语法上更为简洁，且可以使用 %&gt;% 作为管道操作的中间过程。 employee[order(employee$gender, -employee$height),] %&gt;% head(3) # base 中的方式 #&gt; name height weight islocal gender grade birthday #&gt; 李元礼 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 赵蜚廉 赵蜚廉 1.78 78 FALSE 男 中 1990-08-08 #&gt; 杨伯侨 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 employee %&gt;% arrange(gender, desc(height)) %&gt;% head(3) # dplyr 中 arrange 函数更为简洁 #&gt; name height weight islocal gender grade birthday #&gt; 1 李元礼 1.81 80 FALSE 男 中 1992-06-14 #&gt; 2 赵蜚廉 1.78 78 FALSE 男 中 1990-08-08 #&gt; 3 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 3.2.2.4 增加一个新列 mutate mutate() 函数在 dplyr 中用来增加新列，直接利用 data.frame 中的变量名即可创建；与 base 中的 transform() 函数类似，主要不同在于在创建多个新列时，可直接使用刚创建的新变量。 # base 中的 employee$bmi = employee$weight / (employee$height ^ 2) 方法有同样效果 # 但没有 mutate 简洁，且可使用管道操作符，流式编程 employee %&gt;% # 增加 bmi 新变量，可直接使用 weight 和 height 运算 mutate(bmi = weight / (height ^ 2)) %&gt;% head(3) #&gt; name height weight islocal gender grade birthday bmi #&gt; 1 宋子启 1.73 73 TRUE 男 中 1984-02-28 24.4 #&gt; 2 张伯仲 1.68 70 TRUE 男 良 1988-09-26 24.8 #&gt; 3 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 23.0 employee %&gt;% mutate(bmi = weight / (height ^ 2), log_bmi = log(bmi)) %&gt;% # 可直接使用新变量运算 head(3) #&gt; name height weight islocal gender grade birthday bmi log_bmi #&gt; 1 宋子启 1.73 73 TRUE 男 中 1984-02-28 24.4 3.19 #&gt; 2 张伯仲 1.68 70 TRUE 男 良 1988-09-26 24.8 3.21 #&gt; 3 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 23.0 3.13 mutate() 函数是新增列，并且保持了原有列不变；如果只想要保留新增的列，可使用 transmute()函数，则结果只有新增加的列。 employee %&gt;% # 增加 bmi 新变量，可直接使用 weight 和 height 运算 transmute(bmi = weight / (height ^ 2)) %&gt;% head(3) #&gt; bmi #&gt; 1 24.4 #&gt; 2 24.8 #&gt; 3 23.0 mutate() 中可直接使用 window funtion，比如 dplyr 中定义的 row_number() 函数，以及 base 中定义的 cumsum() 累计求和函数。 employee %&gt;% # 给定员工信息表 employee select(name, height, weight) %&gt;% # 筛选 name, height, weight 三列 # 给员工编号，计算体重的累计求和 mutate(employee_no = row_number(), cumsum_weight = cumsum(weight)) %&gt;% head(3) # 显示前3个结果 #&gt; name height weight employee_no cumsum_weight #&gt; 1 宋子启 1.73 73 1 73 #&gt; 2 张伯仲 1.68 70 2 143 #&gt; 3 孟轲舆 1.72 68 3 211 如果想要将某个 window funtion 应用在 data.frame 的所有列上，则可使用 mutate(x, funs(window_function))。其中 windwos functions 可以有多个函数，中间用逗号隔开。 新变量的名字，有应用变量的名称，加上函数名称，中间用下划线组成。 employee %&gt;% # 给定员工信息表 employee select(height, weight) %&gt;% # 筛选 height 和 weight 两个变量 slice(3:5) %&gt;% # 筛选第3到5行 # 对每个变量应用 cumsum 累计求和 与 cumprod 累计乘积函数 mutate_each(funs(cumsum, cumprod)) #&gt; height weight height_cumsum weight_cumsum height_cumprod weight_cumprod #&gt; 1 1.72 68 1.72 68 1.72 68 #&gt; 2 1.65 60 3.37 128 2.84 4080 #&gt; 3 1.66 55 5.03 183 4.71 224400 3.2.2.5 汇总 summarise 汇总就是将 data.frame 通过计算后汇总一个值或者说是一行结果。汇总函数(summary funtion)有很多，比如计数、求和、均值等，类似于 SQL 中的 aggregate funtion 。 employee %&gt;% summarise(employee_num = n(), # 计数，有多少记录数，n() 函数没有参数 avg_height = mean(height), # 平均身高 total_weight = sum(weight), # 总体重 unique_grade = n_distinct(grade) # 排重计数，统计有多少个不同的等级 ) #&gt; employee_num avg_height total_weight unique_grade #&gt; 1 15 1.71 979 3 类似于变形的 mutate_each()，汇总也有一个 summarise_each() 函数，用法相似。 employee %&gt;% # 给定员工信息表 employee select(height, weight) %&gt;% # 筛选 height 和 weight 两个变量 # 对每个变量应用 mean 求平均值 和 与 sum 求总和 summarise_each(funs(mean, sum)) #&gt; height_mean weight_mean height_sum weight_sum #&gt; 1 1.71 65.3 25.7 979 3.2.2.6 分组 group_by 分组统计是数据表处理中非常重要的环节，在 dplyr 中，在对一个 data.frame 对象 group_by 后，该 data.frame 对象就会多了一个 group_by 的属性，对象的类也会变成 tbl ，是一个继承了 data.frame 的对象。 可以对一个 data.frame 只执行 group_by 操作，而不去汇总或者变形等计算。 # 按照 gender 和 islocal 分组 employee %&gt;% group_by(gender, islocal) #&gt; Source: local data frame [15 x 7] #&gt; Groups: gender, islocal [4] #&gt; #&gt; name height weight islocal gender grade birthday #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;date&gt; #&gt; 1 宋子启 1.73 73 TRUE 男 中 1984-02-28 #&gt; 2 张伯仲 1.68 70 TRUE 男 良 1988-09-26 #&gt; 3 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 #&gt; 4 张伟 1.65 60 TRUE 男 中 1990-01-25 #&gt; 5 王雪梅 1.66 55 FALSE 女 优 1987-04-30 #&gt; 6 陈梦妍 1.62 52 FALSE 女 良 1989-12-20 #&gt; .. ... ... ... ... ... ... ... # 打印结果的时候可以看到，多出了一个信息 # Groups: gender, islocal # 表示按照 gender, islocal 这两个字段分组 如果想要解除一个分组的 data.frame ，可以使用 ungroup() 函数。 当然，如果分组之后什么都不做，那分组没什么意义。 分组后通常使用 summarise function 或者 window function 两类函数操作；分组字段默认会被保留；分组后的排序如果不指定，则按照先分组字段顺序排序，其他字段不做排序，除非指定结果排序。 summarise function 是将多行结果计算后返回一行结果；分组后组别有多少个，则返回多少个结果。 employee %&gt;% group_by(gender) %&gt;% # 按性别分组 summarise(num = n(), # 统计每个组别的记录数 avg_height = mean(height), # 统计每个组别的平均身高 max_weight = max(weight) # 统计每个组别的最大体重 ) %&gt;% arrange(desc(num)) # 按照 num 倒序排列 #&gt; Source: local data frame [2 x 4] #&gt; #&gt; gender num avg_height max_weight #&gt; &lt;fctr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 男 10 1.73 80 #&gt; 2 女 5 1.68 82 多个字段联合分组 # 如果分组有多个字段，则汇总结果是按照联合分组后统计的结果 employee %&gt;% group_by(gender, grade) %&gt;% # 按性别和成绩等级分组 summarise(num = n(), avg_height = mean(height), max_weight = max(weight) ) %&gt;% arrange(gender, desc(grade)) # grade 是有序因子，“优”大于“差”，desc(grade) 指定从优到差排列 #&gt; Source: local data frame [6 x 5] #&gt; Groups: gender [2] #&gt; #&gt; gender grade num avg_height max_weight #&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 男 优 1 1.74 75 #&gt; 2 男 良 4 1.71 70 #&gt; 3 男 中 5 1.73 80 #&gt; 4 女 优 2 1.69 82 #&gt; 5 女 良 2 1.67 54 #&gt; 6 女 中 1 1.70 53 SQL中在 group by 之后可以增加 having 字句用来对分组结果进行过滤。但在 dplyr 中没有对应 having 关键字的函数，因为该过程实际就是对分组汇总结果的条件筛选，直接增加一次 filter 的处理过程即可。 # 如果分组有多个字段，则汇总结果是按照联合分组后统计的结果 employee %&gt;% group_by(gender, grade) %&gt;% # 按性别和成绩等级分组 summarise(num = n(), avg_height = mean(height), max_weight = max(weight) ) %&gt;% filter(num &gt;= 2) %&gt;% # 筛选至少包含两名员工的分组，类似 having 关键字 arrange(gender, desc(grade)) # grade 是有序因子，“优”大于“差”，desc(grade) 指定从优到差排列 #&gt; Source: local data frame [4 x 5] #&gt; Groups: gender [2] #&gt; #&gt; gender grade num avg_height max_weight #&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 男 良 4 1.71 70 #&gt; 2 男 中 5 1.73 80 #&gt; 3 女 优 2 1.69 82 #&gt; 4 女 良 2 1.67 54 window function 是将多行结果计算后返回同样行数的结果；分组后组别有多少个，则返回每个分组的行数相同的结果，所有分组行数的总和还是等于总数据表的行数。 employee %&gt;% group_by(gender) %&gt;% arrange(gender, salary) %&gt;% # 先按分组 gender 排序, 再按 salary 排序 # 按分组 gender ，累计求和 salary，其中 salary 以按从小到大排序 mutate(cumsum_salary = cumsum(salary)) #&gt; Source: local data frame [15 x 10] #&gt; Groups: gender [2] #&gt; #&gt; name height weight islocal gender grade birthday salary title #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 张伟 1.65 60 TRUE 男 中 1990-01-25 7000 工程师 #&gt; 2 李元礼 1.81 80 FALSE 男 中 1992-06-14 7200 分析师 #&gt; 3 杨伯侨 1.74 75 TRUE 男 优 1991-07-01 7800 工程师 #&gt; 4 张伯仲 1.68 70 TRUE 男 良 1988-09-26 8000 分析师 #&gt; 5 况天佑 1.74 56 FALSE 男 良 1991-09-25 8800 分析师 #&gt; 6 孟轲舆 1.72 68 FALSE 男 良 1989-07-28 9000 工程师 #&gt; .. ... ... ... ... ... ... ... ... ... #&gt; Variables not shown: cumsum_salary &lt;dbl&gt;. 多个字段联合分组 employee %&gt;% group_by(gender, title) %&gt;% # 先按第一个分组 gender 排序, 在按第二个分组 title排序，最后 salary 倒序 arrange(gender, title, desc(salary)) %&gt;% # 按分组 gender 和 title ，累计求和 salary，其中 salary 以按从大到小排序 mutate(cumsum_salary = cumsum(salary)) #&gt; Source: local data frame [15 x 10] #&gt; Groups: gender, title [4] #&gt; #&gt; name height weight islocal gender grade birthday salary title #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 况天佑 1.74 56 FALSE 男 良 1991-09-25 8800 分析师 #&gt; 2 张伯仲 1.68 70 TRUE 男 良 1988-09-26 8000 分析师 #&gt; 3 李元礼 1.81 80 FALSE 男 中 1992-06-14 7200 分析师 #&gt; 4 宋子启 1.73 73 TRUE 男 中 1984-02-28 12000 工程师 #&gt; 5 沈约度 1.72 61 TRUE 男 良 1993-04-01 10000 工程师 #&gt; 6 陈淮阳 1.69 62 TRUE 男 中 1991-03-05 9600 工程师 #&gt; .. ... ... ... ... ... ... ... ... ... #&gt; Variables not shown: cumsum_salary &lt;dbl&gt;. 3.2.3 summary &amp; window function 在 dplyr 中 Summary Function 是汇总函数，在 SQL 中也被成为 Aggregate Function，聚合函数。 在 dplyr 中 Window Function 是窗口函数，在 SQL 中被称为 Analytic Function，分析函数。 Summary Function 是将多行结果计算后汇总为一行，Window Function 是将多行结果计算后返回相同行数的结果。这个定义更倾向于对数据表来说。 实际上，在 R 中使用对向量的计算描述更为合适。 Summary Function 是那些在对向量计算后只返回一个值的结果，比如 sum() 函数。 这里的待计算的向量不一定是单个向量对象，可以是包含多几个向量运算的结果的向量，比如 max(log(x) - nchar(y))，其中 max() 就是 Summary Function。 Window Function 是那些在对向量计算后返回相同长度的向量的函数，也就是向量化函数，包括初等数学函数，比如 log(), cumsum(), 也包括 字符串函数nchar()，甚至条件判断函数 ifelse()。重要的是不是函数的类型，是返回的结果。 当对一个向量作用某个函数之后，返回结果是一个值（长度为一的向量）就是 Summary Function；返回的结果是与作用向量长度相同的向量，则是 Window Function。 汇总函数和窗口函数，都可以在分组下使用；当然也可以在不分组的情况下使用，这时可以看做是只分为一组的特殊情况。 3.2.3.1 summary function 汇总函数 在 base 中很多的统计函数都是 summarise function 有很多，比如 employee %&gt;% group_by(title) %&gt;% summarise(min_height = min(height), # min 最小值 max_weight = max(weight), # max 最大值 avg_bmi = mean(weight / height ^2), # mean 均值 median_salary = median(salary), # meadin 中位数 var_salary = var(salary), # var 方差 sd_salary = sd(salary), # sd 标准差 iqr_salary = IQR(salary) # IQR 四分位距 ) #&gt; Source: local data frame [2 x 8] #&gt; #&gt; title min_height max_weight avg_bmi median_salary var_salary sd_salary #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 分析师 1.62 80 20.6 8800 3606190 1899 #&gt; 2 工程师 1.65 82 23.6 9300 2297143 1516 #&gt; Variables not shown: iqr_salary &lt;dbl&gt;. 在 dplyr 中定义了一些常用的位置和计数相关的函数，比如 employee %&gt;% group_by(gender) %&gt;% summarise(first_height = first(height), # 第一个值 last_weight = last(weight, order_by = grade), # 最后一个值，按照 grade 排序 nth_birthday = nth(birthday, n = 3), # 第 n 个值 employee_num = n(), # 计数，可以使用 leghth(variable) 来替换，但需要一个 variable 参数 distinct_grade = n_distinct(grade) # 排重计数 ) #&gt; Source: local data frame [2 x 6] #&gt; #&gt; gender first_height last_weight nth_birthday employee_num distinct_grade #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 男 1.73 75 1989-07-28 10 3 #&gt; 2 女 1.66 82 1985-05-10 5 3 # 其中 first, last , nth 都是有可选参数 order_by # 注意，n() 是没有参数的 汇总函数是可以自定义的。 所有通过对多个元素的向量，计算后返回一个值的函数，都是 summarise function 。 # 定义函数 eldest_age_calc &lt;- function(x) { library(lubridate) # 载入 lubridate ，利用 year() 函数 max_age &lt;- max(year(Sys.Date()) - year(x)) return(max_age) } employee %&gt;% group_by(gender) %&gt;% summarise(eldest_age = eldest_age_calc(birthday), # 应用自定义函数 # 计算过程可以用表达式书写，如果过程不太长不影响阅读，则直接书写 # lubridate::year 是使用 lubridate 包中 year() 而不用加载这个函数包 youngest_age = min(lubridate::year(Sys.Date()) - lubridate::year(birthday)), best_grade = first(grade, order_by = desc(grade)) # 分组中最佳成绩（有序因子按优到差排序） ) #&gt; Source: local data frame [2 x 4] #&gt; #&gt; gender eldest_age youngest_age best_grade #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fctr&gt; #&gt; 1 男 32 23 优 #&gt; 2 女 31 24 优 3.2.3.2 window function 窗口函数 在数据分析的SQL取数过程中，window function / analytic function 使用的相对少一些，算是比较高级的用法，就是那些带有 over() 关键字的函数，还经常与分组和排序配合使用。 -- Analytic Function Syntax ANALYTIC_FUNCTION( argument-1, ..., argument-n ) OVER( [ window_partition_clause ] [ window_order_clause ]) 在 dplyr 中介绍文档中，作者还专门书写了一个章节的内容来讲 window functions。 窗口函数相对来说比较高级的分析函数，用法也相比复杂，这里要重点讲解。 对数据分析师来说，从 SQL 转到 R 来做进一步的数据处理语言，那是因为在 R 语言中，相对 SQL 来说更容易编写处理分析函数。 在数据库系统中，分析师并非做系统开发，对 SQL 进一步编程能力相对匮乏，且多数时候也没有编写自定义函数的权限。 窗口函数，实际上就是用来处理列的函数，并且返回长度相同的列，多数情况下就是多数据做预处理。 窗口函数在 dplyr 的介绍文档中，是不包括哪些与行处理没有关系的普通函数的，比如 nchar() 统计字符个数等函数，可以说是狭义上的窗口函数。 下面重点介绍的就是狭义的窗口函数，这和 SQL 中的分析函数是想对应的，它们处理的都是相同的问题，只是处于在 R 和 SQL 两个不同的环境中。 因为普通函数太普通了，这里都没有介绍的必要。 从宏观角度来看，窗口函数可以分为三大类： 秩序和排序函数: row_number(), min_rank(), dense_rank(), cume_dist(), percent_rank(), ntile() 偏移函数: lead() 和 lag() 累积的汇总函数:cumsum(), cummean(), cummin(), cummax(),cumprod(), cumall(), cumany(), pmin(), pmax() 3.2.3.2.1 Ranking functions 让我们先来构造一个简单的向量，应用排序函数，来辨析它们之间的区别。 x &lt;- c(1, 1, 2, 2, 2) row_number(x) #&gt; [1] 1 2 3 4 5 ## row_number 排序并对每个只从小到达给定一个自增的序号，即使大小顺序相同 min_rank(x) #&gt; [1] 1 1 3 3 3 ## min_rank 排序，对大小相同的值给相同的排名值，跳过中间的序号，从后面开始排次 ## 如果有两个并列第一，则排名中没有第二，之后从第三开始 x &lt;- c(1, 3, 2, 2, 2) #&gt; [1] 1 1 2 2 2 ## dense_rank 排序，对大小相同的值给相同的排名值，不跳过中间的序号，继续排名次 ## 排名可以有并列，但名次序号不跳过 row_number 更多的是排序的序号，类似于元素排序后是几个序号（数据表则为行号）。 rank 更多的是排名次（秩），可以有并列名次（相同排名）； min 和 dense 的区别在于名次是有间隔的还是连续不间隔的。 默认排序都是从小到大、从低到高，正序排列；如果要倒序，则可使用 desc()，用法与 arrage() 函数中一致。 employee %&gt;% group_by(gender) %&gt;% mutate(employee_age = row_number(birthday), # 年龄从大到小 rank_salary = min_rank(desc(salary)) # 薪资从高到低 ) %&gt;% arrange(gender, employee_age, desc(rank_salary)) %&gt;% select(-(2:4)) #&gt; Source: local data frame [15 x 8] #&gt; Groups: gender [2] #&gt; #&gt; name gender grade birthday salary title employee_age rank_salary #&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 宋子启 男 中 1984-02-28 12000 工程师 1 1 #&gt; 2 张伯仲 男 良 1988-09-26 8000 分析师 2 7 #&gt; 3 孟轲舆 男 良 1989-07-28 9000 工程师 3 4 #&gt; 4 张伟 男 中 1990-01-25 7000 工程师 4 10 #&gt; 5 赵蜚廉 男 中 1990-08-08 9000 工程师 5 4 #&gt; 6 陈淮阳 男 中 1991-03-05 9600 工程师 6 3 #&gt; .. ... ... ... ... ... ... ... ... 3.2.3.3 lag &amp; lead lag() 和lead() 函数，分别获取当前行所对应的前/后若干个偏移量的值，分别有四个参数： x 是列（变量） n 是偏移量（offset），为正整数，默认为 1，也就是前一个值，或者后一个值 default 是超出记录窗口时的默认值，默认是 NA order_by 是排序，默认为 NULL，也就是按当前的顺序取偏移值 x &lt;- 1:5 lag(x) #&gt; [1] NA 1 2 3 4 lead(x) #&gt; [1] 2 3 4 5 NA lag(x, n = 2, default = 0) #&gt; [1] 0 0 1 2 3 # 向前 2 格取值，如果不存在则默认为 0 lead(x, n = 3, default = 999) [1] 4 5 999 999 999 # 向后 3 格取值，如果不存在则默认为 999 通常来说， lag 和 lead 的偏移量都是 1，用来做差异分析。 employee %&gt;% # 先排序 arrange(salary) %&gt;% # 后一个值与当前值相减，也就是计算前后两者的差异 mutate(salary_diff = lead(salary) - salary) %&gt;% select(name, salary, salary_diff) #&gt; name salary salary_diff #&gt; 1 张伟 7000 200 #&gt; 2 李元礼 7200 600 #&gt; 3 杨伯侨 7800 200 #&gt; 4 张伯仲 8000 800 #&gt; 5 陈梦妍 8800 0 #&gt; 6 况天佑 8800 200 #&gt; 7 孟轲舆 9000 0 #&gt; 8 赵蜚廉 9000 500 #&gt; 9 王雪梅 9500 100 #&gt; 10 陈淮阳 9600 400 #&gt; 11 沈约度 10000 0 #&gt; 12 马小玲 10000 1000 #&gt; 13 王珍珍 11000 1000 #&gt; 14 宋子启 12000 800 #&gt; 15 蒋欣 12800 NA 3.2.3.4 Cumulative aggregates 累计聚合函数 累计聚合函数用得最多的是 cumsum() 累计求和，以及 cumsum() 累计求均值。 其他的累计聚合函数：累计求最大cummax()、累计求最小cummin()、累计乘积cumprod()等。 employee %&gt;% group_by(title) %&gt;% arrange(title, salary) %&gt;% mutate(salary_cumsum = cumsum(salary), # mutate 中可以使用汇总函数 sum # 每个分组得到一个结果 # 遵循循环补齐规则填充到每个组等长的向量 salary_total = sum(salary), salary_pct = salary / salary_total ) %&gt;% select(name, salary, salary_cumsum, salary_total, salary_pct) #&gt; Adding missing grouping variables: `title` #&gt; Source: local data frame [15 x 6] #&gt; Groups: title [2] #&gt; #&gt; title name salary salary_cumsum salary_total salary_pct #&gt; &lt;chr&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 分析师 李元礼 7200 7200 66100 0.109 #&gt; 2 分析师 张伯仲 8000 15200 66100 0.121 #&gt; 3 分析师 陈梦妍 8800 24000 66100 0.133 #&gt; 4 分析师 况天佑 8800 32800 66100 0.133 #&gt; 5 分析师 王雪梅 9500 42300 66100 0.144 #&gt; 6 分析师 王珍珍 11000 53300 66100 0.166 #&gt; .. ... ... ... ... ... ... 3.2.4 多表操作 join 和 combine 3.2.4.1 mutating joins base 中的 merge() 函数可以用来合并数据框，但使用起来并不是那么顺手。 dplyr 中提供了有关 join 的函数来实现类似 SQL 中表连接功能。 a &lt;- data.frame(x1 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), x2 = c(1, 2, 3), stringsAsFactors = FALSE) b &lt;- data.frame(x1 = c(&quot;A&quot;, &quot;B&quot;, &quot;D&quot;), x3 = c(&quot;T&quot;, &quot;F&quot;, &quot;T&quot;), stringsAsFactors = FALSE) # left join left_join(a, b, by = &quot;x1&quot;) # by 是关联字段；关联不到的值变为 NA #&gt; x1 x2 x3 #&gt; 1 A 1 T #&gt; 2 B 2 F #&gt; 3 C 3 &lt;NA&gt; # 如果 by 省略则按相同变量名称来关联，但会给出一个警告信息 left_join(a, b) #&gt; Joining, by = &quot;x1&quot; #&gt; x1 x2 x3 #&gt; 1 A 1 T #&gt; 2 B 2 F #&gt; 3 C 3 &lt;NA&gt; # right join right_join(a, b, by = &quot;x1&quot;) # 右连接的结果是 b 在前 #&gt; x1 x2 x3 #&gt; 1 A 1 T #&gt; 2 B 2 F #&gt; 3 D NA T # inner join # 在 SQL 中 inner join 可以省略简化为 join, 但在 R 中不能省略，没有定义 join() 函数 inner_join(a, b, by = &quot;x1&quot;) #&gt; x1 x2 x3 #&gt; 1 A 1 T #&gt; 2 B 2 F # full join full_join(a, b, by = &quot;x1&quot;) # 包含两个表中都有的值 #&gt; x1 x2 x3 #&gt; 1 A 1 T #&gt; 2 B 2 F #&gt; 3 C 3 &lt;NA&gt; #&gt; 4 D NA T 表连接中字段名称不同时，可以在 by 中指定对应关系。 authors &lt;- data.frame( surname = I(c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;)), nationality = c(&quot;US&quot;, &quot;Australia&quot;, &quot;US&quot;, &quot;UK&quot;, &quot;Australia&quot;), deceased = c(&quot;yes&quot;, rep(&quot;no&quot;, 4))) books &lt;- data.frame( name = I(c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;, &quot;R Core&quot;)), title = c(&quot;Exploratory Data Analysis&quot;, &quot;Modern Applied Statistics ...&quot;, &quot;LISP-STAT&quot;, &quot;Spatial Statistics&quot;, &quot;Stochastic Simulation&quot;, &quot;Interactive Data Analysis&quot;, &quot;An Introduction to R&quot;), other.author = c(NA, &quot;Ripley&quot;, NA, NA, NA, NA, &quot;Venables &amp; Smith&quot;)) # by 中两个变量的名称，与join中表之间有对应关系 # by 中第一个变量对应的是第一个表 inner_join(authors, books, by = c(&quot;surname&quot; = &quot;name&quot;), copy = TRUE) #&gt; surname nationality deceased title other.author #&gt; 1 Tukey US yes Exploratory Data Analysis &lt;NA&gt; #&gt; 2 Venables Australia no Modern Applied Statistics ... Ripley #&gt; 3 Tierney US no LISP-STAT &lt;NA&gt; #&gt; 4 Ripley UK no Spatial Statistics &lt;NA&gt; #&gt; 5 Ripley UK no Stochastic Simulation &lt;NA&gt; #&gt; 6 McNeil Australia no Interactive Data Analysis &lt;NA&gt; # 用不同变量名之间来关联看起来有点复杂 # 可以先将关联的字段名称改为相同的再关联会显得容易些 books %&gt;% rename(surname = name) %&gt;% inner_join(authors, copy = TRUE) #&gt; Joining, by = &quot;surname&quot; #&gt; surname title other.author nationality deceased #&gt; 1 Tukey Exploratory Data Analysis &lt;NA&gt; US yes #&gt; 2 Venables Modern Applied Statistics ... Ripley Australia no #&gt; 3 Tierney LISP-STAT &lt;NA&gt; US no #&gt; 4 Ripley Spatial Statistics &lt;NA&gt; UK no #&gt; 5 Ripley Stochastic Simulation &lt;NA&gt; UK no #&gt; 6 McNeil Interactive Data Analysis &lt;NA&gt; Australia no 3.2.4.2 filtering joins filtering join 只是将关联作为过滤条件，但不要被关联表的变量。 # 半连接 # 等价于 select a.* from a inner join b on a.x1 = b.x1 semi_join(a, b, by = &quot;x1&quot;) #&gt; x1 x2 #&gt; 1 A 1 #&gt; 2 B 2 # 反连接 # 等价于 select a.* from a left join b on a.x1 = b.x1 where b.x3 is null anti_join(a, b, by = &quot;x1&quot;) #&gt; x1 x2 #&gt; 1 C 3 3.2.5 合并 combine y &lt;- data.frame(x1 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), x2 = c(1, 2, 3), stringsAsFactors = FALSE) z &lt;- data.frame(x1 = c(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;), x2 = c(2, 3, 4), stringsAsFactors = FALSE) # 并集(结果合并) # 类似于 SQL 中 union all rbind(y, z) #&gt; x1 x2 #&gt; 1 A 1 #&gt; 2 B 2 #&gt; 3 C 3 #&gt; 4 B 2 #&gt; 5 C 3 #&gt; 6 D 4 # 并集(结果排重) # 类似于 SQL 中 union union(y, z) #&gt; [[1]] #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; #&gt; #&gt; [[2]] #&gt; [1] 1 2 3 #&gt; #&gt; [[3]] #&gt; [1] &quot;B&quot; &quot;C&quot; &quot;D&quot; #&gt; #&gt; [[4]] #&gt; [1] 2 3 4 # 交集 # 类似于 SQL 中 intersect intersect(y, z) #&gt; data frame with 0 columns and 0 rows # 差集 # 类似于 SQL 中 minus setdiff(y, z) #&gt; x1 x2 #&gt; 1 A 1 #&gt; 2 B 2 #&gt; 3 C 3 "]
]
