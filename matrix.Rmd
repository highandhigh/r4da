## 矩阵 matrix

```{r, echo=FALSE}
load(file = "rdata/height.RData")
load(file = "rdata/weight.RData")
load(file = "rdata/islocal.RData")
load(file = "rdata/name.RData")
load(file = "rdata/gender.RData")
load(file = "rdata/grade.RData")
load(file = "rdata/birthday.RData")
```

### 创建矩阵


矩阵是线性代数上常用的一个概念，是由行和列组成的数据结构。

创建矩阵的方法是通过 matrix() 函数来定义。

```{r,eval=FALSE}
# 矩阵的定义函数、参数及参数默认值
matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
# 参数
# data 是原始数据，通常是一个向量
# nrow 是行的数量（行数）
# ncol 是列的数量（两书）
# byrow 是原始数据（向量）是否按行排列填充，默认 FALSE 则默认不按行排列，即默认按列来排列填充
# dimnames 是维度的名称属性，也就是行和列的名称向量，默认是空（不启用名称属性）
```

通过向量来创建矩阵，可以看做是将原来一维的向量元素，按照行和列重新排列填充，形成一个新结构的对象。

比如我们对原来15名员工的身高进行重排列变成一个3行5列的矩阵：

```{r}
height <- c(1:15)
print(height) # 先将原来15名员工的身高数据显示出来
matrix(data = height, nrow = 3, ncol = 5) # 将身高 height 数据转变成3*5的矩阵
# 对比height向量和新矩阵数据，两者包含的数据和顺序都一样
# 两者只是排列方式从一维数据，变成了3行5列的二维数据
# 可以将员工每连续3个一组分共5组，或者每隔5个分为一组共3组
```

数据的排列方式默认是按列填充，但可以更改
```{r}
m_height <- matrix(data = height, nrow = 3, ncol = 5, byrow = TRUE) # 排列方式更为按行填充
print(m_height)
```

### 矩阵维度

矩阵有一个属性叫做`维度(dim)`，因为矩阵是二维的，所以矩阵的维度分别是行和列，其值就是`行数(nrow)`和`列数(ncol)`组成的包含两个整数的向量。

```{r}
dim(m_height) 
# 第一个数值对应的就是 nrow ，第二个数值对应的就是 ncol
# nrow 和 ncol 与 matrix() 矩阵定义中两个参数 nrow 和 ncol 是一一对应的
# nrow 的全称是 Number of Rows
# ncol 的全称是 Number of Columns
```

如果只需要单独获得矩阵的行数或者列数，可则使用 `nrow()` 和 `ncol()`.
```{r}
nrow(m_height) # 行数；等价于 dim(m_height)[1]
ncol(m_height) # 列数；等价于 dim(m_height)[2]
```

R语言中每个对象都有其长度，对矩阵而言，`length()`返回的是矩阵所有元素的个数，并且等于矩阵的行数与列数乘积。

对矩阵而言，长度并不是一个常用的概念；更多的时候，用行数和列数更实用。
```{r}
length(m_height) # 矩阵的长度表示矩阵的所有元素个数
#等价于行数与列数的乘积
nrow(m_height) * ncol(m_height) 
```


### 矩阵索引

类似于向量通过`[]`来索引定位具体的元素，矩阵也沿用此方法，但需要行和列两部分`[,]`才能索引定位到具体的元素，他们中间用逗号分隔，前者表示行索引，后者表示列索引。

#### 位置整数索引

矩阵位置索引的逻辑与向量是一样的，只是索引需要行和列两部分构成。

* 通过第n行第m列来定位一个具体的单个元素。

* 通过某几行（向量）、某几列（向量）来定位某些元素。

* 如果行或者列没有输入（即缺省），则表示不限制具体的行或者列（也就是所有行或者所有列）。

* 去掉某几行或者莫几列，用对应的负数。

```{r}
m_height # 原矩阵，打印到屏幕上，后续的索引解决与此对比验证
m_height[3,4, drop = FALSE] # 第3行，第4列的元素
m_height[c(1,3),c(2,5)] # 第1和第3行，第2和第5列的元素
m_height[c(1,3),] # 第1和第3行，所有列的元素
m_height[,c(2,5)] # 所有行，第2和第5列的元素
m_height[-2,c(2,5)] # 去除第2行，包含第2和第5列的元素
```

#### 逻辑向量索引

类似于向量，矩阵的逻辑索引由行和列对应的两个逻辑向量完成，索引的结果就是对应为`TRUE`的行和列。

行和列的逻辑向量的长度，分别等于 `nrow` 和 `ncol`; 如果逻辑索引向量的长度小于矩阵的行列数则遵循向量循环补齐原则。

```{r}
m_height # 原矩阵
m_height[c(TRUE, FALSE, TRUE), c(TRUE, FALSE, TRUE, FALSE,TRUE)] # 第3行，第4列的元素
m_height[c(TRUE, FALSE), c(TRUE, TRUE, FALSE)] # 行列索引的向量长度小于矩阵的行列数，索引的向量遵循循环补齐原则

# 循环补齐后等价于 
m_height[c(TRUE, FALSE, TRUE), c(TRUE, TRUE, FALSE, TRUE, TRUE)] 
```

#### 逻辑矩阵

通过逻辑表达式可以获得对应的逻辑矩阵。
```{r}
m_height > 1.7 # 矩阵中哪些元素大于 1.7
```

通过逻辑矩阵来索引矩阵，得到的是矩阵中对应逻辑为真的元素，是一个向量。

```{r}
m_height[m_height > 1.7] # 索引大于 1.7 的元素
```

#### 行列名称索引

在矩阵创建时可以定义行和列的名称，但也可以在创建创建后再定义行和列的名称，这种方法更为实用。

通过`rownames()` 来定义行名称， `colnames()`来定义列名称。

```{r}
rownames(m_height) <- c("A", "B", "C") # 行名称
colnames(m_height) <- c("col_1", "col_2", "col_3", "col_4", "col_5") # 列名称
print(m_height)
```

在有了矩阵的名称属性之后，就可以通过行和列的名称属性来索引向量。

```{r}
m_height[c("A", "C"), c("col_1", "col_3", "col_5")]
```


#### subset筛选行和列

`subset(x, subset, select)`函数可以对矩阵使用，筛选符合条件的行和列。

`subset` 参数是针对要筛选行的条件，是一个逻辑表达式，长度与函数相同。

`select` 参数是针对要筛选的列条件，可以是位置（列数）的整数向量，也可以是列名（如果有列名称属性的话）的字符向量。

```{r}
subset(m_height, m_height[,1] > 1.7, 2:4) # 筛选矩阵第1列中大于1.7的行，并提取第2到第4列

subset(m_height, m_height[,5] > 1.7, c("col_1", "col_3", "col_5")) # 筛选矩阵第5列中大于1.7的行，并提取名字为"col_1"、"col_3"、"col_5"的列

subset(m_height, m_height[,1] > 1.7, m_height[3,] > 1.7) # 筛选矩阵第1列中大于1.7的行，筛选矩阵第3行中大于1.7的列
```

`subset`函数虽然对矩阵有效，但是并不常用。


#### head/tail筛选首尾行

`head()` 和 `tail()`同样适用与矩阵，但是参数 n 表示的是行数；也就是只能筛选行，而不能筛选列。
```{r}
head(m_height, n = 2) # 
tail(m_height, 2)
```


### 矩阵合并

类似于向量合并是用`c()`函数，矩阵的合并分为按行合并 `rbind()` 和 按列合并 `cbind()`。

按行合并，要求合并的矩阵其列数相同；按列合并，要求合并的矩阵其行数相同；否则会报错。

```{r}
mc_height <- matrix(data = height, nrow = 3, ncol = 5, byrow = FALSE) # 排列方式更为按列填充
mr_height <- matrix(data = height, nrow = 3, ncol = 5, byrow = TRUE) # 排列方式更为按行填充
print(mc_height)
print(mr_height)
rbind(mc_height, mr_height) # 按行合并
cbind(mc_height, mr_height) # 按列合并
```

### 矩阵计算

#### 矩阵算术运算

矩阵算术运算与向量类似，对应元素之间的运算。

```{r}
m_height <- matrix(data = height, nrow = 3, ncol = 5, byrow = TRUE) # 排列方式更为按行填充
m_weight <- matrix(data = weight, nrow = 3, ncol = 5, byrow = TRUE) # 排列方式更为按行填充
m_weight/(m_height^2) # 身高质量指数；对应元素之间做算术运算
```

#### 矩阵代数运算

矩阵代数运算，有一套自己特有的法则，对应了特殊的运算符号和函数。

```{r}
print(m_height)
t(m_height) # 转置，行列转化
det(m_height[1:3,1:3]) # 求行列式，要求矩阵必须是方阵（正方形矩阵，行数和列数相同）
diag(m_height[1:3,1:3]) # 求矩阵对角线上的元素
```

线性代数中有非常多的矩阵性质与运算逻辑，这里不一一列出。


### 矩阵检验与转化

矩阵是一种基于向量上构建的特殊结构，其类属性为 `matrix`，有一个特殊的维度属性 `dim`。

检验一个对象是否为矩阵，实际上是验证该对象的类是否为 matrix 及是否具有 dim 属性及 dim 的结果是否为包含连个整数值的向量。

类判断函数，本质上是去校验对象是否符合对应类的定义。

```{r}
class(m_height) # 显示对象的类，如果是矩阵，就显示为 matrix
is.matrix(m_height) # 对象是否为矩阵
as.matrix(height) # 将对象转化为矩阵
# 这里待转化对象是向量故而结果为列数等于1的矩阵，行数等于向量的长度
```


## 数组 array

数组可以看做是具有多维结构的向量，也就是将原本一维的向量，改变索引结构变为多维表示。

创建数组的方法是通过 array() 函数。

```{r, eval = FALSE}
array(data = NA, dim = length(data), dimnames = NULL)
# data 是要创建数组的向量，其元素用于构建数组
# dim 为数组的维数向量(为数值型向 量)
# dimnames 为由各维的名称构成的向量(为字符型向量)
```

比如，将 `1:30` 的向量，按照 `2*3*5` 的3维结构重新排列为数组，则需要三个位置数字向量才能定位到一个具体的元素。

```{r}
a <- array(1:30, dim = c(2, 3, 5))
print(a) # 因为该数组是3维结构，而屏幕只能显示2维平面，故而按第3个维度每个维数切片显示
dim(a) # 维度向量，按顺序分别代表了每个维度的维数
class(a) # 对象的类，如果是数组，则结果为 array
is.array(a) # 检验对象是否为数组类：判断元素的模式是否相同，判断dim属性是否不为NULL
```

矩阵是数组在二维结构上的特殊形式。因为矩阵在数学上常用，且有一套矩阵运算和代数上的意义，故而将其独立作为一个类。

数组的索引，类似矩阵，只是维数不同。不同维度的索引，中间用逗号隔开。

```{r}
a[2, 1, 4] # 第1为第2个切片，第2为的第1个切片，第3为的第4个切片，三个维度联合定位的元素 
a[1:2, c(2,3), c(1,4,5)] # 第1为第1到2个切片，第2为的第2和第3个切片，第3为的第1第4和第5个切片
```

同样可以使用名称索引，如果有名称属性的话。

每个维度的索引也可以使用对应的逻辑向量，其长度与对应的维数相同。

`subset()`和`head()/tail()`函数，虽然可以对应用在数据上，但并无实际上的意义。
